Übereinstimmungen in Binärdatei ./Data-Processor-0.3.0.tar.gz.
./META.json:   "meta-spec" : {
./META.json:   "name" : "Data-Processor",
./META.json:         "web" : "https://github.com/maettu/Data-Processor/issues"
./META.json:      "homepage" : "https://github.com/maettu/Data-Processor",
./META.json:         "url" : "https://github.com/maettu/Data-Processor.git",
./META.json:         "web" : "https://github.com/maettu/Data-Processor"
./README.md:Data::Processor - Transform Perl Data Structures, Validate Data against a Schema, Produce Data from a Schema, or produce documentation directly from information in the Schema.
./README.md:                      # undef is "no-error" -> success.
./README.md:                          if $self->{value} == 42;
./README.md:    my $p = Data::Processor->new($schema);
./README.md:    my $error_collection = $p->validate($data, verbose=>0);
./README.md:    # no errors :-)
./README.md:    my $processor = Data::Processor->new($schema);
./README.md:\- indent: count of spaces to insert when printing in verbose mode. Default 4
./README.md:\- depth: level at which to start. Default is 0.
./README.md:\- verbose: Set to a true value to print messages during processing.
./README.md:    my $error_collection = $processor->validate($data, verbose=>0);
./README.md:    my $error_collection = $processor->validate_schema();
./README.md:Transforms the data in-place.
./README.md:    my $validator = Data::Processor::Validator->new($schema, data => $data)
./README.md:    my $error_string = $processor->transform($key, $validator);
./README.md:    my $data = $processor->make_data(data=>$data);
./README.md:    my $pod_string = $processor->make_pod();
./README.md:Copyright 2015- Matthias Bloch
./Changes:Revision history for Data-Processor
./Changes:0.3.0  2015-01-24 23:01:34 CET
./Changes:    - data template generator
./Changes:0.2.0  2015-01-24 22:12:26 CET
./Changes:    - Pod writer
./Changes:    - schema validator
./Changes:0.1.7  2015-01-23 20:31:53 CET
./Changes:    - Transformer, basic (not very useful yet)
./Changes:0.1.6  2015-01-23 16:50:55 CET
./Changes:    - no more "require"
./Changes:    - code cleanup
./Changes:0.1.5  2015-01-22 16:50:24 CET
./Changes:    - Interface change: use positional parameters for $schema, $data
./Changes:0.1.4  2015-01-22 16:22:30 CET
./Changes:    - array support as of t/013_array.t 
./Changes:    - Transformer object
./Changes:    - Error::Instance handles more
./Changes:0.1.3  2015-01-20 09:43:14 CET
./Changes:    - not-ready and interface change warning added
./Changes:0.1.2  2015-01-19 11:15:29 CET
./Changes:    - Makefile.PL instead of Build.PL
./Changes:0.1.1  2015-01-18 21:48:47 CET
./Changes:    - more test (mostly ported from old module)
./Changes:    - ValidatorFactory
./Changes:0.1.0  2015-01-18 16:50:50 CET
./Changes:    - Error Collector added
./Changes:    - Basic functionality: validation without frills
./Changes:0.0.3  2015-01-15 21:37:19 CET
./Changes:0.0.2  2015-01-15 21:31:16 CET
./Changes:    - Code Layout
./Changes:0.0.1  2015-01-15 19:09:03 CET
./Changes:        - Initial release
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.json:   "meta-spec" : {
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.json:   "name" : "Data-Processor",
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.json:         "web" : "https://github.com/maettu/Data-Processor/issues"
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.json:      "homepage" : "https://github.com/maettu/Data-Processor",
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.json:         "url" : "https://github.com/maettu/Data-Processor.git",
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.json:         "web" : "https://github.com/maettu/Data-Processor"
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:---
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:  - 'Matthias Bloch <matthias.bloch@puffin.ch>'
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:meta-spec:
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:  url: http://module-build.sourceforge.net/META-spec-v1.4.html
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:name: Data-Processor
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:    - t
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:    - xt
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:    - inc
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:    - share
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:    - eg
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:    - examples
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:  bugtracker: https://github.com/maettu/Data-Processor/issues
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:  homepage: https://github.com/maettu/Data-Processor
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:  repository: https://github.com/maettu/Data-Processor.git
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:  - 'Dominik Hassler <hadfl@cpan.org>'
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:  - 'Tobias Oetiker <tobi@oetiker.ch>'
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.yml:  - 'maettu <matthias.bloch@puffin.ch>'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:# Data::Processor::Validator - Validate Data Against a Schema
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        errors => $p{errors}  // Data::Processor::Error::Collection->new(),
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        transformer => Data::Processor::Transformer->new(),
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    $self->{errors} = Data::Processor::Error::Collection->new();
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    $self->_add_defaults();
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{data}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->explain (">>'$key'");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        my $schema_key = $self->_schema_twin_key($key) or next;
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->__value_is_valid( $key );
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->__validator_returns_undef($key, $schema_key);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        my $e = $self->{transformer}->transform($key, $self);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->error($e) if $e;
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        if ($self->{schema}->{$schema_key}->{no_descend_into}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->explain (
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        if (! %{$self->{schema}->{$schema_key}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->explain ("skipping '$key' because schema key is empty'");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        if (! $self->{schema}->{$schema_key}->{members}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->explain (
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->explain (">>descending into '$key'\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        if (ref $self->{data}->{$key} eq ref {} ){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->explain
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            my $e = Data::Processor::Validator->new(
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                schema      => $self->{schema}->{$schema_key}->{members},
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                data        => $self->{data}->{$key},
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                parent_keys => [@{$self->{parent_keys}}, $key],
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                depth       => $self->{depth}+1,
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                verbose     => $self->{verbose},
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            ) ->validate();
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->{errors}->add_collection($e);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        elsif ((ref $self->{data}->{$key} eq ref [])
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            && $self->{schema}->{$schema_key}->{array}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->explain(
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            push @{$self->{parent_keys}}, $key;
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->{depth}++;
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            for my $member (@{$self->{data}->{$key}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                my $e = Data::Processor::Validator->new(
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                    schema      => $self->{schema}->{$schema_key}->{members},
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                    parent_keys => [@{$self->{parent_keys}}, $key],
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                    depth       => $self->{depth}+1,
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                    verbose     => $self->{verbose},
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                ) ->validate();
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                $self->{errors}->add_collection($e);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            pop @{$self->{parent_keys}};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->{depth}--;
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        # We cannot descend into a non-existing branch in data
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->explain(">>checking data key '$key' which is a leaf..");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$schema_key}->{members}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                $self->explain("but schema requires members.\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                $self->error("'$key' should have members");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                $self->explain("schema key is also a leaf. ok.\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    # look for missing non-optional keys in schema
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    $self->_check_mandatory_keys();
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    return $self->{errors};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    $self->{errors}->add(
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        path => $self->{parent_keys},
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    my $indent = ' ' x ($self->{depth}*$self->{indent});
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    print $string if $self->{verbose};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        next unless $self->{schema}->{$key}->{default};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->{data}->{$key} = $self->{schema}->{$key}->{default}
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            unless $self->{data}->{$key};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->explain(">>Checking if '$key' is mandatory: ");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        unless ($self->{schema}->{$key}->{optional}
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                   and $self->{schema}->{$key}->{optional}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->explain("true\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            next if $self->{data}->{$key};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            # regex-keys never directly occur.
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$key}->{regex}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                $self->explain(">>regex enabled key found. ");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                $self->explain("Checking data keys.. ");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                for my $c_key (keys %{$self->{data}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                $self->explain("$c matching occurencies found\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            next if $self->{schema}->{$key}->{array};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $error_msg = $self->{schema}->{$key}->{error_msg}
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                if $self->{schema}->{$key}->{error_msg};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->error("mandatory key '$key' missing. Error msg: '$error_msg'");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->explain("false\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    if ($self->{schema}->{$key}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->explain(" ok\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        for my $match_key (keys %{$self->{schema}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            next unless exists $self->{schema}->{$match_key}
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                           and $self->{schema}->{$match_key}->{regex};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                $self->explain("'$key' matches $match_key\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->explain(">>$key not in schema, keys available: ");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->explain(join (", ", (keys %{$self->{schema}})));
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->explain("\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->error("key '$key' not found in schema\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:# 'validator' specified gets this called to call the callback :-)
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    return unless $self->{schema}->{$schema_key}->{validator};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    $self->explain("running validator for '$key': $self->{data}->{$key}\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    if (ref $self->{data}->{$key} eq ref []
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        && $self->{schema}->{$key}->{array}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        for my $elem (@{$self->{data}->{$key}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            my $return_value = $self->{schema}->{$key}->{validator}->($elem, $self->{data});
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                $self->explain("validator error: $return_value (element $counter)\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                $self->error("Execution of validator for '$key' element $counter returns with error: $return_value");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                $self->explain("successful validation for key '$key' element $counter\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        my $return_value = $self->{schema}->{$key}->{validator}->($self->{data}->{$key}, $self->{data});
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->explain("validator error: $return_value\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->error("Execution of validator for '$key' returns with error: $return_value");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->explain("successful validation for key '$key'\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:    if (exists  $self->{schema}->{$key}
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            and $self->{schema}->{$key}->{value}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        $self->explain('>>'.ref($self->{schema}->{$key}->{value})."\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        if (ref($self->{schema}->{$key}->{value}) eq 'CODE'){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:        elsif (ref($self->{schema}->{$key}->{value}) eq 'Regexp'){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            if (ref $self->{data}->{$key} eq ref []
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                && $self->{schema}->{$key}->{array}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                for my $elem (@{$self->{data}->{$key}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                    $self->explain(">>match '$elem' against '$self->{schema}->{$key}->{value}'");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                    if ($elem =~ m/^$self->{schema}->{$key}->{value}$/){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                        $self->explain(" ok.\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                        $self->explain(" no.\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                        $self->error("$elem does not match ^$self->{schema}->{$key}->{value}\$");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:               $self->explain(">>match '$self->{data}->{$key}' against '$self->{schema}->{$key}->{value}'");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                if ($self->{data}->{$key} =~ m/^$self->{schema}->{$key}->{value}$/){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                    $self->explain(" ok.\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                    $self->explain(" no.\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:                    $self->error("$self->{data}->{$key} does not match ^$self->{schema}->{$key}->{value}\$");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->explain("neither CODE nor Regexp\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Validator.pm:            $self->error("'$key' not CODE nor Regexp");
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/ValidatorFactory.pm:Data::Processor::ValidatorFactory - create validators for use in schemas
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/ValidatorFactory.pm: my $vf = Data::Processor::ValidatorFactory->new;
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->file('>','writing'),
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->rx(qr{[A-Z]+},'expected name made up from capital letters')
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->any(qw(UP DOWN))
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/ValidatorFactory.pm: $vf->file('<','reading');
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/ValidatorFactory.pm: $vf->file('>>','appending to');
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/ValidatorFactory.pm: $vf->dir();
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/ValidatorFactory.pm:        return undef if -d $value;
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/ValidatorFactory.pm: $vf->rx(qr{[A-Z]+},'use uppercase letters')
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/ValidatorFactory.pm: $vf->any(qw(ON OFF))
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Transformer.pm:    if (exists $section->{schema}->{$key}
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Transformer.pm:        and exists $section->{schema}->{$key}->{transformer}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Transformer.pm:                $section->{schema}->{$key}->{transformer}
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Transformer.pm:                ->($section->{data}->{$key},$section->{data});
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Transformer.pm:            if (ref $err eq 'HASH' and $err->{msg}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Transformer.pm:                $err = $err->{msg};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Transformer.pm:            $section->{data}->{$key} = $return_value;
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Instance.pm:        $self->{$_} // die "$_ missing";
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Instance.pm:    $self->{path_array} = $self->{path};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Instance.pm:    $self->{path} = join '->', @{$self->{path}};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Instance.pm:    $self->{caller} = "$sub line $line";
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Instance.pm:    return $self->{path}. ": " . $self->{message};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:Data::Processor::Error::Collection - Collect errors for Data::Processor
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:    my $errors = Data::Processor::Error::Collection->new();
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:- message
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:- path
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:    my $error = Data::Processor::Error::Instance->new(%p);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $error;
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $e;
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:    my @e = $other->as_array();
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:        $self->add_error($_);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:  $error->collection->any_error_contains(
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:    for my $error (@{$self->{errors}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:        return 1 if $error->{$p{field}} =~ /$p{string}/;
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:    return @{$self->{errors}};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor/Error/Collection.pm:    return scalar @{$self->{errors}};
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:Data::Processor - Transform Perl Data Structures, Validate Data against a Schema, Produce Data from a Schema, or produce documentation directly from information in the Data
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm: my $processor = Data::Processor->new($schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:- indent: count of spaces to insert when printing in verbose mode. Default 4
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:- depth: level at which to start. Default is 0.
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:- verbose: Set to a true value to print messages during processing.
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:        errors      => Data::Processor::Error::Collection->new(),
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm: my @errors = $processor->validate($data, verbose=>0);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:    $self->{validator}=Data::Processor::Validator->new(
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:        schema      => $self->{schema} // $p{schema},
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:        verbose     => $p{verbose} // $self->{verbose} // undef,
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:        errors      => $self->{errors},
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:        depth       => $self->{depth},
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:        indent      => $self->{indent},
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:        parent_keys => $self->{parent_keys},
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:    return $self->{validator}->validate();
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm: my ($data_transformed, @errors) = $processor->transform_data(data=>$data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm: my ($schema_transformed, @errors) = $processor->transform_schema(schema=>$schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm: my ($data, @errors) = $processor->make_data(data=>$data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm: my ($pod, @errors) = $processor->make_pod(data=>$data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/lib/Data/Processor.pm:Copyright 2015- Matthias Bloch
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.\" Set up some character translations and predefined strings.  \*(-- will
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.tr \(*W-
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    ds -- \(*W-
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    ds -- \|\(em\|
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    \" troff and (daisy-wheel) nroff accents
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.ds ae a\h'-(\w'a'u*4/10)'e
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.ds Ae A\h'-(\w'A'u*4/10)'E
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    ds d- d\h'-1'\(ga
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.    ds D- D\h'-1'\(hy
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:.TH Data::Processor::ValidatorFactory 3 "2015-01-23" "perl v5.16.3" "User Contributed Perl Documentation"
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:Data::Processor::ValidatorFactory \- create validators for use in schemas
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:\& my $vf = Data::Processor::ValidatorFactory\->new;
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:\&        validator => $vf\->file(\*(Aq>\*(Aq,\*(Aqwriting\*(Aq),
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:\&        validator => $vf\->rx(qr{[A\-Z]+},\*(Aqexpected name made up from capital letters\*(Aq)
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:\&        validator => $vf\->any(qw(UP DOWN))
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:\& $vf\->file(\*(Aq<\*(Aq,\*(Aqreading\*(Aq);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:\& $vf\->file(\*(Aq>>\*(Aq,\*(Aqappending to\*(Aq);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:\& $vf\->dir();
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:\& $vf\->rx(qr{[A\-Z]+},\*(Aquse uppercase letters\*(Aq)
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:\& $vf\->any(qw(ON OFF))
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::ValidatorFactory.3:Copyright (c) 2015 by \s-1OETIKER+PARTNER\s0 \s-1AG\s0. All rights reserved.
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.\" Set up some character translations and predefined strings.  \*(-- will
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.tr \(*W-
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    ds -- \(*W-
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    ds -- \|\(em\|
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    \" troff and (daisy-wheel) nroff accents
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.ds ae a\h'-(\w'a'u*4/10)'e
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.ds Ae A\h'-(\w'A'u*4/10)'E
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    ds d- d\h'-1'\(ga
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.    ds D- D\h'-1'\(hy
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:.TH Data::Processor 3 "2015-01-23" "perl v5.16.3" "User Contributed Perl Documentation"
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:Data::Processor \- Transform Perl Data Structures, Validate Data against a Schema, Produce Data from a Schema, or produce documentation directly from information in the Data
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\& my $processor = Data::Processor\->new($schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\&\- indent: count of spaces to insert when printing in verbose mode. Default 4
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\&\- depth: level at which to start. Default is 0.
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\&\- verbose: Set to a true value to print messages during processing.
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\& my @errors = $processor\->validate($data, verbose=>0);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\&\s-1UNIMPLEMENTED\s0
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\& my ($data_transformed, @errors) = $processor\->transform_data(data=>$data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\&\s-1UNIMPLEMENTED\s0
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\& my ($schema_transformed, @errors) = $processor\->transform_schema(schema=>$schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\&\s-1UNIMPLEMENTED\s0
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\& my ($data, @errors) = $processor\->make_data(data=>$data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\&\s-1UNIMPLEMENTED\s0
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:\& my ($pod, @errors) = $processor\->make_pod(data=>$data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor.3:Copyright 2015\- Matthias Bloch
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.\" Set up some character translations and predefined strings.  \*(-- will
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.tr \(*W-
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    ds -- \(*W-
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    ds -- \|\(em\|
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    \" troff and (daisy-wheel) nroff accents
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.ds ae a\h'-(\w'a'u*4/10)'e
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.ds Ae A\h'-(\w'A'u*4/10)'E
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    ds d- d\h'-1'\(ga
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.    ds D- D\h'-1'\(hy
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.TH Data::Processor::Error::Collection 3 "2015-01-23" "perl v5.16.3" "User Contributed Perl Documentation"
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.SH "NAME Data::Processor::Error::Collection \- Collect errors for Data::Processor"
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.IX Header "NAME Data::Processor::Error::Collection - Collect errors for Data::Processor"
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:\&    my $errors = Data::Processor::Error::Collection\->new();
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.SS "add Adds an error. parameters: \- message \- path"
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.IX Subsection "add Adds an error. parameters: - message - path"
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.ie n .SS "any_error_contains Return true if any of the collected errors contains a given string. $error\->collection\->any_error_contains( string => ""error_msg"", field  => ""message"", # any of the data fields of an error );"
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.el .SS "any_error_contains Return true if any of the collected errors contains a given string. \f(CW$error\fP\->collection\->any_error_contains( string => ``error_msg'', field  => ``message'', # any of the data fields of an error );"
./.build/OkDOcJKakw/Data-Processor-0.1.6/blib/libdoc/Data::Processor::Error::Collection.3:.IX Subsection "any_error_contains Return true if any of the collected errors contains a given string. $error->collection->any_error_contains( string => error_msg, field  => message, # any of the data fields of an error );"
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:Revision history for Data-Processor
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:0.1.6  2015-01-23 16:49:56 CET
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - no more "require"
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - code cleanup
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:0.1.5  2015-01-22 16:50:24 CET
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - Interface change: use positional parameters for $schema, $data
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:0.1.4  2015-01-22 16:22:30 CET
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - array support as of t/013_array.t 
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - Transformer object
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - Error::Instance handles more
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:0.1.3  2015-01-20 09:43:14 CET
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - not-ready and interface change warning added
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:0.1.2  2015-01-19 11:15:29 CET
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - Makefile.PL instead of Build.PL
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:0.1.1  2015-01-18 21:48:47 CET
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - more test (mostly ported from old module)
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - ValidatorFactory
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:0.1.0  2015-01-18 16:50:50 CET
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - Error Collector added
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - Basic functionality: validation without frills
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:0.0.3  2015-01-15 21:37:19 CET
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:0.0.2  2015-01-15 21:31:16 CET
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:    - Code Layout
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:0.0.1  2015-01-15 19:09:03 CET
./.build/OkDOcJKakw/Data-Processor-0.1.6/Changes:        - Initial release
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:---
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:  - 'Matthias Bloch <matthias.bloch@puffin.ch>'
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:meta-spec:
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:  url: http://module-build.sourceforge.net/META-spec-v1.4.html
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:name: Data-Processor
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:    - t
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:    - xt
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:    - inc
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:    - share
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:    - eg
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:    - examples
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:  bugtracker: https://github.com/maettu/Data-Processor/issues
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:  homepage: https://github.com/maettu/Data-Processor
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:  repository: https://github.com/maettu/Data-Processor.git
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:  - 'Dominik Hassler <hadfl@cpan.org>'
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:  - 'Tobias Oetiker <tobi@oetiker.ch>'
./.build/OkDOcJKakw/Data-Processor-0.1.6/META.yml:  - 'maettu <matthias.bloch@puffin.ch>'
./.build/OkDOcJKakw/Data-Processor-0.1.6/MANIFEST:t/release-pod-syntax.t
./.build/OkDOcJKakw/Data-Processor-0.1.6/Build:#!/home/ti/perl5/perlbrew/perls/perl-5.16.3/bin/perl
./.build/OkDOcJKakw/Data-Processor-0.1.6/Build.PL:# This Build.PL for Data-Processor was generated by Dist::Zilla::Plugin::ModuleBuildTiny 0.008.
./.build/OkDOcJKakw/Data-Processor-0.1.6/Makefile.PL:      license     => 'http://www.opensource.org/licenses/artistic-license-2.0',
./.build/OkDOcJKakw/Data-Processor-0.1.6/Makefile.PL:      repository  => 'https://github.com/maettu/Data-Structure-Validation',
./.build/OkDOcJKakw/Data-Processor-0.1.6/Makefile.PL:      bugtracker  => 'https://github.com/maettu/Data-Structure-Validation/issues'
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:This software is copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:--- The GNU General Public License, Version 1, February 1989 ---
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE: 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:software--to make sure the software is free for all its users.  The
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:    a) accompany it with the complete corresponding machine-readable
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:    for the cost of distribution) a complete machine-readable copy of the
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA  02110-1301 USA
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:c'; they could even be mouse-clicks or menu items--whatever suits your
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:--- The Artistic License 1.0 ---
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:the package the right to use and distribute the Package in a more-or-less
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:  - "Package" refers to the collection of files distributed by the Copyright
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:  - "Standard Version" refers to such a Package if it has not been modified,
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:  - "Copyright Holder" is whoever is named in the copyright or copyrights for
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:  - "You" is you, if you're thinking about copying or distributing this Package.
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:  - "Reasonable copying fee" is whatever you can justify on the basis of media
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:  - "Freely Available" means that no fee is charged for the item itself, though
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:  c) rename any non-standard executables so the names do not conflict with
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:     manual page for each non-standard executable that clearly documents how it
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:  b) accompany the distribution with the machine-readable source of the Package
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:  c) accompany any non-standard executables with their corresponding Standard
./.build/OkDOcJKakw/Data-Processor-0.1.6/LICENSE:     Version executables, giving the non-standard executables non-standard
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.json:   "meta-spec" : {
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.json:   "name" : "Data-Processor",
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.json:         "web" : "https://github.com/maettu/Data-Processor/issues"
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.json:      "homepage" : "https://github.com/maettu/Data-Processor",
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.json:         "url" : "https://github.com/maettu/Data-Processor.git",
./.build/OkDOcJKakw/Data-Processor-0.1.6/MYMETA.json:         "web" : "https://github.com/maettu/Data-Processor"
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(verbose => 1);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}, 'section "GENERAL" exists');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}->{logfile}, '"logfile" exists');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/100_make_config_template.t:#~ ok ($config_template->{GENERAL}->{logfile} = 'absolute path to logfile (?-xism:/.*)', 'logifle has correct content');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(entry_point => $schema->{GENERAL}->{members}->{silos});
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/100_make_config_template.t:#~ ok (exists $config_template->{'silo-.+'}, 'entry point "silos" found');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/100_make_config_template.t:#~ ok ($config_template->{'silo-.+'}->{url} eq 'url of the silo server. Only https:// allowed(?^:https.*)',
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/007_no_value_check.t:my $p = Data::Processor->new($schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/007_no_value_check.t:my $error_collection = $p->validate($data, verbose=>0);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/007_no_value_check.t:ok ($error_collection->count==0, 'no errors');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/007_no_value_check.t:$error_collection = $p->validate($data, verbose=>0);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/007_no_value_check.t:ok ($error_collection->count==0, 'still no errors');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/010_transformer.t:                return ($1 * $timespecfactor->{($2 || 's')});
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/010_transformer.t:        transformer => $transformer->{timespec}(
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/010_transformer.t:my $validator = Data::Processor->new($schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/010_transformer.t:my $error_collection = $validator->validate($data, verbose=>0);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/010_transformer.t:ok ($data->{history} == 3600, 'transformed "1h" into "3600"');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/010_transformer.t:    history => 'regards, your error :-)',
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/010_transformer.t:$error_collection = $validator->validate($data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/010_transformer.t:ok ($data->{history} eq 'regards, your error :-)',
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/010_transformer.t:    'Could not transform "regards, your error :-)"');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/010_transformer.t:ok ($error_collection->{errors}[0]->{message}
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/011_default_values.t:my $p = Data::Processor->new($schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/011_default_values.t:my $error_collection = $p->validate($data, verbose=>0);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/011_default_values.t:ok ($data->{key_with_default_value}==42,
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/005_synopsis.t:                    # undef is "no-error" -> success.
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/005_synopsis.t:                        if $self->{value} == 42;
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/005_synopsis.t:my $p = Data::Processor->new($schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/005_synopsis.t:my $error_collection = $p->validate($data, verbose=>0);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/005_synopsis.t:# no errors :-)
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/005_synopsis.t:ok ($error_collection->count==0, 'no errors');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/013_array.t:my $p = Data::Processor->new($schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/013_array.t:my $error_collection = $p->validate($data, verbose=>0);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/013_array.t:ok ($error_collection->count == 8, '8 errors detected');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/013_array.t:ok ($error_collection->any_error_contains(
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/008_error_stringify.t:my $validator = Data::Processor->new($schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/008_error_stringify.t:my $error_collection = $validator->validate($data, verbose=>0);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/008_error_stringify.t:ok ($error_collection->count==1, '1 error');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/008_error_stringify.t:my $msg = $error_collection->{errors}[0]->stringify();
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/012_factory.t:my $vf = Data::Processor::ValidatorFactory->new;
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/012_factory.t:like ($vf->file('<','oops')->('/tmp/xkddf'),qr/oops/, 'error message generated');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/012_factory.t:is ($vf->rx(qr{XX},'oops')->('xxXXx'),undef,'regular expression check');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/012_factory.t:is ($vf->any(qw(OFF ON))->('OFF'),undef, 'is it one of the list');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/012_factory.t:is ($vf->dir()->('/'),undef, 'directory exists');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:my $processor = Data::Processor->new($schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:eval{$processor->validate()};
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:my $error_collection = $processor->validate($data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:my @errors = $error_collection->as_array();
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->count()==2, 'error count =2');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->any_error_contains(
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->any_error_contains(
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->any_error_contains(
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:        string => "silo-a",
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:    "missing value from 'silo-a'"
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->any_error_contains(
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:        logfile => '/tmp/n3k-poller.log',
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:        cachedb => '/tmp/n3k-cache.db',
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:            'silo-a' => {
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:                url => 'https://silo-a/api',
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:                key => 'my-secret-shared-key',
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:$error_collection = $processor->validate($data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->count==0, 'no more errors with corrected config');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:use Data::Dumper; print Dumper $error_collection->as_array;
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:$error_collection = $processor->validate($data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->count==2, '2 errors');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->any_error_contains(
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:            logfile => '/tmp/n3k-poller.log',
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:            cachedb => '/tmp/n3k-cache.db',
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:                'silo-a' => {
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:                    url => 'https://silo-a/api',
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:                    key => 'my-secret-shared-key',
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:                    # "members" stands for all "non-internal" fields
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:                        'silo-.+' => {
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/002_validate.t:                                    example     => 'https://silo-a/api',
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/001_basic.t:my $processor = Data::Processor->new();
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/006_regex_keys.t:my $p = Data::Processor->new($schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/006_regex_keys.t:my $error_collection = $p->validate($data, verbose=>0);
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/006_regex_keys.t:ok ($error_collection->count==3, '3 errors detected');
./.build/OkDOcJKakw/Data-Processor-0.1.6/t/006_regex_keys.t:ok ($error_collection->any_error_contains(
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:# Data::Processor::Validator - Validate Data Against a Schema
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        errors => $p{errors}  // Data::Processor::Error::Collection->new(),
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        transformer => Data::Processor::Transformer->new(),
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    $self->{errors} = Data::Processor::Error::Collection->new();
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    $self->_add_defaults();
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{data}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain (">>'$key'");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        my $schema_key = $self->_schema_twin_key($key) or next;
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->__value_is_valid( $key );
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->__validator_returns_undef($key, $schema_key);
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        my $e = $self->{transformer}->transform($key, $self);
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->error($e) if $e;
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        if ($self->{schema}->{$schema_key}->{no_descend_into}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain (
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        if (! %{$self->{schema}->{$schema_key}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain ("skipping '$key' because schema key is empty'");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        if (! $self->{schema}->{$schema_key}->{members}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain (
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain (">>descending into '$key'\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        if (ref $self->{data}->{$key} eq ref {} ){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            my $e = Data::Processor::Validator->new(
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                schema      => $self->{schema}->{$schema_key}->{members},
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                data        => $self->{data}->{$key},
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                parent_keys => [@{$self->{parent_keys}}, $key],
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                depth       => $self->{depth}+1,
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                verbose     => $self->{verbose},
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            ) ->validate();
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->{errors}->add_collection($e);
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        elsif ((ref $self->{data}->{$key} eq ref [])
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            && $self->{schema}->{$schema_key}->{array}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain(
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            push @{$self->{parent_keys}}, $key;
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->{depth}++;
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            for my $member (@{$self->{data}->{$key}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                my $e = Data::Processor::Validator->new(
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    schema      => $self->{schema}->{$schema_key}->{members},
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    parent_keys => [@{$self->{parent_keys}}, $key],
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    depth       => $self->{depth}+1,
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    verbose     => $self->{verbose},
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                ) ->validate();
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->{errors}->add_collection($e);
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            pop @{$self->{parent_keys}};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->{depth}--;
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        # We cannot descend into a non-existing branch in data
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain(">>checking data key '$key' which is a leaf..");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$schema_key}->{members}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("but schema requires members.\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->error("'$key' should have members");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("schema key is also a leaf. ok.\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    # look for missing non-optional keys in schema
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    $self->_check_mandatory_keys();
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    return $self->{errors};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    $self->{errors}->add(
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        path => $self->{parent_keys},
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    my $indent = ' ' x ($self->{depth}*$self->{indent});
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    print $string if $self->{verbose};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        next unless $self->{schema}->{$key}->{default};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->{data}->{$key} = $self->{schema}->{$key}->{default}
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            unless $self->{data}->{$key};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain(">>Checking if '$key' is mandatory: ");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        unless ($self->{schema}->{$key}->{optional}
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                   and $self->{schema}->{$key}->{optional}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain("true\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            next if $self->{data}->{$key};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            # regex-keys never directly occur.
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$key}->{regex}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain(">>regex enabled key found. ");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("Checking data keys.. ");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                for my $c_key (keys %{$self->{data}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("$c matching occurencies found\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            next if $self->{schema}->{$key}->{array};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $error_msg = $self->{schema}->{$key}->{error_msg}
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                if $self->{schema}->{$key}->{error_msg};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->error("mandatory key '$key' missing. Error msg: '$error_msg'");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain("false\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    if ($self->{schema}->{$key}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain(" ok\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        for my $match_key (keys %{$self->{schema}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            next unless exists $self->{schema}->{$match_key}
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                           and $self->{schema}->{$match_key}->{regex};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("'$key' matches $match_key\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain(">>$key not in schema, keys available: ");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain(join (", ", (keys %{$self->{schema}})));
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain("\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->error("key '$key' not found in schema\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:# 'validator' specified gets this called to call the callback :-)
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    return unless $self->{schema}->{$schema_key}->{validator};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    $self->explain("running validator for '$key': $self->{data}->{$key}\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    if (ref $self->{data}->{$key} eq ref []
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        && $self->{schema}->{$key}->{array}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        for my $elem (@{$self->{data}->{$key}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            my $return_value = $self->{schema}->{$key}->{validator}->($elem, $self->{data});
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("validator error: $return_value (element $counter)\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->error("Execution of validator for '$key' element $counter returns with error: $return_value");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("successful validation for key '$key' element $counter\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        my $return_value = $self->{schema}->{$key}->{validator}->($self->{data}->{$key}, $self->{data});
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain("validator error: $return_value\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->error("Execution of validator for '$key' returns with error: $return_value");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain("successful validation for key '$key'\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    if (exists  $self->{schema}->{$key}
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            and $self->{schema}->{$key}->{value}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain('>>'.ref($self->{schema}->{$key}->{value})."\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        if (ref($self->{schema}->{$key}->{value}) eq 'CODE'){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        elsif (ref($self->{schema}->{$key}->{value}) eq 'Regexp'){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            if (ref $self->{data}->{$key} eq ref []
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                && $self->{schema}->{$key}->{array}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                for my $elem (@{$self->{data}->{$key}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    $self->explain(">>match '$elem' against '$self->{schema}->{$key}->{value}'");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    if ($elem =~ m/^$self->{schema}->{$key}->{value}$/){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                        $self->explain(" ok.\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                        $self->explain(" no.\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                        $self->error("$elem does not match ^$self->{schema}->{$key}->{value}\$");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:               $self->explain(">>match '$self->{data}->{$key}' against '$self->{schema}->{$key}->{value}'");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                if ($self->{data}->{$key} =~ m/^$self->{schema}->{$key}->{value}$/){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    $self->explain(" ok.\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    $self->explain(" no.\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    $self->error("$self->{data}->{$key} does not match ^$self->{schema}->{$key}->{value}\$");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain("neither CODE nor Regexp\n");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->error("'$key' not CODE nor Regexp");
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm:Data::Processor::ValidatorFactory - create validators for use in schemas
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm: my $vf = Data::Processor::ValidatorFactory->new;
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->file('>','writing'),
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->rx(qr{[A-Z]+},'expected name made up from capital letters')
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->any(qw(UP DOWN))
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm: $vf->file('<','reading');
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm: $vf->file('>>','appending to');
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm: $vf->dir();
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm:        return undef if -d $value;
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm: $vf->rx(qr{[A-Z]+},'use uppercase letters')
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm: $vf->any(qw(ON OFF))
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:    if (exists $section->{schema}->{$key}
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:        and exists $section->{schema}->{$key}->{transformer}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:                $section->{schema}->{$key}->{transformer}
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:                ->($section->{data}->{$key},$section->{data});
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:            if (ref $err eq 'HASH' and $err->{msg}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:                $err = $err->{msg};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:            $section->{data}->{$key} = $return_value;
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Instance.pm:        $self->{$_} // die "$_ missing";
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Instance.pm:    $self->{path_array} = $self->{path};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Instance.pm:    $self->{path} = join '->', @{$self->{path}};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Instance.pm:    $self->{caller} = "$sub line $line";
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Instance.pm:    return $self->{path}. ": " . $self->{message};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:Data::Processor::Error::Collection - Collect errors for Data::Processor
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    my $errors = Data::Processor::Error::Collection->new();
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:- message
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:- path
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    my $error = Data::Processor::Error::Instance->new(%p);
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $error;
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $e;
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    my @e = $other->as_array();
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:        $self->add_error($_);
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:  $error->collection->any_error_contains(
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    for my $error (@{$self->{errors}}){
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:        return 1 if $error->{$p{field}} =~ /$p{string}/;
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    return @{$self->{errors}};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    return scalar @{$self->{errors}};
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:Data::Processor - Transform Perl Data Structures, Validate Data against a Schema, Produce Data from a Schema, or produce documentation directly from information in the Data
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm: my $processor = Data::Processor->new($schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:- indent: count of spaces to insert when printing in verbose mode. Default 4
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:- depth: level at which to start. Default is 0.
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:- verbose: Set to a true value to print messages during processing.
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:        errors      => Data::Processor::Error::Collection->new(),
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm: my @errors = $processor->validate($data, verbose=>0);
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:    $self->{validator}=Data::Processor::Validator->new(
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:        schema      => $self->{schema} // $p{schema},
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:        verbose     => $p{verbose} // $self->{verbose} // undef,
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:        errors      => $self->{errors},
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:        depth       => $self->{depth},
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:        indent      => $self->{indent},
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:        parent_keys => $self->{parent_keys},
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:    return $self->{validator}->validate();
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm: my ($data_transformed, @errors) = $processor->transform_data(data=>$data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm: my ($schema_transformed, @errors) = $processor->transform_schema(schema=>$schema);
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm: my ($data, @errors) = $processor->make_data(data=>$data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm: my ($pod, @errors) = $processor->make_pod(data=>$data);
./.build/OkDOcJKakw/Data-Processor-0.1.6/lib/Data/Processor.pm:Copyright 2015- Matthias Bloch
Übereinstimmungen in Binärdatei ./Data-Processor-0.2.0.tar.gz.
./.gitignore:/Data-Processor-*
Übereinstimmungen in Binärdatei ./Data-Processor-0.1.5.tar.gz.
./Data-Processor-0.1.4/META.json:   "meta-spec" : {
./Data-Processor-0.1.4/META.json:   "name" : "Data-Processor",
./Data-Processor-0.1.4/META.json:         "web" : "https://github.com/maettu/Data-Processor/issues"
./Data-Processor-0.1.4/META.json:      "homepage" : "https://github.com/maettu/Data-Processor",
./Data-Processor-0.1.4/META.json:         "url" : "https://github.com/maettu/Data-Processor.git",
./Data-Processor-0.1.4/META.json:         "web" : "https://github.com/maettu/Data-Processor"
./Data-Processor-0.1.4/Changes:Revision history for Data-Processor
./Data-Processor-0.1.4/Changes:0.1.4  2015-01-22 16:22:30 CET
./Data-Processor-0.1.4/Changes:    - array support as of t/013_array.t 
./Data-Processor-0.1.4/Changes:    - Transformer object
./Data-Processor-0.1.4/Changes:    - Error::Instance handles more
./Data-Processor-0.1.4/Changes:0.1.3  2015-01-20 09:43:14 CET
./Data-Processor-0.1.4/Changes:    - not-ready and interface change warning added
./Data-Processor-0.1.4/Changes:0.1.2  2015-01-19 11:15:29 CET
./Data-Processor-0.1.4/Changes:    - Makefile.PL instead of Build.PL
./Data-Processor-0.1.4/Changes:0.1.1  2015-01-18 21:48:47 CET
./Data-Processor-0.1.4/Changes:    - more test (mostly ported from old module)
./Data-Processor-0.1.4/Changes:    - ValidatorFactory
./Data-Processor-0.1.4/Changes:0.1.0  2015-01-18 16:50:50 CET
./Data-Processor-0.1.4/Changes:    - Error Collector added
./Data-Processor-0.1.4/Changes:    - Basic functionality: validation without frills
./Data-Processor-0.1.4/Changes:0.0.3  2015-01-15 21:37:19 CET
./Data-Processor-0.1.4/Changes:0.0.2  2015-01-15 21:31:16 CET
./Data-Processor-0.1.4/Changes:    - Code Layout
./Data-Processor-0.1.4/Changes:0.0.1  2015-01-15 19:09:03 CET
./Data-Processor-0.1.4/Changes:        - Initial release
./Data-Processor-0.1.4/META.yml:---
./Data-Processor-0.1.4/META.yml:  - 'Matthias Bloch <matthias.bloch@puffin.ch>'
./Data-Processor-0.1.4/META.yml:meta-spec:
./Data-Processor-0.1.4/META.yml:  url: http://module-build.sourceforge.net/META-spec-v1.4.html
./Data-Processor-0.1.4/META.yml:name: Data-Processor
./Data-Processor-0.1.4/META.yml:    - t
./Data-Processor-0.1.4/META.yml:    - xt
./Data-Processor-0.1.4/META.yml:    - inc
./Data-Processor-0.1.4/META.yml:    - share
./Data-Processor-0.1.4/META.yml:    - eg
./Data-Processor-0.1.4/META.yml:    - examples
./Data-Processor-0.1.4/META.yml:  bugtracker: https://github.com/maettu/Data-Processor/issues
./Data-Processor-0.1.4/META.yml:  homepage: https://github.com/maettu/Data-Processor
./Data-Processor-0.1.4/META.yml:  repository: https://github.com/maettu/Data-Processor.git
./Data-Processor-0.1.4/META.yml:  - 'Dominik Hassler <hadfl@cpan.org>'
./Data-Processor-0.1.4/META.yml:  - 'Tobias Oetiker <tobi@oetiker.ch>'
./Data-Processor-0.1.4/META.yml:  - 'maettu <matthias.bloch@puffin.ch>'
./Data-Processor-0.1.4/MANIFEST:t/release-pod-syntax.t
./Data-Processor-0.1.4/Build.PL:# This Build.PL for Data-Processor was generated by Dist::Zilla::Plugin::ModuleBuildTiny 0.008.
./Data-Processor-0.1.4/Makefile.PL:      license     => 'http://www.opensource.org/licenses/artistic-license-2.0',
./Data-Processor-0.1.4/Makefile.PL:      repository  => 'https://github.com/maettu/Data-Structure-Validation',
./Data-Processor-0.1.4/Makefile.PL:      bugtracker  => 'https://github.com/maettu/Data-Structure-Validation/issues'
./Data-Processor-0.1.4/LICENSE:This software is copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.1.4/LICENSE:--- The GNU General Public License, Version 1, February 1989 ---
./Data-Processor-0.1.4/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.1.4/LICENSE: 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
./Data-Processor-0.1.4/LICENSE:software--to make sure the software is free for all its users.  The
./Data-Processor-0.1.4/LICENSE:    a) accompany it with the complete corresponding machine-readable
./Data-Processor-0.1.4/LICENSE:    for the cost of distribution) a complete machine-readable copy of the
./Data-Processor-0.1.4/LICENSE:    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA  02110-1301 USA
./Data-Processor-0.1.4/LICENSE:c'; they could even be mouse-clicks or menu items--whatever suits your
./Data-Processor-0.1.4/LICENSE:--- The Artistic License 1.0 ---
./Data-Processor-0.1.4/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.1.4/LICENSE:the package the right to use and distribute the Package in a more-or-less
./Data-Processor-0.1.4/LICENSE:  - "Package" refers to the collection of files distributed by the Copyright
./Data-Processor-0.1.4/LICENSE:  - "Standard Version" refers to such a Package if it has not been modified,
./Data-Processor-0.1.4/LICENSE:  - "Copyright Holder" is whoever is named in the copyright or copyrights for
./Data-Processor-0.1.4/LICENSE:  - "You" is you, if you're thinking about copying or distributing this Package.
./Data-Processor-0.1.4/LICENSE:  - "Reasonable copying fee" is whatever you can justify on the basis of media
./Data-Processor-0.1.4/LICENSE:  - "Freely Available" means that no fee is charged for the item itself, though
./Data-Processor-0.1.4/LICENSE:  c) rename any non-standard executables so the names do not conflict with
./Data-Processor-0.1.4/LICENSE:     manual page for each non-standard executable that clearly documents how it
./Data-Processor-0.1.4/LICENSE:  b) accompany the distribution with the machine-readable source of the Package
./Data-Processor-0.1.4/LICENSE:  c) accompany any non-standard executables with their corresponding Standard
./Data-Processor-0.1.4/LICENSE:     Version executables, giving the non-standard executables non-standard
./Data-Processor-0.1.4/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(verbose => 1);
./Data-Processor-0.1.4/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}, 'section "GENERAL" exists');
./Data-Processor-0.1.4/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}->{logfile}, '"logfile" exists');
./Data-Processor-0.1.4/t/100_make_config_template.t:#~ ok ($config_template->{GENERAL}->{logfile} = 'absolute path to logfile (?-xism:/.*)', 'logifle has correct content');
./Data-Processor-0.1.4/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(entry_point => $schema->{GENERAL}->{members}->{silos});
./Data-Processor-0.1.4/t/100_make_config_template.t:#~ ok (exists $config_template->{'silo-.+'}, 'entry point "silos" found');
./Data-Processor-0.1.4/t/100_make_config_template.t:#~ ok ($config_template->{'silo-.+'}->{url} eq 'url of the silo server. Only https:// allowed(?^:https.*)',
./Data-Processor-0.1.4/t/007_no_value_check.t:my $p = Data::Processor->new(schema=>$schema);
./Data-Processor-0.1.4/t/007_no_value_check.t:my $error_collection = $p->validate(data=>$data, verbose=>0);
./Data-Processor-0.1.4/t/007_no_value_check.t:ok ($error_collection->count==0, 'no errors');
./Data-Processor-0.1.4/t/007_no_value_check.t:$error_collection = $p->validate(data=>$data, verbose=>0);
./Data-Processor-0.1.4/t/007_no_value_check.t:ok ($error_collection->count==0, 'still no errors');
./Data-Processor-0.1.4/t/010_transformer.t:                return ($1 * $timespecfactor->{($2 || 's')});
./Data-Processor-0.1.4/t/010_transformer.t:        transformer => $transformer->{timespec}(
./Data-Processor-0.1.4/t/010_transformer.t:my $validator = Data::Processor->new(schema=>$schema);
./Data-Processor-0.1.4/t/010_transformer.t:my $error_collection = $validator->validate(data=>$data, verbose=>0);
./Data-Processor-0.1.4/t/010_transformer.t:ok ($data->{history} == 3600, 'transformed "1h" into "3600"');
./Data-Processor-0.1.4/t/010_transformer.t:    history => 'regards, your error :-)',
./Data-Processor-0.1.4/t/010_transformer.t:$error_collection = $validator->validate(data=>$data);
./Data-Processor-0.1.4/t/010_transformer.t:ok ($data->{history} eq 'regards, your error :-)',
./Data-Processor-0.1.4/t/010_transformer.t:    'Could not transform "regards, your error :-)"');
./Data-Processor-0.1.4/t/010_transformer.t:ok ($error_collection->{errors}[0]->{message}
./Data-Processor-0.1.4/t/011_default_values.t:my $p = Data::Processor->new(schema=>$schema);
./Data-Processor-0.1.4/t/011_default_values.t:my $error_collection = $p->validate(data=>$data, verbose=>0);
./Data-Processor-0.1.4/t/011_default_values.t:ok ($data->{key_with_default_value}==42,
./Data-Processor-0.1.4/t/005_synopsis.t:                    # undef is "no-error" -> success.
./Data-Processor-0.1.4/t/005_synopsis.t:                        if $self->{value} == 42;
./Data-Processor-0.1.4/t/005_synopsis.t:my $p = Data::Processor->new(schema => $schema);
./Data-Processor-0.1.4/t/005_synopsis.t:my $error_collection = $p->validate(data => $data, verbose=>0);
./Data-Processor-0.1.4/t/005_synopsis.t:# no errors :-)
./Data-Processor-0.1.4/t/005_synopsis.t:ok ($error_collection->count==0, 'no errors');
./Data-Processor-0.1.4/t/013_array.t:my $p = Data::Processor->new(schema => $schema);
./Data-Processor-0.1.4/t/013_array.t:my $error_collection = $p->validate(data => $data, verbose=>0);
./Data-Processor-0.1.4/t/013_array.t:ok ($error_collection->count == 8, '8 errors detected');
./Data-Processor-0.1.4/t/013_array.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.4/t/008_error_stringify.t:my $validator = Data::Processor->new(schema=>$schema);
./Data-Processor-0.1.4/t/008_error_stringify.t:my $error_collection = $validator->validate(data=>$data, verbose=>0);
./Data-Processor-0.1.4/t/008_error_stringify.t:ok ($error_collection->count==1, '1 error');
./Data-Processor-0.1.4/t/008_error_stringify.t:my $msg = $error_collection->{errors}[0]->stringify();
./Data-Processor-0.1.4/t/012_factory.t:my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.1.4/t/012_factory.t:like ($vf->file('<','oops')->('/tmp/xkddf'),qr/oops/, 'error message generated');
./Data-Processor-0.1.4/t/012_factory.t:is ($vf->rx(qr{XX},'oops')->('xxXXx'),undef,'regular expression check');
./Data-Processor-0.1.4/t/012_factory.t:is ($vf->any(qw(OFF ON))->('OFF'),undef, 'is it one of the list');
./Data-Processor-0.1.4/t/012_factory.t:is ($vf->dir()->('/'),undef, 'directory exists');
./Data-Processor-0.1.4/t/002_validate.t:my $processor_without_schema = Data::Processor->new();
./Data-Processor-0.1.4/t/002_validate.t:eval{$processor_without_schema->validate()};
./Data-Processor-0.1.4/t/002_validate.t:eval{$processor_without_schema->validate(schema=>$schema)};
./Data-Processor-0.1.4/t/002_validate.t:my $processor = Data::Processor->new(schema => $schema);
./Data-Processor-0.1.4/t/002_validate.t:eval{$processor->validate()};
./Data-Processor-0.1.4/t/002_validate.t:my $error_collection = $processor->validate(data=>$data);
./Data-Processor-0.1.4/t/002_validate.t:my @errors = $error_collection->as_array();
./Data-Processor-0.1.4/t/002_validate.t:ok ($error_collection->count()==2, 'error count =2');
./Data-Processor-0.1.4/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.4/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.4/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.4/t/002_validate.t:        string => "silo-a",
./Data-Processor-0.1.4/t/002_validate.t:    "missing value from 'silo-a'"
./Data-Processor-0.1.4/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.4/t/002_validate.t:        logfile => '/tmp/n3k-poller.log',
./Data-Processor-0.1.4/t/002_validate.t:        cachedb => '/tmp/n3k-cache.db',
./Data-Processor-0.1.4/t/002_validate.t:            'silo-a' => {
./Data-Processor-0.1.4/t/002_validate.t:                url => 'https://silo-a/api',
./Data-Processor-0.1.4/t/002_validate.t:                key => 'my-secret-shared-key',
./Data-Processor-0.1.4/t/002_validate.t:$error_collection = $processor->validate(data=>$data);
./Data-Processor-0.1.4/t/002_validate.t:ok ($error_collection->count==0, 'no more errors with corrected config');
./Data-Processor-0.1.4/t/002_validate.t:use Data::Dumper; print Dumper $error_collection->as_array;
./Data-Processor-0.1.4/t/002_validate.t:$error_collection = $processor->validate(data=>$data);
./Data-Processor-0.1.4/t/002_validate.t:ok ($error_collection->count==2, '2 errors');
./Data-Processor-0.1.4/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.4/t/002_validate.t:            logfile => '/tmp/n3k-poller.log',
./Data-Processor-0.1.4/t/002_validate.t:            cachedb => '/tmp/n3k-cache.db',
./Data-Processor-0.1.4/t/002_validate.t:                'silo-a' => {
./Data-Processor-0.1.4/t/002_validate.t:                    url => 'https://silo-a/api',
./Data-Processor-0.1.4/t/002_validate.t:                    key => 'my-secret-shared-key',
./Data-Processor-0.1.4/t/002_validate.t:                    # "members" stands for all "non-internal" fields
./Data-Processor-0.1.4/t/002_validate.t:                        'silo-.+' => {
./Data-Processor-0.1.4/t/002_validate.t:                                    example     => 'https://silo-a/api',
./Data-Processor-0.1.4/t/001_basic.t:my $processor = Data::Processor->new();
./Data-Processor-0.1.4/t/006_regex_keys.t:my $p = Data::Processor->new(schema => $schema);
./Data-Processor-0.1.4/t/006_regex_keys.t:my $error_collection = $p->validate(data => $data, verbose=>0);
./Data-Processor-0.1.4/t/006_regex_keys.t:ok ($error_collection->count==3, '3 errors detected');
./Data-Processor-0.1.4/t/006_regex_keys.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:# Data::Processor::Validator - Validate Data Against a Schema
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        errors => $p{errors}  // Data::Processor::Error::Collection->new(),
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        transformer => Data::Processor::Transformer->new(),
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:    $self->{errors} = Data::Processor::Error::Collection->new();
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:    $self->_validate($self->{data}, $self->{schema}, 'root');
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:    return $self->{errors};
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:    $self->_add_defaults($data_section, $schema_section);
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        $self->explain (">>'$key'");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->__key_present_in_schema(
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        $self->__value_is_valid(
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        $self->__validator_returns_undef(
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        ) if exists $schema_section->{$key}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:             and exists $schema_section->{$key}->{validator};
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        my $e = $self->{transformer}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                ->transform($schema_section, $data_section, $key);
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        $self->error($e) if $e;
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        if (exists  $schema_section->{$key}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                and $schema_section->{$key}->{no_descend_into}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                and $schema_section->{$key}->{no_descend_into}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        elsif (exists $schema_section->{$key}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                and ! %{$schema_section->{$key}}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        elsif (exists $schema_section->{$key}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                and ! exists $schema_section->{$key}->{members}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->explain (">>descending into '$key'\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        if ((ref $data_section->{$key} eq ref {})
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->explain (">>'$key' is not a leaf and we descend into it\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            push @{$self->{parent_keys}}, $key;
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->{depth}++;
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->_validate(
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $data_section->{$key},
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $schema_section->{$key_schema_to_descend_into}->{members}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            pop @{$self->{parent_keys}};
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->{depth}--;
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        elsif ((ref $data_section->{$key} eq ref []) && $descend_into
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            && exists $schema_section->{$key_schema_to_descend_into}->{array}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            && $schema_section->{$key_schema_to_descend_into}->{array}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->explain(">>'$key' is an array reference so we check all elements\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            push @{$self->{parent_keys}}, $key;
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->{depth}++;
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            for my $member (@{$data_section->{$key}}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $self->_validate(
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                    $schema_section->{$key_schema_to_descend_into}->{members}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            pop @{$self->{parent_keys}};
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->{depth}--;
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        # We cannot descend into a non-existing branch in data
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->explain(">>checking data key '$key' which is a leaf..");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                 $schema_section->{$key_schema_to_descend_into}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                ref $schema_section->{$key_schema_to_descend_into} eq ref {}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                exists $schema_section->{$key_schema_to_descend_into}->{members}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $self->explain("but schema requires members.\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $self->error("'$key' should have members");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $self->explain("schema key is also a leaf. ok.\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:     # look for missing non-optional keys in schema
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:    $self->_check_mandatory_keys(
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:    $self->{errors}->add(
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        path => $self->{parent_keys},
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:    my $indent = ' ' x ($self->{depth}*$self->{indent});
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:    print $string if $self->{verbose};
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        next unless exists $schema_section->{$key}->{default};
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        $data_section->{$key} = $schema_section->{$key}->{default}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            unless $data_section->{$key};
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        $self->explain(">>Checking if '$key' is mandatory: ");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        unless (exists $schema_section->{$key}->{optional}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                   and $schema_section->{$key}->{optional}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->explain("true\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            next if exists $data_section->{$key};
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            # regex-keys never directly occur.
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            if (exists $schema_section->{$key}->{regex}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                   and $schema_section->{$key}->{regex}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $self->explain(">>regex enabled key found. ");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $self->explain("Checking data keys.. ");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $self->explain("$c matching occurencies found\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            next if exists $schema_section->{$key}->{array}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                && $schema_section->{$key}->{array};
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $error_msg = $schema_section->{$key}->{error_msg}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                if exists $schema_section->{$key}->{error_msg};
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->error("mandatory key '$key' missing. Error msg: '$error_msg'");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->explain("false\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:    if (exists $schema_section->{$key}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        $self->explain(" ok\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            next unless exists $schema_section->{$match_key}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                    and exists $schema_section->{$match_key}->{regex}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                           and $schema_section->{$match_key}->{regex};
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $self->explain("'$key' matches $match_key\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        $self->explain(">>$key not in schema, keys available: ");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        $self->explain(join (", ", (keys %{$schema_section})));
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        $self->explain("\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        $self->error("key '$key' not found in schema\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:# 'validator' specified gets this called to call the callback :-)
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:    $self->explain("running validator for '$key': $data_section->{$key}\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:    if (ref $data_section->{$key} eq ref []
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        && exists $schema_section->{$key}->{array} && $schema_section->{$key}->{array}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        for my $elem (@{$data_section->{$key}}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            my $return_value = $schema_section->{$key}->{validator}->($elem, $data_section);
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $self->explain("validator error: $return_value (element $counter)\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $self->error("Execution of validator for '$key' element $counter returns with error: $return_value");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                $self->explain("successful validation for key '$key' element $counter\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        my $return_value = $schema_section->{$key}->{validator}->($data_section->{$key}, $data_section);
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->explain("validator error: $return_value\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->error("Execution of validator for '$key' returns with error: $return_value");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->explain("successful validation for key '$key'\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:    if (exists  $schema_section->{$key}
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            and $schema_section->{$key}->{value}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        $self->explain('>>'.ref($schema_section->{$key}->{value})."\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        if (ref($schema_section->{$key}->{value}) eq 'CODE'){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:        elsif (ref($schema_section->{$key}->{value}) eq 'Regexp'){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            if (ref $data_section->{$key} eq ref []
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                && exists $schema_section->{$key}->{array} && $schema_section->{$key}->{array}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                for my $elem (@{$data_section->{$key}}){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                    $self->explain(">>match '$elem' against '$schema_section->{$key}->{value}'");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                    if ($elem =~ m/^$schema_section->{$key}->{value}$/){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                        $self->explain(" ok.\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                        $self->explain(" no.\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                        $self->error("$elem does not match ^$schema_section->{$key}->{value}\$");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:               $self->explain(">>match '$data_section->{$key}' against '$schema_section->{$key}->{value}'");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                if ($data_section->{$key} =~ m/^$schema_section->{$key}->{value}$/){
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                    $self->explain(" ok.\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                    $self->explain(" no.\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:                    $self->error("$data_section->{$key} does not match ^$schema_section->{$key}->{value}\$");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->explain("neither CODE nor Regexp\n");
./Data-Processor-0.1.4/lib/Data/Processor/Validator.pm:            $self->error("'$key' not CODE nor Regexp");
./Data-Processor-0.1.4/lib/Data/Processor/ValidatorFactory.pm:Data::Processor::ValidatorFactory - create validators for use in schemas
./Data-Processor-0.1.4/lib/Data/Processor/ValidatorFactory.pm: my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.1.4/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->file('>','writing'),
./Data-Processor-0.1.4/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->rx(qr{[A-Z]+},'expected name made up from capital letters')
./Data-Processor-0.1.4/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->any(qw(UP DOWN))
./Data-Processor-0.1.4/lib/Data/Processor/ValidatorFactory.pm: $vf->file('<','reading');
./Data-Processor-0.1.4/lib/Data/Processor/ValidatorFactory.pm: $vf->file('>>','appending to');
./Data-Processor-0.1.4/lib/Data/Processor/ValidatorFactory.pm: $vf->dir();
./Data-Processor-0.1.4/lib/Data/Processor/ValidatorFactory.pm:        return undef if -d $value;
./Data-Processor-0.1.4/lib/Data/Processor/ValidatorFactory.pm: $vf->rx(qr{[A-Z]+},'use uppercase letters')
./Data-Processor-0.1.4/lib/Data/Processor/ValidatorFactory.pm: $vf->any(qw(ON OFF))
./Data-Processor-0.1.4/lib/Data/Processor/Transformer.pm:    if (exists $schema_section->{$key}
./Data-Processor-0.1.4/lib/Data/Processor/Transformer.pm:        and exists $schema_section->{$key}->{transformer}){
./Data-Processor-0.1.4/lib/Data/Processor/Transformer.pm:                $schema_section->{$key}->{transformer}
./Data-Processor-0.1.4/lib/Data/Processor/Transformer.pm:                ->($data_section->{$key},$data_section);
./Data-Processor-0.1.4/lib/Data/Processor/Transformer.pm:            if (ref $err eq 'HASH' and $err->{msg}){
./Data-Processor-0.1.4/lib/Data/Processor/Transformer.pm:                $err = $err->{msg};
./Data-Processor-0.1.4/lib/Data/Processor/Transformer.pm:            $data_section->{$key} = $return_value;
./Data-Processor-0.1.4/lib/Data/Processor/Error/Instance.pm:        $self->{$_} // die "$_ missing";
./Data-Processor-0.1.4/lib/Data/Processor/Error/Instance.pm:    $self->{path_array} = $self->{path};
./Data-Processor-0.1.4/lib/Data/Processor/Error/Instance.pm:    $self->{path} = join '->', @{$self->{path}};
./Data-Processor-0.1.4/lib/Data/Processor/Error/Instance.pm:    $self->{caller} = "$sub line $line";
./Data-Processor-0.1.4/lib/Data/Processor/Error/Instance.pm:    return $self->{path}. ": " . $self->{message};
./Data-Processor-0.1.4/lib/Data/Processor/Error/Collection.pm:Data::Processor::Error::Collection - Collect errors for Data::Processor
./Data-Processor-0.1.4/lib/Data/Processor/Error/Collection.pm:    my $errors = Data::Processor::Error::Collection->new();
./Data-Processor-0.1.4/lib/Data/Processor/Error/Collection.pm:    my $error = Data::Processor::Error::Instance->new(%p);
./Data-Processor-0.1.4/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $error;
./Data-Processor-0.1.4/lib/Data/Processor/Error/Collection.pm:  $error->collection->any_error_contains(
./Data-Processor-0.1.4/lib/Data/Processor/Error/Collection.pm:    for my $error (@{$self->{errors}}){
./Data-Processor-0.1.4/lib/Data/Processor/Error/Collection.pm:        return 1 if $error->{$p{field}} =~ /$p{string}/;
./Data-Processor-0.1.4/lib/Data/Processor/Error/Collection.pm:    return @{$self->{errors}};
./Data-Processor-0.1.4/lib/Data/Processor/Error/Collection.pm:    return scalar @{$self->{errors}};
./Data-Processor-0.1.4/lib/Data/Processor.pm:Data::Processor - Transform Perl Data Structures, Validate Data against a Schema, Produce Data from a Schema, or produce documentation directly from information in the Data
./Data-Processor-0.1.4/lib/Data/Processor.pm: my $processor = Data::Processor->new();
./Data-Processor-0.1.4/lib/Data/Processor.pm:- schema: schema to validate against. Can also be specified later
./Data-Processor-0.1.4/lib/Data/Processor.pm:- indent: count of spaces to insert when printing in verbose mode. Default 4
./Data-Processor-0.1.4/lib/Data/Processor.pm:- depth: level at which to start. Default is 0.
./Data-Processor-0.1.4/lib/Data/Processor.pm:- verbose: Set to a true value to print messages during processing.
./Data-Processor-0.1.4/lib/Data/Processor.pm:        errors      => Data::Processor::Error::Collection->new(),
./Data-Processor-0.1.4/lib/Data/Processor.pm: my @errors = $processor->validate(schema=>$schema, data=>$data, verbose=>0);
./Data-Processor-0.1.4/lib/Data/Processor.pm:    $self->{validator}=Data::Processor::Validator->new(
./Data-Processor-0.1.4/lib/Data/Processor.pm:        schema      => $self->{schema} // $p{schema},
./Data-Processor-0.1.4/lib/Data/Processor.pm:        verbose     => $p{verbose} // $self->{verbose} // undef,
./Data-Processor-0.1.4/lib/Data/Processor.pm:        errors      => $self->{errors},
./Data-Processor-0.1.4/lib/Data/Processor.pm:        depth       => $self->{depth},
./Data-Processor-0.1.4/lib/Data/Processor.pm:        indent      => $self->{indent},
./Data-Processor-0.1.4/lib/Data/Processor.pm:        parent_keys => $self->{parent_keys},
./Data-Processor-0.1.4/lib/Data/Processor.pm:    return $self->{validator}->validate();
./Data-Processor-0.1.4/lib/Data/Processor.pm: my ($data_transformed, @errors) = $processor->transform_data(data=>$data);
./Data-Processor-0.1.4/lib/Data/Processor.pm: my ($schema_transformed, @errors) = $processor->transform_schema(schema=>$schema);
./Data-Processor-0.1.4/lib/Data/Processor.pm: my ($data, @errors) = $processor->make_data(data=>$data);
./Data-Processor-0.1.4/lib/Data/Processor.pm: my ($pod, @errors) = $processor->make_pod(data=>$data);
./Data-Processor-0.1.4/lib/Data/Processor.pm:Copyright 2015- Matthias Bloch
./Data-Processor-0.1.5/META.json:   "meta-spec" : {
./Data-Processor-0.1.5/META.json:   "name" : "Data-Processor",
./Data-Processor-0.1.5/META.json:         "web" : "https://github.com/maettu/Data-Processor/issues"
./Data-Processor-0.1.5/META.json:      "homepage" : "https://github.com/maettu/Data-Processor",
./Data-Processor-0.1.5/META.json:         "url" : "https://github.com/maettu/Data-Processor.git",
./Data-Processor-0.1.5/META.json:         "web" : "https://github.com/maettu/Data-Processor"
./Data-Processor-0.1.5/Changes:Revision history for Data-Processor
./Data-Processor-0.1.5/Changes:0.1.5  2015-01-22 16:50:24 CET
./Data-Processor-0.1.5/Changes:    - Interface change: use positional parameters for $schema, $data
./Data-Processor-0.1.5/Changes:0.1.4  2015-01-22 16:22:30 CET
./Data-Processor-0.1.5/Changes:    - array support as of t/013_array.t 
./Data-Processor-0.1.5/Changes:    - Transformer object
./Data-Processor-0.1.5/Changes:    - Error::Instance handles more
./Data-Processor-0.1.5/Changes:0.1.3  2015-01-20 09:43:14 CET
./Data-Processor-0.1.5/Changes:    - not-ready and interface change warning added
./Data-Processor-0.1.5/Changes:0.1.2  2015-01-19 11:15:29 CET
./Data-Processor-0.1.5/Changes:    - Makefile.PL instead of Build.PL
./Data-Processor-0.1.5/Changes:0.1.1  2015-01-18 21:48:47 CET
./Data-Processor-0.1.5/Changes:    - more test (mostly ported from old module)
./Data-Processor-0.1.5/Changes:    - ValidatorFactory
./Data-Processor-0.1.5/Changes:0.1.0  2015-01-18 16:50:50 CET
./Data-Processor-0.1.5/Changes:    - Error Collector added
./Data-Processor-0.1.5/Changes:    - Basic functionality: validation without frills
./Data-Processor-0.1.5/Changes:0.0.3  2015-01-15 21:37:19 CET
./Data-Processor-0.1.5/Changes:0.0.2  2015-01-15 21:31:16 CET
./Data-Processor-0.1.5/Changes:    - Code Layout
./Data-Processor-0.1.5/Changes:0.0.1  2015-01-15 19:09:03 CET
./Data-Processor-0.1.5/Changes:        - Initial release
./Data-Processor-0.1.5/META.yml:---
./Data-Processor-0.1.5/META.yml:  - 'Matthias Bloch <matthias.bloch@puffin.ch>'
./Data-Processor-0.1.5/META.yml:meta-spec:
./Data-Processor-0.1.5/META.yml:  url: http://module-build.sourceforge.net/META-spec-v1.4.html
./Data-Processor-0.1.5/META.yml:name: Data-Processor
./Data-Processor-0.1.5/META.yml:    - t
./Data-Processor-0.1.5/META.yml:    - xt
./Data-Processor-0.1.5/META.yml:    - inc
./Data-Processor-0.1.5/META.yml:    - share
./Data-Processor-0.1.5/META.yml:    - eg
./Data-Processor-0.1.5/META.yml:    - examples
./Data-Processor-0.1.5/META.yml:  bugtracker: https://github.com/maettu/Data-Processor/issues
./Data-Processor-0.1.5/META.yml:  homepage: https://github.com/maettu/Data-Processor
./Data-Processor-0.1.5/META.yml:  repository: https://github.com/maettu/Data-Processor.git
./Data-Processor-0.1.5/META.yml:  - 'Dominik Hassler <hadfl@cpan.org>'
./Data-Processor-0.1.5/META.yml:  - 'Tobias Oetiker <tobi@oetiker.ch>'
./Data-Processor-0.1.5/META.yml:  - 'maettu <matthias.bloch@puffin.ch>'
./Data-Processor-0.1.5/MANIFEST:t/release-pod-syntax.t
./Data-Processor-0.1.5/Build.PL:# This Build.PL for Data-Processor was generated by Dist::Zilla::Plugin::ModuleBuildTiny 0.008.
./Data-Processor-0.1.5/Makefile.PL:      license     => 'http://www.opensource.org/licenses/artistic-license-2.0',
./Data-Processor-0.1.5/Makefile.PL:      repository  => 'https://github.com/maettu/Data-Structure-Validation',
./Data-Processor-0.1.5/Makefile.PL:      bugtracker  => 'https://github.com/maettu/Data-Structure-Validation/issues'
./Data-Processor-0.1.5/LICENSE:This software is copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.1.5/LICENSE:--- The GNU General Public License, Version 1, February 1989 ---
./Data-Processor-0.1.5/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.1.5/LICENSE: 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
./Data-Processor-0.1.5/LICENSE:software--to make sure the software is free for all its users.  The
./Data-Processor-0.1.5/LICENSE:    a) accompany it with the complete corresponding machine-readable
./Data-Processor-0.1.5/LICENSE:    for the cost of distribution) a complete machine-readable copy of the
./Data-Processor-0.1.5/LICENSE:    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA  02110-1301 USA
./Data-Processor-0.1.5/LICENSE:c'; they could even be mouse-clicks or menu items--whatever suits your
./Data-Processor-0.1.5/LICENSE:--- The Artistic License 1.0 ---
./Data-Processor-0.1.5/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.1.5/LICENSE:the package the right to use and distribute the Package in a more-or-less
./Data-Processor-0.1.5/LICENSE:  - "Package" refers to the collection of files distributed by the Copyright
./Data-Processor-0.1.5/LICENSE:  - "Standard Version" refers to such a Package if it has not been modified,
./Data-Processor-0.1.5/LICENSE:  - "Copyright Holder" is whoever is named in the copyright or copyrights for
./Data-Processor-0.1.5/LICENSE:  - "You" is you, if you're thinking about copying or distributing this Package.
./Data-Processor-0.1.5/LICENSE:  - "Reasonable copying fee" is whatever you can justify on the basis of media
./Data-Processor-0.1.5/LICENSE:  - "Freely Available" means that no fee is charged for the item itself, though
./Data-Processor-0.1.5/LICENSE:  c) rename any non-standard executables so the names do not conflict with
./Data-Processor-0.1.5/LICENSE:     manual page for each non-standard executable that clearly documents how it
./Data-Processor-0.1.5/LICENSE:  b) accompany the distribution with the machine-readable source of the Package
./Data-Processor-0.1.5/LICENSE:  c) accompany any non-standard executables with their corresponding Standard
./Data-Processor-0.1.5/LICENSE:     Version executables, giving the non-standard executables non-standard
./Data-Processor-0.1.5/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(verbose => 1);
./Data-Processor-0.1.5/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}, 'section "GENERAL" exists');
./Data-Processor-0.1.5/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}->{logfile}, '"logfile" exists');
./Data-Processor-0.1.5/t/100_make_config_template.t:#~ ok ($config_template->{GENERAL}->{logfile} = 'absolute path to logfile (?-xism:/.*)', 'logifle has correct content');
./Data-Processor-0.1.5/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(entry_point => $schema->{GENERAL}->{members}->{silos});
./Data-Processor-0.1.5/t/100_make_config_template.t:#~ ok (exists $config_template->{'silo-.+'}, 'entry point "silos" found');
./Data-Processor-0.1.5/t/100_make_config_template.t:#~ ok ($config_template->{'silo-.+'}->{url} eq 'url of the silo server. Only https:// allowed(?^:https.*)',
./Data-Processor-0.1.5/t/007_no_value_check.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.5/t/007_no_value_check.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.5/t/007_no_value_check.t:ok ($error_collection->count==0, 'no errors');
./Data-Processor-0.1.5/t/007_no_value_check.t:$error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.5/t/007_no_value_check.t:ok ($error_collection->count==0, 'still no errors');
./Data-Processor-0.1.5/t/010_transformer.t:                return ($1 * $timespecfactor->{($2 || 's')});
./Data-Processor-0.1.5/t/010_transformer.t:        transformer => $transformer->{timespec}(
./Data-Processor-0.1.5/t/010_transformer.t:my $validator = Data::Processor->new($schema);
./Data-Processor-0.1.5/t/010_transformer.t:my $error_collection = $validator->validate($data, verbose=>0);
./Data-Processor-0.1.5/t/010_transformer.t:ok ($data->{history} == 3600, 'transformed "1h" into "3600"');
./Data-Processor-0.1.5/t/010_transformer.t:    history => 'regards, your error :-)',
./Data-Processor-0.1.5/t/010_transformer.t:$error_collection = $validator->validate($data);
./Data-Processor-0.1.5/t/010_transformer.t:ok ($data->{history} eq 'regards, your error :-)',
./Data-Processor-0.1.5/t/010_transformer.t:    'Could not transform "regards, your error :-)"');
./Data-Processor-0.1.5/t/010_transformer.t:ok ($error_collection->{errors}[0]->{message}
./Data-Processor-0.1.5/t/011_default_values.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.5/t/011_default_values.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.5/t/011_default_values.t:ok ($data->{key_with_default_value}==42,
./Data-Processor-0.1.5/t/005_synopsis.t:                    # undef is "no-error" -> success.
./Data-Processor-0.1.5/t/005_synopsis.t:                        if $self->{value} == 42;
./Data-Processor-0.1.5/t/005_synopsis.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.5/t/005_synopsis.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.5/t/005_synopsis.t:# no errors :-)
./Data-Processor-0.1.5/t/005_synopsis.t:ok ($error_collection->count==0, 'no errors');
./Data-Processor-0.1.5/t/013_array.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.5/t/013_array.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.5/t/013_array.t:ok ($error_collection->count == 8, '8 errors detected');
./Data-Processor-0.1.5/t/013_array.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.5/t/008_error_stringify.t:my $validator = Data::Processor->new($schema);
./Data-Processor-0.1.5/t/008_error_stringify.t:my $error_collection = $validator->validate($data, verbose=>0);
./Data-Processor-0.1.5/t/008_error_stringify.t:ok ($error_collection->count==1, '1 error');
./Data-Processor-0.1.5/t/008_error_stringify.t:my $msg = $error_collection->{errors}[0]->stringify();
./Data-Processor-0.1.5/t/012_factory.t:my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.1.5/t/012_factory.t:like ($vf->file('<','oops')->('/tmp/xkddf'),qr/oops/, 'error message generated');
./Data-Processor-0.1.5/t/012_factory.t:is ($vf->rx(qr{XX},'oops')->('xxXXx'),undef,'regular expression check');
./Data-Processor-0.1.5/t/012_factory.t:is ($vf->any(qw(OFF ON))->('OFF'),undef, 'is it one of the list');
./Data-Processor-0.1.5/t/012_factory.t:is ($vf->dir()->('/'),undef, 'directory exists');
./Data-Processor-0.1.5/t/002_validate.t:my $processor = Data::Processor->new($schema);
./Data-Processor-0.1.5/t/002_validate.t:eval{$processor->validate()};
./Data-Processor-0.1.5/t/002_validate.t:my $error_collection = $processor->validate($data);
./Data-Processor-0.1.5/t/002_validate.t:my @errors = $error_collection->as_array();
./Data-Processor-0.1.5/t/002_validate.t:ok ($error_collection->count()==2, 'error count =2');
./Data-Processor-0.1.5/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.5/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.5/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.5/t/002_validate.t:        string => "silo-a",
./Data-Processor-0.1.5/t/002_validate.t:    "missing value from 'silo-a'"
./Data-Processor-0.1.5/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.5/t/002_validate.t:        logfile => '/tmp/n3k-poller.log',
./Data-Processor-0.1.5/t/002_validate.t:        cachedb => '/tmp/n3k-cache.db',
./Data-Processor-0.1.5/t/002_validate.t:            'silo-a' => {
./Data-Processor-0.1.5/t/002_validate.t:                url => 'https://silo-a/api',
./Data-Processor-0.1.5/t/002_validate.t:                key => 'my-secret-shared-key',
./Data-Processor-0.1.5/t/002_validate.t:$error_collection = $processor->validate($data);
./Data-Processor-0.1.5/t/002_validate.t:ok ($error_collection->count==0, 'no more errors with corrected config');
./Data-Processor-0.1.5/t/002_validate.t:use Data::Dumper; print Dumper $error_collection->as_array;
./Data-Processor-0.1.5/t/002_validate.t:$error_collection = $processor->validate($data);
./Data-Processor-0.1.5/t/002_validate.t:ok ($error_collection->count==2, '2 errors');
./Data-Processor-0.1.5/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.5/t/002_validate.t:            logfile => '/tmp/n3k-poller.log',
./Data-Processor-0.1.5/t/002_validate.t:            cachedb => '/tmp/n3k-cache.db',
./Data-Processor-0.1.5/t/002_validate.t:                'silo-a' => {
./Data-Processor-0.1.5/t/002_validate.t:                    url => 'https://silo-a/api',
./Data-Processor-0.1.5/t/002_validate.t:                    key => 'my-secret-shared-key',
./Data-Processor-0.1.5/t/002_validate.t:                    # "members" stands for all "non-internal" fields
./Data-Processor-0.1.5/t/002_validate.t:                        'silo-.+' => {
./Data-Processor-0.1.5/t/002_validate.t:                                    example     => 'https://silo-a/api',
./Data-Processor-0.1.5/t/001_basic.t:my $processor = Data::Processor->new();
./Data-Processor-0.1.5/t/006_regex_keys.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.5/t/006_regex_keys.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.5/t/006_regex_keys.t:ok ($error_collection->count==3, '3 errors detected');
./Data-Processor-0.1.5/t/006_regex_keys.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:# Data::Processor::Validator - Validate Data Against a Schema
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        errors => $p{errors}  // Data::Processor::Error::Collection->new(),
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        transformer => Data::Processor::Transformer->new(),
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:    $self->{errors} = Data::Processor::Error::Collection->new();
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:    $self->_validate($self->{data}, $self->{schema}, 'root');
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:    return $self->{errors};
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:    $self->_add_defaults($data_section, $schema_section);
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        $self->explain (">>'$key'");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->__key_present_in_schema(
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        $self->__value_is_valid(
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        $self->__validator_returns_undef(
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        ) if exists $schema_section->{$key}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:             and exists $schema_section->{$key}->{validator};
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        my $e = $self->{transformer}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                ->transform($schema_section, $data_section, $key);
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        $self->error($e) if $e;
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        if (exists  $schema_section->{$key}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                and $schema_section->{$key}->{no_descend_into}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                and $schema_section->{$key}->{no_descend_into}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        elsif (exists $schema_section->{$key}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                and ! %{$schema_section->{$key}}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        elsif (exists $schema_section->{$key}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                and ! exists $schema_section->{$key}->{members}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->explain (">>descending into '$key'\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        if ((ref $data_section->{$key} eq ref {})
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->explain (">>'$key' is not a leaf and we descend into it\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            push @{$self->{parent_keys}}, $key;
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->{depth}++;
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->_validate(
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $data_section->{$key},
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $schema_section->{$key_schema_to_descend_into}->{members}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            pop @{$self->{parent_keys}};
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->{depth}--;
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        elsif ((ref $data_section->{$key} eq ref []) && $descend_into
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            && exists $schema_section->{$key_schema_to_descend_into}->{array}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            && $schema_section->{$key_schema_to_descend_into}->{array}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->explain(">>'$key' is an array reference so we check all elements\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            push @{$self->{parent_keys}}, $key;
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->{depth}++;
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            for my $member (@{$data_section->{$key}}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $self->_validate(
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                    $schema_section->{$key_schema_to_descend_into}->{members}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            pop @{$self->{parent_keys}};
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->{depth}--;
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        # We cannot descend into a non-existing branch in data
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->explain(">>checking data key '$key' which is a leaf..");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                 $schema_section->{$key_schema_to_descend_into}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                ref $schema_section->{$key_schema_to_descend_into} eq ref {}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                exists $schema_section->{$key_schema_to_descend_into}->{members}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $self->explain("but schema requires members.\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $self->error("'$key' should have members");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $self->explain("schema key is also a leaf. ok.\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:     # look for missing non-optional keys in schema
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:    $self->_check_mandatory_keys(
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:    $self->{errors}->add(
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        path => $self->{parent_keys},
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:    my $indent = ' ' x ($self->{depth}*$self->{indent});
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:    print $string if $self->{verbose};
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        next unless exists $schema_section->{$key}->{default};
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        $data_section->{$key} = $schema_section->{$key}->{default}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            unless $data_section->{$key};
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        $self->explain(">>Checking if '$key' is mandatory: ");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        unless (exists $schema_section->{$key}->{optional}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                   and $schema_section->{$key}->{optional}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->explain("true\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            next if exists $data_section->{$key};
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            # regex-keys never directly occur.
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            if (exists $schema_section->{$key}->{regex}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                   and $schema_section->{$key}->{regex}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $self->explain(">>regex enabled key found. ");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $self->explain("Checking data keys.. ");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $self->explain("$c matching occurencies found\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            next if exists $schema_section->{$key}->{array}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                && $schema_section->{$key}->{array};
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $error_msg = $schema_section->{$key}->{error_msg}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                if exists $schema_section->{$key}->{error_msg};
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->error("mandatory key '$key' missing. Error msg: '$error_msg'");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->explain("false\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:    if (exists $schema_section->{$key}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        $self->explain(" ok\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            next unless exists $schema_section->{$match_key}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                    and exists $schema_section->{$match_key}->{regex}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                           and $schema_section->{$match_key}->{regex};
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $self->explain("'$key' matches $match_key\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        $self->explain(">>$key not in schema, keys available: ");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        $self->explain(join (", ", (keys %{$schema_section})));
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        $self->explain("\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        $self->error("key '$key' not found in schema\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:# 'validator' specified gets this called to call the callback :-)
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:    $self->explain("running validator for '$key': $data_section->{$key}\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:    if (ref $data_section->{$key} eq ref []
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        && exists $schema_section->{$key}->{array} && $schema_section->{$key}->{array}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        for my $elem (@{$data_section->{$key}}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            my $return_value = $schema_section->{$key}->{validator}->($elem, $data_section);
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $self->explain("validator error: $return_value (element $counter)\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $self->error("Execution of validator for '$key' element $counter returns with error: $return_value");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                $self->explain("successful validation for key '$key' element $counter\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        my $return_value = $schema_section->{$key}->{validator}->($data_section->{$key}, $data_section);
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->explain("validator error: $return_value\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->error("Execution of validator for '$key' returns with error: $return_value");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->explain("successful validation for key '$key'\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:    if (exists  $schema_section->{$key}
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            and $schema_section->{$key}->{value}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        $self->explain('>>'.ref($schema_section->{$key}->{value})."\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        if (ref($schema_section->{$key}->{value}) eq 'CODE'){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:        elsif (ref($schema_section->{$key}->{value}) eq 'Regexp'){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            if (ref $data_section->{$key} eq ref []
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                && exists $schema_section->{$key}->{array} && $schema_section->{$key}->{array}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                for my $elem (@{$data_section->{$key}}){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                    $self->explain(">>match '$elem' against '$schema_section->{$key}->{value}'");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                    if ($elem =~ m/^$schema_section->{$key}->{value}$/){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                        $self->explain(" ok.\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                        $self->explain(" no.\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                        $self->error("$elem does not match ^$schema_section->{$key}->{value}\$");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:               $self->explain(">>match '$data_section->{$key}' against '$schema_section->{$key}->{value}'");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                if ($data_section->{$key} =~ m/^$schema_section->{$key}->{value}$/){
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                    $self->explain(" ok.\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                    $self->explain(" no.\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:                    $self->error("$data_section->{$key} does not match ^$schema_section->{$key}->{value}\$");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->explain("neither CODE nor Regexp\n");
./Data-Processor-0.1.5/lib/Data/Processor/Validator.pm:            $self->error("'$key' not CODE nor Regexp");
./Data-Processor-0.1.5/lib/Data/Processor/ValidatorFactory.pm:Data::Processor::ValidatorFactory - create validators for use in schemas
./Data-Processor-0.1.5/lib/Data/Processor/ValidatorFactory.pm: my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.1.5/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->file('>','writing'),
./Data-Processor-0.1.5/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->rx(qr{[A-Z]+},'expected name made up from capital letters')
./Data-Processor-0.1.5/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->any(qw(UP DOWN))
./Data-Processor-0.1.5/lib/Data/Processor/ValidatorFactory.pm: $vf->file('<','reading');
./Data-Processor-0.1.5/lib/Data/Processor/ValidatorFactory.pm: $vf->file('>>','appending to');
./Data-Processor-0.1.5/lib/Data/Processor/ValidatorFactory.pm: $vf->dir();
./Data-Processor-0.1.5/lib/Data/Processor/ValidatorFactory.pm:        return undef if -d $value;
./Data-Processor-0.1.5/lib/Data/Processor/ValidatorFactory.pm: $vf->rx(qr{[A-Z]+},'use uppercase letters')
./Data-Processor-0.1.5/lib/Data/Processor/ValidatorFactory.pm: $vf->any(qw(ON OFF))
./Data-Processor-0.1.5/lib/Data/Processor/Transformer.pm:    if (exists $schema_section->{$key}
./Data-Processor-0.1.5/lib/Data/Processor/Transformer.pm:        and exists $schema_section->{$key}->{transformer}){
./Data-Processor-0.1.5/lib/Data/Processor/Transformer.pm:                $schema_section->{$key}->{transformer}
./Data-Processor-0.1.5/lib/Data/Processor/Transformer.pm:                ->($data_section->{$key},$data_section);
./Data-Processor-0.1.5/lib/Data/Processor/Transformer.pm:            if (ref $err eq 'HASH' and $err->{msg}){
./Data-Processor-0.1.5/lib/Data/Processor/Transformer.pm:                $err = $err->{msg};
./Data-Processor-0.1.5/lib/Data/Processor/Transformer.pm:            $data_section->{$key} = $return_value;
./Data-Processor-0.1.5/lib/Data/Processor/Error/Instance.pm:        $self->{$_} // die "$_ missing";
./Data-Processor-0.1.5/lib/Data/Processor/Error/Instance.pm:    $self->{path_array} = $self->{path};
./Data-Processor-0.1.5/lib/Data/Processor/Error/Instance.pm:    $self->{path} = join '->', @{$self->{path}};
./Data-Processor-0.1.5/lib/Data/Processor/Error/Instance.pm:    $self->{caller} = "$sub line $line";
./Data-Processor-0.1.5/lib/Data/Processor/Error/Instance.pm:    return $self->{path}. ": " . $self->{message};
./Data-Processor-0.1.5/lib/Data/Processor/Error/Collection.pm:Data::Processor::Error::Collection - Collect errors for Data::Processor
./Data-Processor-0.1.5/lib/Data/Processor/Error/Collection.pm:    my $errors = Data::Processor::Error::Collection->new();
./Data-Processor-0.1.5/lib/Data/Processor/Error/Collection.pm:    my $error = Data::Processor::Error::Instance->new(%p);
./Data-Processor-0.1.5/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $error;
./Data-Processor-0.1.5/lib/Data/Processor/Error/Collection.pm:  $error->collection->any_error_contains(
./Data-Processor-0.1.5/lib/Data/Processor/Error/Collection.pm:    for my $error (@{$self->{errors}}){
./Data-Processor-0.1.5/lib/Data/Processor/Error/Collection.pm:        return 1 if $error->{$p{field}} =~ /$p{string}/;
./Data-Processor-0.1.5/lib/Data/Processor/Error/Collection.pm:    return @{$self->{errors}};
./Data-Processor-0.1.5/lib/Data/Processor/Error/Collection.pm:    return scalar @{$self->{errors}};
./Data-Processor-0.1.5/lib/Data/Processor.pm:Data::Processor - Transform Perl Data Structures, Validate Data against a Schema, Produce Data from a Schema, or produce documentation directly from information in the Data
./Data-Processor-0.1.5/lib/Data/Processor.pm: my $processor = Data::Processor->new($schema);
./Data-Processor-0.1.5/lib/Data/Processor.pm:- indent: count of spaces to insert when printing in verbose mode. Default 4
./Data-Processor-0.1.5/lib/Data/Processor.pm:- depth: level at which to start. Default is 0.
./Data-Processor-0.1.5/lib/Data/Processor.pm:- verbose: Set to a true value to print messages during processing.
./Data-Processor-0.1.5/lib/Data/Processor.pm:        errors      => Data::Processor::Error::Collection->new(),
./Data-Processor-0.1.5/lib/Data/Processor.pm: my @errors = $processor->validate($data, verbose=>0);
./Data-Processor-0.1.5/lib/Data/Processor.pm:    $self->{validator}=Data::Processor::Validator->new(
./Data-Processor-0.1.5/lib/Data/Processor.pm:        schema      => $self->{schema} // $p{schema},
./Data-Processor-0.1.5/lib/Data/Processor.pm:        verbose     => $p{verbose} // $self->{verbose} // undef,
./Data-Processor-0.1.5/lib/Data/Processor.pm:        errors      => $self->{errors},
./Data-Processor-0.1.5/lib/Data/Processor.pm:        depth       => $self->{depth},
./Data-Processor-0.1.5/lib/Data/Processor.pm:        indent      => $self->{indent},
./Data-Processor-0.1.5/lib/Data/Processor.pm:        parent_keys => $self->{parent_keys},
./Data-Processor-0.1.5/lib/Data/Processor.pm:    return $self->{validator}->validate();
./Data-Processor-0.1.5/lib/Data/Processor.pm: my ($data_transformed, @errors) = $processor->transform_data(data=>$data);
./Data-Processor-0.1.5/lib/Data/Processor.pm: my ($schema_transformed, @errors) = $processor->transform_schema(schema=>$schema);
./Data-Processor-0.1.5/lib/Data/Processor.pm: my ($data, @errors) = $processor->make_data(data=>$data);
./Data-Processor-0.1.5/lib/Data/Processor.pm: my ($pod, @errors) = $processor->make_pod(data=>$data);
./Data-Processor-0.1.5/lib/Data/Processor.pm:Copyright 2015- Matthias Bloch
./Data-Processor-0.3.0/META.json:   "meta-spec" : {
./Data-Processor-0.3.0/META.json:   "name" : "Data-Processor",
./Data-Processor-0.3.0/META.json:         "web" : "https://github.com/maettu/Data-Processor/issues"
./Data-Processor-0.3.0/META.json:      "homepage" : "https://github.com/maettu/Data-Processor",
./Data-Processor-0.3.0/META.json:         "url" : "https://github.com/maettu/Data-Processor.git",
./Data-Processor-0.3.0/META.json:         "web" : "https://github.com/maettu/Data-Processor"
./Data-Processor-0.3.0/Changes:Revision history for Data-Processor
./Data-Processor-0.3.0/Changes:0.3.0  2015-01-24 23:01:34 CET
./Data-Processor-0.3.0/Changes:    - data template generator
./Data-Processor-0.3.0/Changes:0.2.0  2015-01-24 22:12:26 CET
./Data-Processor-0.3.0/Changes:    - Pod writer
./Data-Processor-0.3.0/Changes:    - schema validator
./Data-Processor-0.3.0/Changes:0.1.7  2015-01-23 20:31:53 CET
./Data-Processor-0.3.0/Changes:    - Transformer, basic (not very useful yet)
./Data-Processor-0.3.0/Changes:0.1.6  2015-01-23 16:50:55 CET
./Data-Processor-0.3.0/Changes:    - no more "require"
./Data-Processor-0.3.0/Changes:    - code cleanup
./Data-Processor-0.3.0/Changes:0.1.5  2015-01-22 16:50:24 CET
./Data-Processor-0.3.0/Changes:    - Interface change: use positional parameters for $schema, $data
./Data-Processor-0.3.0/Changes:0.1.4  2015-01-22 16:22:30 CET
./Data-Processor-0.3.0/Changes:    - array support as of t/013_array.t 
./Data-Processor-0.3.0/Changes:    - Transformer object
./Data-Processor-0.3.0/Changes:    - Error::Instance handles more
./Data-Processor-0.3.0/Changes:0.1.3  2015-01-20 09:43:14 CET
./Data-Processor-0.3.0/Changes:    - not-ready and interface change warning added
./Data-Processor-0.3.0/Changes:0.1.2  2015-01-19 11:15:29 CET
./Data-Processor-0.3.0/Changes:    - Makefile.PL instead of Build.PL
./Data-Processor-0.3.0/Changes:0.1.1  2015-01-18 21:48:47 CET
./Data-Processor-0.3.0/Changes:    - more test (mostly ported from old module)
./Data-Processor-0.3.0/Changes:    - ValidatorFactory
./Data-Processor-0.3.0/Changes:0.1.0  2015-01-18 16:50:50 CET
./Data-Processor-0.3.0/Changes:    - Error Collector added
./Data-Processor-0.3.0/Changes:    - Basic functionality: validation without frills
./Data-Processor-0.3.0/Changes:0.0.3  2015-01-15 21:37:19 CET
./Data-Processor-0.3.0/Changes:0.0.2  2015-01-15 21:31:16 CET
./Data-Processor-0.3.0/Changes:    - Code Layout
./Data-Processor-0.3.0/Changes:0.0.1  2015-01-15 19:09:03 CET
./Data-Processor-0.3.0/Changes:        - Initial release
./Data-Processor-0.3.0/META.yml:---
./Data-Processor-0.3.0/META.yml:  - 'Matthias Bloch <matthias.bloch@puffin.ch>'
./Data-Processor-0.3.0/META.yml:meta-spec:
./Data-Processor-0.3.0/META.yml:  url: http://module-build.sourceforge.net/META-spec-v1.4.html
./Data-Processor-0.3.0/META.yml:name: Data-Processor
./Data-Processor-0.3.0/META.yml:    - t
./Data-Processor-0.3.0/META.yml:    - xt
./Data-Processor-0.3.0/META.yml:    - inc
./Data-Processor-0.3.0/META.yml:    - share
./Data-Processor-0.3.0/META.yml:    - eg
./Data-Processor-0.3.0/META.yml:    - examples
./Data-Processor-0.3.0/META.yml:  bugtracker: https://github.com/maettu/Data-Processor/issues
./Data-Processor-0.3.0/META.yml:  homepage: https://github.com/maettu/Data-Processor
./Data-Processor-0.3.0/META.yml:  repository: https://github.com/maettu/Data-Processor.git
./Data-Processor-0.3.0/META.yml:  - 'Dominik Hassler <hadfl@cpan.org>'
./Data-Processor-0.3.0/META.yml:  - 'Tobias Oetiker <tobi@oetiker.ch>'
./Data-Processor-0.3.0/META.yml:  - 'maettu <matthias.bloch@puffin.ch>'
./Data-Processor-0.3.0/MANIFEST:t/release-pod-syntax.t
./Data-Processor-0.3.0/Build.PL:# This Build.PL for Data-Processor was generated by Dist::Zilla::Plugin::ModuleBuildTiny 0.008.
./Data-Processor-0.3.0/Makefile.PL:      license     => 'http://www.opensource.org/licenses/artistic-license-2.0',
./Data-Processor-0.3.0/Makefile.PL:      repository  => 'https://github.com/maettu/Data-Structure-Validation',
./Data-Processor-0.3.0/Makefile.PL:      bugtracker  => 'https://github.com/maettu/Data-Structure-Validation/issues'
./Data-Processor-0.3.0/LICENSE:This software is copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.3.0/LICENSE:--- The GNU General Public License, Version 1, February 1989 ---
./Data-Processor-0.3.0/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.3.0/LICENSE: 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
./Data-Processor-0.3.0/LICENSE:software--to make sure the software is free for all its users.  The
./Data-Processor-0.3.0/LICENSE:    a) accompany it with the complete corresponding machine-readable
./Data-Processor-0.3.0/LICENSE:    for the cost of distribution) a complete machine-readable copy of the
./Data-Processor-0.3.0/LICENSE:    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA  02110-1301 USA
./Data-Processor-0.3.0/LICENSE:c'; they could even be mouse-clicks or menu items--whatever suits your
./Data-Processor-0.3.0/LICENSE:--- The Artistic License 1.0 ---
./Data-Processor-0.3.0/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.3.0/LICENSE:the package the right to use and distribute the Package in a more-or-less
./Data-Processor-0.3.0/LICENSE:  - "Package" refers to the collection of files distributed by the Copyright
./Data-Processor-0.3.0/LICENSE:  - "Standard Version" refers to such a Package if it has not been modified,
./Data-Processor-0.3.0/LICENSE:  - "Copyright Holder" is whoever is named in the copyright or copyrights for
./Data-Processor-0.3.0/LICENSE:  - "You" is you, if you're thinking about copying or distributing this Package.
./Data-Processor-0.3.0/LICENSE:  - "Reasonable copying fee" is whatever you can justify on the basis of media
./Data-Processor-0.3.0/LICENSE:  - "Freely Available" means that no fee is charged for the item itself, though
./Data-Processor-0.3.0/LICENSE:  c) rename any non-standard executables so the names do not conflict with
./Data-Processor-0.3.0/LICENSE:     manual page for each non-standard executable that clearly documents how it
./Data-Processor-0.3.0/LICENSE:  b) accompany the distribution with the machine-readable source of the Package
./Data-Processor-0.3.0/LICENSE:  c) accompany any non-standard executables with their corresponding Standard
./Data-Processor-0.3.0/LICENSE:     Version executables, giving the non-standard executables non-standard
./Data-Processor-0.3.0/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(verbose => 1);
./Data-Processor-0.3.0/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}, 'section "GENERAL" exists');
./Data-Processor-0.3.0/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}->{logfile}, '"logfile" exists');
./Data-Processor-0.3.0/t/100_make_config_template.t:#~ ok ($config_template->{GENERAL}->{logfile} = 'absolute path to logfile (?-xism:/.*)', 'logifle has correct content');
./Data-Processor-0.3.0/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(entry_point => $schema->{GENERAL}->{members}->{silos});
./Data-Processor-0.3.0/t/100_make_config_template.t:#~ ok (exists $config_template->{'silo-.+'}, 'entry point "silos" found');
./Data-Processor-0.3.0/t/100_make_config_template.t:#~ ok ($config_template->{'silo-.+'}->{url} eq 'url of the silo server. Only https:// allowed(?^:https.*)',
./Data-Processor-0.3.0/t/007_no_value_check.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.3.0/t/007_no_value_check.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.3.0/t/007_no_value_check.t:ok ($error_collection->count==0, 'no errors');
./Data-Processor-0.3.0/t/007_no_value_check.t:$error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.3.0/t/007_no_value_check.t:ok ($error_collection->count==0, 'still no errors');
./Data-Processor-0.3.0/t/010_transformer.t:                return ($1 * $timespecfactor->{($2 || 's')});
./Data-Processor-0.3.0/t/010_transformer.t:        transformer => $transformer->{timespec}(
./Data-Processor-0.3.0/t/010_transformer.t:my $validator = Data::Processor->new($schema);
./Data-Processor-0.3.0/t/010_transformer.t:my $error_collection = $validator->validate($data, verbose=>0);
./Data-Processor-0.3.0/t/010_transformer.t:ok ($data->{history} == 3600, 'transformed "1h" into "3600"');
./Data-Processor-0.3.0/t/010_transformer.t:    history => 'regards, your error :-)',
./Data-Processor-0.3.0/t/010_transformer.t:$error_collection = $validator->validate($data);
./Data-Processor-0.3.0/t/010_transformer.t:ok ($data->{history} eq 'regards, your error :-)',
./Data-Processor-0.3.0/t/010_transformer.t:    'Could not transform "regards, your error :-)"');
./Data-Processor-0.3.0/t/010_transformer.t:ok ($error_collection->{errors}[0]->{message}
./Data-Processor-0.3.0/t/011_default_values.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.3.0/t/011_default_values.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.3.0/t/011_default_values.t:ok ($data->{key_with_default_value}==42,
./Data-Processor-0.3.0/t/016_schemaschema.t:eval { Data::Processor->new($schema);};
./Data-Processor-0.3.0/t/005_synopsis.t:                    # undef is "no-error" -> success.
./Data-Processor-0.3.0/t/005_synopsis.t:                        if $self->{value} == 42;
./Data-Processor-0.3.0/t/005_synopsis.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.3.0/t/005_synopsis.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.3.0/t/005_synopsis.t:# no errors :-)
./Data-Processor-0.3.0/t/005_synopsis.t:ok ($error_collection->count==0, 'no errors');
./Data-Processor-0.3.0/t/013_array.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.3.0/t/013_array.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.3.0/t/013_array.t:ok ($error_collection->count == 9, '9 errors detected');
./Data-Processor-0.3.0/t/013_array.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.3.0/t/013_array.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.3.0/t/015_rx_validator.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.3.0/t/015_rx_validator.t:like ( [$p->validate($data)->as_array]->[0]->{message}, qr'BAD', 'got an error as expected');
./Data-Processor-0.3.0/t/015_rx_validator.t:like ( [$p->validate($data)->as_array]->[1]->{message}, qr'BAD', 'got an error as expected');
./Data-Processor-0.3.0/t/200_pod_writer.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.3.0/t/200_pod_writer.t:my $pod = $p->pod_write();
./Data-Processor-0.3.0/t/008_error_stringify.t:my $validator = Data::Processor->new($schema);
./Data-Processor-0.3.0/t/008_error_stringify.t:my $error_collection = $validator->validate($data, verbose=>0);
./Data-Processor-0.3.0/t/008_error_stringify.t:ok ($error_collection->count==1, '1 error');
./Data-Processor-0.3.0/t/008_error_stringify.t:my $msg = $error_collection->{errors}[0]->stringify();
./Data-Processor-0.3.0/t/300_make_config_template.t:                # "members" stands for all "non-internal" fields
./Data-Processor-0.3.0/t/300_make_config_template.t:                    'silo-.+' => {
./Data-Processor-0.3.0/t/300_make_config_template.t:                                example     => 'https://silo-a/api',
./Data-Processor-0.3.0/t/300_make_config_template.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.3.0/t/300_make_config_template.t:my $data_template = $p->make_data();
./Data-Processor-0.3.0/t/300_make_config_template.t:ok (exists $data_template->{GENERAL}, 'section "GENERAL" exists');
./Data-Processor-0.3.0/t/300_make_config_template.t:ok (exists $data_template->{GENERAL}->{logfile}, '"logfile" exists');
./Data-Processor-0.3.0/t/300_make_config_template.t:ok ($data_template->{GENERAL}->{logfile} = 'absolute path to logfile (?-xism:/.*)', 'logifle has correct content');
./Data-Processor-0.3.0/t/300_make_config_template.t:my $data_template = $p->make_data($schema->{GENERAL}->{members}->{silos});
./Data-Processor-0.3.0/t/300_make_config_template.t:ok (exists $data_template->{'silo-.+'}, 'entry point "silos" found');
./Data-Processor-0.3.0/t/300_make_config_template.t:ok ($data_template->{'silo-.+'}->{url} eq 'url of the silo server. Only https:// allowed(?^:https.*)',
./Data-Processor-0.3.0/t/012_factory.t:my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.3.0/t/012_factory.t:like ($vf->file('<','oops')->('/tmp/xkddf'),qr/oops/, 'error message generated');
./Data-Processor-0.3.0/t/012_factory.t:is ($vf->rx(qr{XX},'oops')->('xxXXx'),undef,'regular expression check');
./Data-Processor-0.3.0/t/012_factory.t:is ($vf->any(qw(OFF ON))->('OFF'),undef, 'is it one of the list');
./Data-Processor-0.3.0/t/012_factory.t:is ($vf->dir()->('/'),undef, 'directory exists');
./Data-Processor-0.3.0/t/002_validate.t:my $processor = Data::Processor->new($schema);
./Data-Processor-0.3.0/t/002_validate.t:eval{$processor->validate()};
./Data-Processor-0.3.0/t/002_validate.t:my $error_collection = $processor->validate($data);
./Data-Processor-0.3.0/t/002_validate.t:my @errors = $error_collection->as_array();
./Data-Processor-0.3.0/t/002_validate.t:ok ($error_collection->count()==2, 'error count =2');
./Data-Processor-0.3.0/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.3.0/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.3.0/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.3.0/t/002_validate.t:        string => "silo-a",
./Data-Processor-0.3.0/t/002_validate.t:    "missing value from 'silo-a'"
./Data-Processor-0.3.0/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.3.0/t/002_validate.t:        logfile => '/tmp/n3k-poller.log',
./Data-Processor-0.3.0/t/002_validate.t:        cachedb => '/tmp/n3k-cache.db',
./Data-Processor-0.3.0/t/002_validate.t:            'silo-a' => {
./Data-Processor-0.3.0/t/002_validate.t:                url => 'https://silo-a/api',
./Data-Processor-0.3.0/t/002_validate.t:                key => 'my-secret-shared-key',
./Data-Processor-0.3.0/t/002_validate.t:$error_collection = $processor->validate($data);
./Data-Processor-0.3.0/t/002_validate.t:ok ($error_collection->count==0, 'no more errors with corrected config');
./Data-Processor-0.3.0/t/002_validate.t:$error_collection = $processor->validate($data);
./Data-Processor-0.3.0/t/002_validate.t:ok ($error_collection->count==2, '2 errors');
./Data-Processor-0.3.0/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.3.0/t/002_validate.t:            logfile => '/tmp/n3k-poller.log',
./Data-Processor-0.3.0/t/002_validate.t:            cachedb => '/tmp/n3k-cache.db',
./Data-Processor-0.3.0/t/002_validate.t:                'silo-a' => {
./Data-Processor-0.3.0/t/002_validate.t:                    url => 'https://silo-a/api',
./Data-Processor-0.3.0/t/002_validate.t:                    key => 'my-secret-shared-key',
./Data-Processor-0.3.0/t/002_validate.t:                    # "members" stands for all "non-internal" fields
./Data-Processor-0.3.0/t/002_validate.t:                        'silo-.+' => {
./Data-Processor-0.3.0/t/002_validate.t:                                    example     => 'https://silo-a/api',
./Data-Processor-0.3.0/t/001_basic.t:my $processor = Data::Processor->new();
./Data-Processor-0.3.0/t/006_regex_keys.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.3.0/t/006_regex_keys.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.3.0/t/006_regex_keys.t:ok ($error_collection->count==3, '3 errors detected');
./Data-Processor-0.3.0/t/006_regex_keys.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.3.0/t/014_transformer_direct.t:my $v = Data::Processor::Validator->new($schema, data=>$data);
./Data-Processor-0.3.0/t/014_transformer_direct.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.3.0/t/014_transformer_direct.t:my $error_collection = $p->transform_data('transform_here', $v);
./Data-Processor-0.3.0/t/014_transformer_direct.t:ok ($data->{transform_here}==42, 'transformed into 42');
./Data-Processor-0.3.0/lib/Data/Processor/PodWriter.pm:            if $schema->{$key}->{optional};
./Data-Processor-0.3.0/lib/Data/Processor/PodWriter.pm:        $pod_string .= ": $schema->{$key}->{description}"
./Data-Processor-0.3.0/lib/Data/Processor/PodWriter.pm:            if $schema->{$key}->{description};
./Data-Processor-0.3.0/lib/Data/Processor/PodWriter.pm:        $pod_string .= "\n\nDefault value: $schema->{$key}->{default}"
./Data-Processor-0.3.0/lib/Data/Processor/PodWriter.pm:            if $schema->{$key}->{default};
./Data-Processor-0.3.0/lib/Data/Processor/PodWriter.pm:        if ($schema->{$key}->{members}){
./Data-Processor-0.3.0/lib/Data/Processor/PodWriter.pm:            $pod_string .= pod_write($schema->{$key}->{members}, '');
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:# Data::Processor::Validator - Validate Data Against a Schema
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        errors => $p{errors}  // Data::Processor::Error::Collection->new(),
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        transformer => Data::Processor::Transformer->new(),
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    $self->{data} = shift;
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    croak ('cannot validate without "data"') unless $self->{data};
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    $self->{errors} = Data::Processor::Error::Collection->new();
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    $self->_add_defaults();
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{data}}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->explain (">>'$key'");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        my $schema_key = $self->_schema_twin_key($key) or next;
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->__value_is_valid( $key );
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->__validator_returns_undef($key, $schema_key);
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        my $e = $self->{transformer}->transform($key, $self);
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->error($e) if $e;
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        if ($self->{schema}->{$schema_key}->{no_descend_into}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        if (! %{$self->{schema}->{$schema_key}}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->explain (">>skipping '$key' because schema key is empty\n'");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        if (! $self->{schema}->{$schema_key}->{members}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->explain (">>descending into '$key'\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        if (ref $self->{data}->{$key} eq ref {} ){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->explain
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            my $e = Data::Processor::Validator->new(
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                $self->{schema}->{$schema_key}->{members},
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                parent_keys => [@{$self->{parent_keys}}, $key],
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                depth       => $self->{depth}+1,
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                verbose     => $self->{verbose},
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            ) ->validate($self->{data}->{$key});
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->{errors}->add_collection($e);
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        elsif ((ref $self->{data}->{$key} eq ref [])
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            && $self->{schema}->{$schema_key}->{array}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->explain(
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            push @{$self->{parent_keys}}, $key;
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->{depth}++;
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            for my $member (@{$self->{data}->{$key}}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                my $e = Data::Processor::Validator->new(
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                    $self->{schema}->{$schema_key}->{members},
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                    parent_keys => [@{$self->{parent_keys}}, $key],
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                    depth       => $self->{depth}+1,
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                    verbose     => $self->{verbose},
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                ) ->validate($member);
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                $self->{errors}->add_collection($e);
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            pop @{$self->{parent_keys}};
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->{depth}--;
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        # We cannot descend into a non-existing branch in data
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->explain(">>checking data key '$key' which is a leaf..");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$schema_key}->{members}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                $self->explain("but schema requires members.\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                $self->error("'$key' should have members");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                $self->explain("schema key is also a leaf. ok.\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    # look for missing non-optional keys in schema
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    $self->_check_mandatory_keys();
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    return $self->{errors};
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    $self->{errors}->add(
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        path => $self->{parent_keys},
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    my $indent = ' ' x ($self->{depth}*$self->{indent});
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    print $string if $self->{verbose};
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        next unless $self->{schema}->{$key}->{default};
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->{data}->{$key} = $self->{schema}->{$key}->{default}
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            unless $self->{data}->{$key};
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->explain(">>Checking if '$key' is mandatory: ");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        unless ($self->{schema}->{$key}->{optional}
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                   and $self->{schema}->{$key}->{optional}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->explain("true\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            next if $self->{data}->{$key};
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            # regex-keys never directly occur.
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$key}->{regex}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                $self->explain(">>regex enabled key found. ");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                $self->explain("Checking data keys.. ");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                for my $c_key (keys %{$self->{data}}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                $self->explain("$c matching occurencies found\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $error_msg = $self->{schema}->{$key}->{error_msg}
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                if $self->{schema}->{$key}->{error_msg};
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->error("mandatory key '$key' missing. Error msg: '$error_msg'");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->explain("false\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    if ($self->{schema}->{$key}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->explain(" ok\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        for my $match_key (keys %{$self->{schema}}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            next unless exists $self->{schema}->{$match_key}
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                           and $self->{schema}->{$match_key}->{regex};
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                $self->explain("'$key' matches $match_key\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->explain(">>$key not in schema, keys available: ");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->explain(join (", ", (keys %{$self->{schema}})));
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->explain("\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->error("key '$key' not found in schema\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:# 'validator' specified gets this called to call the callback :-)
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    return unless $self->{schema}->{$schema_key}->{validator};
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    $self->explain("running validator for '$key': $self->{data}->{$key}\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    if (ref $self->{data}->{$key} eq ref []
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        && $self->{schema}->{$schema_key}->{array}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        for my $elem (@{$self->{data}->{$key}}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            my $return_value = $self->{schema}->{$schema_key}->{validator}->($elem, $self->{data});
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                $self->explain("validator error: $return_value (element $counter)\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                $self->error("Execution of validator for '$key' element $counter returns with error: $return_value");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                $self->explain("successful validation for key '$key' element $counter\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        my $return_value = $self->{schema}->{$schema_key}->{validator}->($self->{data}->{$key}, $self->{data});
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->explain("validator error: $return_value\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->error("Execution of validator for '$key' returns with error: $return_value");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->explain("successful validation for key '$key'\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:    if (exists  $self->{schema}->{$key}
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            and $self->{schema}->{$key}->{value}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        $self->explain('>>'.ref($self->{schema}->{$key}->{value})."\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        if (ref($self->{schema}->{$key}->{value}) eq 'CODE'){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:        elsif (ref($self->{schema}->{$key}->{value}) eq 'Regexp'){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            if (ref $self->{data}->{$key} eq ref []
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                && $self->{schema}->{$key}->{array}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                for my $elem (@{$self->{data}->{$key}}){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                    $self->explain(">>match '$elem' against '$self->{schema}->{$key}->{value}'");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                    if ($elem =~ m/^$self->{schema}->{$key}->{value}$/){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                        $self->explain(" ok.\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                        $self->explain(" no.\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                        $self->error("$elem does not match ^$self->{schema}->{$key}->{value}\$");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:               $self->explain(">>match '$self->{data}->{$key}' against '$self->{schema}->{$key}->{value}'");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                if ($self->{data}->{$key} =~ m/^$self->{schema}->{$key}->{value}$/){
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                    $self->explain(" ok.\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                    $self->explain(" no.\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:                    $self->error("$self->{data}->{$key} does not match ^$self->{schema}->{$key}->{value}\$");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->explain("neither CODE nor Regexp\n");
./Data-Processor-0.3.0/lib/Data/Processor/Validator.pm:            $self->error("'$key' not CODE nor Regexp");
./Data-Processor-0.3.0/lib/Data/Processor/Generator.pm:        if (ref $schema_section->{$key} eq ref {} ){
./Data-Processor-0.3.0/lib/Data/Processor/Generator.pm:                    $schema_section->{$key},
./Data-Processor-0.3.0/lib/Data/Processor/Generator.pm:                if (exists $schema_section->{$key}->{description}){
./Data-Processor-0.3.0/lib/Data/Processor/Generator.pm:                    $data->{$key} = $schema_section->{$key}->{description}
./Data-Processor-0.3.0/lib/Data/Processor/Generator.pm:                if (exists $schema_section->{$key}->{value}){
./Data-Processor-0.3.0/lib/Data/Processor/Generator.pm:                    $data->{$key} .= $schema_section->{$key}->{value};
./Data-Processor-0.3.0/lib/Data/Processor/Generator.pm:                # Inversely, if there is a value, it is an end-point.
./Data-Processor-0.3.0/lib/Data/Processor/Generator.pm:                if (! exists  $schema_section->{$key}->{value}){
./Data-Processor-0.3.0/lib/Data/Processor/Generator.pm:                    $data->{$key} = make_data_template(
./Data-Processor-0.3.0/lib/Data/Processor/Generator.pm:                        $schema_section->{$key},
./Data-Processor-0.3.0/lib/Data/Processor/ValidatorFactory.pm:Data::Processor::ValidatorFactory - create validators for use in schemas
./Data-Processor-0.3.0/lib/Data/Processor/ValidatorFactory.pm: my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.3.0/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->file('>','writing'),
./Data-Processor-0.3.0/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->rx(qr{[A-Z]+},'expected name made up from capital letters')
./Data-Processor-0.3.0/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->any(qw(UP DOWN))
./Data-Processor-0.3.0/lib/Data/Processor/ValidatorFactory.pm: $vf->file('<','reading');
./Data-Processor-0.3.0/lib/Data/Processor/ValidatorFactory.pm: $vf->file('>>','appending to');
./Data-Processor-0.3.0/lib/Data/Processor/ValidatorFactory.pm: $vf->dir();
./Data-Processor-0.3.0/lib/Data/Processor/ValidatorFactory.pm:        return undef if -d $value;
./Data-Processor-0.3.0/lib/Data/Processor/ValidatorFactory.pm: $vf->rx(qr{[A-Z]+},'use uppercase letters')
./Data-Processor-0.3.0/lib/Data/Processor/ValidatorFactory.pm: $vf->any(qw(ON OFF))
./Data-Processor-0.3.0/lib/Data/Processor/Transformer.pm:    if (exists $section->{schema}->{$key}
./Data-Processor-0.3.0/lib/Data/Processor/Transformer.pm:        and exists $section->{schema}->{$key}->{transformer}){
./Data-Processor-0.3.0/lib/Data/Processor/Transformer.pm:                $section->{schema}->{$key}->{transformer}
./Data-Processor-0.3.0/lib/Data/Processor/Transformer.pm:                ->($section->{data}->{$key},$section->{data});
./Data-Processor-0.3.0/lib/Data/Processor/Transformer.pm:            if (ref $err eq 'HASH' and $err->{msg}){
./Data-Processor-0.3.0/lib/Data/Processor/Transformer.pm:                $err = $err->{msg};
./Data-Processor-0.3.0/lib/Data/Processor/Transformer.pm:            $section->{data}->{$key} = $return_value;
./Data-Processor-0.3.0/lib/Data/Processor/Error/Instance.pm:        $self->{$_} // die "$_ missing";
./Data-Processor-0.3.0/lib/Data/Processor/Error/Instance.pm:    $self->{path_array} = $self->{path};
./Data-Processor-0.3.0/lib/Data/Processor/Error/Instance.pm:    $self->{path} = join '->', @{$self->{path}};
./Data-Processor-0.3.0/lib/Data/Processor/Error/Instance.pm:    $self->{caller} = "$sub line $line";
./Data-Processor-0.3.0/lib/Data/Processor/Error/Instance.pm:    return $self->{path}. ": " . $self->{message};
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:Data::Processor::Error::Collection - Collect errors for Data::Processor
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:    my $errors = Data::Processor::Error::Collection->new();
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:- message
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:- path
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:    my $error = Data::Processor::Error::Instance->new(%p);
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $error;
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $e;
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:    my @e = $other->as_array();
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:        $self->add_error($_);
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:  $error->collection->any_error_contains(
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:    for my $error (@{$self->{errors}}){
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:        return 1 if $error->{$p{field}} =~ /$p{string}/;
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:    return @{$self->{errors}};
./Data-Processor-0.3.0/lib/Data/Processor/Error/Collection.pm:    return scalar @{$self->{errors}};
./Data-Processor-0.3.0/lib/Data/Processor.pm:Data::Processor - Transform Perl Data Structures, Validate Data against a Schema, Produce Data from a Schema, or produce documentation directly from information in the Schema.
./Data-Processor-0.3.0/lib/Data/Processor.pm:                    # undef is "no-error" -> success.
./Data-Processor-0.3.0/lib/Data/Processor.pm:                        if $self->{value} == 42;
./Data-Processor-0.3.0/lib/Data/Processor.pm:  my $p = Data::Processor->new($schema);
./Data-Processor-0.3.0/lib/Data/Processor.pm:  my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.3.0/lib/Data/Processor.pm:  # no errors :-)
./Data-Processor-0.3.0/lib/Data/Processor.pm: my $processor = Data::Processor->new($schema);
./Data-Processor-0.3.0/lib/Data/Processor.pm:- indent: count of spaces to insert when printing in verbose mode. Default 4
./Data-Processor-0.3.0/lib/Data/Processor.pm:- depth: level at which to start. Default is 0.
./Data-Processor-0.3.0/lib/Data/Processor.pm:- verbose: Set to a true value to print messages during processing.
./Data-Processor-0.3.0/lib/Data/Processor.pm:        errors      => Data::Processor::Error::Collection->new(),
./Data-Processor-0.3.0/lib/Data/Processor.pm:    my $e = $self->validate_schema;
./Data-Processor-0.3.0/lib/Data/Processor.pm:    if ($e->count > 0){
./Data-Processor-0.3.0/lib/Data/Processor.pm:        croak "There is a problem with your schema:".join "\n", $e->as_array;
./Data-Processor-0.3.0/lib/Data/Processor.pm: my $error_collection = $processor->validate($data, verbose=>0);
./Data-Processor-0.3.0/lib/Data/Processor.pm:    $self->{validator}=Data::Processor::Validator->new(
./Data-Processor-0.3.0/lib/Data/Processor.pm:        $self->{schema} // $p{schema},
./Data-Processor-0.3.0/lib/Data/Processor.pm:        verbose     => $p{verbose} // $self->{verbose} // undef,
./Data-Processor-0.3.0/lib/Data/Processor.pm:        errors      => $self->{errors},
./Data-Processor-0.3.0/lib/Data/Processor.pm:        depth       => $self->{depth},
./Data-Processor-0.3.0/lib/Data/Processor.pm:        indent      => $self->{indent},
./Data-Processor-0.3.0/lib/Data/Processor.pm:        parent_keys => $self->{parent_keys},
./Data-Processor-0.3.0/lib/Data/Processor.pm:    return $self->{validator}->validate($data);
./Data-Processor-0.3.0/lib/Data/Processor.pm: my $error_collection = $processor->validate_schema();
./Data-Processor-0.3.0/lib/Data/Processor.pm:    my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.3.0/lib/Data/Processor.pm:    my $bool = $vf->rx(qr(^[01]$),'Expected 0 or 1');
./Data-Processor-0.3.0/lib/Data/Processor.pm:                    validator => $vf->rx(qr(.+),'expected a description string'),
./Data-Processor-0.3.0/lib/Data/Processor.pm:                    validator => $vf->rx(qr(.+),'expected an example string'),
./Data-Processor-0.3.0/lib/Data/Processor.pm:                    validator => $vf->rx(qr(.+),'expected an error message string'),
./Data-Processor-0.3.0/lib/Data/Processor.pm:                        my $subVal=Data::Processor::Validator->new($schemaSchema,%$self);
./Data-Processor-0.3.0/lib/Data/Processor.pm:                        my $e = $subVal->validate($value);
./Data-Processor-0.3.0/lib/Data/Processor.pm:                        return ( $e->count > 0 ? join("\n", $e->as_array) : undef);
./Data-Processor-0.3.0/lib/Data/Processor.pm:    return Data::Processor::Validator->new($schemaSchema,%$self)->validate($self->{schema});
./Data-Processor-0.3.0/lib/Data/Processor.pm:Transforms the data in-place.
./Data-Processor-0.3.0/lib/Data/Processor.pm: my $validator = Data::Processor::Validator->new($schema, data => $data)
./Data-Processor-0.3.0/lib/Data/Processor.pm: my $error_string = $processor->transform($key, $validator);
./Data-Processor-0.3.0/lib/Data/Processor.pm:    return Data::Processor::Transformer->new()->transform($key, $val);
./Data-Processor-0.3.0/lib/Data/Processor.pm: my $data = $processor->make_data(data=>$data);
./Data-Processor-0.3.0/lib/Data/Processor.pm:    my $entry_point = shift // $self->{schema};
./Data-Processor-0.3.0/lib/Data/Processor.pm: my $pod_string = $processor->make_pod();
./Data-Processor-0.3.0/lib/Data/Processor.pm:        $self->{schema},
./Data-Processor-0.3.0/lib/Data/Processor.pm:Copyright 2015- Matthias Bloch
./todo:    - Readme.md with (overwritten by milla release)
./todo:        [![Build Status](https://travis-ci.org/maettu/Data-Processor.svg?branch=master)]
./todo:        (https://travis-ci.org/maettu/Data-Processor)
./Build.PL:# This Build.PL for Data-Processor was generated by Dist::Zilla::Plugin::ModuleBuildTiny 0.008.
./Makefile.PL:      license     => 'http://www.opensource.org/licenses/artistic-license-2.0',
./Makefile.PL:      repository  => 'https://github.com/maettu/Data-Structure-Validation',
./Makefile.PL:      bugtracker  => 'https://github.com/maettu/Data-Structure-Validation/issues'
./LICENSE:This software is copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./LICENSE:--- The GNU General Public License, Version 1, February 1989 ---
./LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./LICENSE: 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
./LICENSE:software--to make sure the software is free for all its users.  The
./LICENSE:    a) accompany it with the complete corresponding machine-readable
./LICENSE:    for the cost of distribution) a complete machine-readable copy of the
./LICENSE:    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA  02110-1301 USA
./LICENSE:c'; they could even be mouse-clicks or menu items--whatever suits your
./LICENSE:--- The Artistic License 1.0 ---
./LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./LICENSE:the package the right to use and distribute the Package in a more-or-less
./LICENSE:  - "Package" refers to the collection of files distributed by the Copyright
./LICENSE:  - "Standard Version" refers to such a Package if it has not been modified,
./LICENSE:  - "Copyright Holder" is whoever is named in the copyright or copyrights for
./LICENSE:  - "You" is you, if you're thinking about copying or distributing this Package.
./LICENSE:  - "Reasonable copying fee" is whatever you can justify on the basis of media
./LICENSE:  - "Freely Available" means that no fee is charged for the item itself, though
./LICENSE:  c) rename any non-standard executables so the names do not conflict with
./LICENSE:     manual page for each non-standard executable that clearly documents how it
./LICENSE:  b) accompany the distribution with the machine-readable source of the Package
./LICENSE:  c) accompany any non-standard executables with their corresponding Standard
./LICENSE:     Version executables, giving the non-standard executables non-standard
./.git/logs/HEAD:4315ed8db1d6d89aad60c9fec83218eb2b246fb7 56f439beced5ff674874194d6efaeab8291c72f6 Matthias Bloch <matthias.bloch@puffin.ch> 1421700681 +0100	commit: Readme mit travis-button
./.git/logs/HEAD:fc210ecc23d9d743258f5c986a158eae2abaa308 0e90d0f294641b70403f60010b66003156acb0ed Matthias Bloch <matthias.bloch@puffin.ch> 1421743387 +0100	commit: 0.1.3: "not-ready" warning
./.git/logs/HEAD:6421037eea5e81a430024afde4432a08cb206271 ea25d153ec307e9aba0aef6fb1e9daa91213b54b Matthias Bloch <matthias.bloch@puffin.ch> 1421754436 +0100	pull: Fast-forward
./.git/logs/HEAD:9e0b75afa773f9d8c03a5a5c0a01f1d62b6e868c 6f9a1b3cb59f18d6125c066b8676e0e8f94d6dad Matthias Bloch <matthias.bloch@puffin.ch> 1421820203 +0100	pull: Fast-forward
./.git/logs/HEAD:0e79dafc2bf93820bb4534cb8bd3a48c3ef6ef95 9668e0c20d1a2c89a84281c5b48671ae538211a9 Matthias Bloch <matthias.bloch@puffin.ch> 1421966081 +0100	commit: "next" fallthrough instead of if-elsif
./.git/logs/HEAD:1d8dc0c23cc7c7324531cdc3002c261b587e5fdc bc70db5630d4ab28b41e22d0704baab87576ab2c Matthias Bloch <matthias.bloch@puffin.ch> 1422032086 +0100	commit: remove "next if ..->{array} from _check_mandatory_keys
./.git/logs/HEAD:32dffeb42be453eb41ef2b5fc47837b8fa07cefe a8e471a27b20ba6e0f430b588d140df8966bfa39 Matthias Bloch <matthias.bloch@puffin.ch> 1422041508 +0100	commit: 0.1.7 - basic transformer, not too interesting
./.git/logs/HEAD:5084af234729791056c871401f9061407029cb05 a0f7ecfe0f709159bf24a746076017e571788bfd Matthias Bloch <matthias.bloch@puffin.ch> 1422106894 +0100	pull: Fast-forward
./.git/logs/HEAD:a0f7ecfe0f709159bf24a746076017e571788bfd c865cba46b44d0f984ca5160227f0b10c41a5843 Matthias Bloch <matthias.bloch@puffin.ch> 1422110413 +0100	pull: Fast-forward
./.git/logs/HEAD:c865cba46b44d0f984ca5160227f0b10c41a5843 f9bb5723e4ba6d2037dbf4f6ee4abcc1b90321f6 Matthias Bloch <matthias.bloch@puffin.ch> 1422119259 +0100	commit: interface change make_pod -> pod_write
./.git/logs/HEAD:3c6049e848b90cdf84be691ea1ac2ec8bd0571a3 05b29dd997d18b5a887edd2457fb0482503ddbac Matthias Bloch <matthias.bloch@puffin.ch> 1422120430 +0100	pull: Fast-forward
./.git/logs/refs/remotes/origin/master:6421037eea5e81a430024afde4432a08cb206271 ea25d153ec307e9aba0aef6fb1e9daa91213b54b Matthias Bloch <matthias.bloch@puffin.ch> 1421754436 +0100	pull: fast-forward
./.git/logs/refs/remotes/origin/master:9e0b75afa773f9d8c03a5a5c0a01f1d62b6e868c 6f9a1b3cb59f18d6125c066b8676e0e8f94d6dad Matthias Bloch <matthias.bloch@puffin.ch> 1421820203 +0100	pull: fast-forward
./.git/logs/refs/remotes/origin/master:5084af234729791056c871401f9061407029cb05 a0f7ecfe0f709159bf24a746076017e571788bfd Matthias Bloch <matthias.bloch@puffin.ch> 1422106894 +0100	pull: fast-forward
./.git/logs/refs/remotes/origin/master:a0f7ecfe0f709159bf24a746076017e571788bfd c865cba46b44d0f984ca5160227f0b10c41a5843 Matthias Bloch <matthias.bloch@puffin.ch> 1422110413 +0100	pull: fast-forward
./.git/logs/refs/remotes/origin/master:f9bb5723e4ba6d2037dbf4f6ee4abcc1b90321f6 1caff985945bea1d25dcd212316bf5457017cd14 Matthias Bloch <matthias.bloch@puffin.ch> 1422119651 +0100	pull: fast-forward
./.git/logs/refs/remotes/origin/master:3c6049e848b90cdf84be691ea1ac2ec8bd0571a3 05b29dd997d18b5a887edd2457fb0482503ddbac Matthias Bloch <matthias.bloch@puffin.ch> 1422120430 +0100	pull: fast-forward
./.git/logs/refs/heads/master:4315ed8db1d6d89aad60c9fec83218eb2b246fb7 56f439beced5ff674874194d6efaeab8291c72f6 Matthias Bloch <matthias.bloch@puffin.ch> 1421700681 +0100	commit: Readme mit travis-button
./.git/logs/refs/heads/master:fc210ecc23d9d743258f5c986a158eae2abaa308 0e90d0f294641b70403f60010b66003156acb0ed Matthias Bloch <matthias.bloch@puffin.ch> 1421743387 +0100	commit: 0.1.3: "not-ready" warning
./.git/logs/refs/heads/master:6421037eea5e81a430024afde4432a08cb206271 ea25d153ec307e9aba0aef6fb1e9daa91213b54b Matthias Bloch <matthias.bloch@puffin.ch> 1421754436 +0100	pull: Fast-forward
./.git/logs/refs/heads/master:9e0b75afa773f9d8c03a5a5c0a01f1d62b6e868c 6f9a1b3cb59f18d6125c066b8676e0e8f94d6dad Matthias Bloch <matthias.bloch@puffin.ch> 1421820203 +0100	pull: Fast-forward
./.git/logs/refs/heads/master:0e79dafc2bf93820bb4534cb8bd3a48c3ef6ef95 9668e0c20d1a2c89a84281c5b48671ae538211a9 Matthias Bloch <matthias.bloch@puffin.ch> 1421966081 +0100	commit: "next" fallthrough instead of if-elsif
./.git/logs/refs/heads/master:1d8dc0c23cc7c7324531cdc3002c261b587e5fdc bc70db5630d4ab28b41e22d0704baab87576ab2c Matthias Bloch <matthias.bloch@puffin.ch> 1422032086 +0100	commit: remove "next if ..->{array} from _check_mandatory_keys
./.git/logs/refs/heads/master:32dffeb42be453eb41ef2b5fc47837b8fa07cefe a8e471a27b20ba6e0f430b588d140df8966bfa39 Matthias Bloch <matthias.bloch@puffin.ch> 1422041508 +0100	commit: 0.1.7 - basic transformer, not too interesting
./.git/logs/refs/heads/master:5084af234729791056c871401f9061407029cb05 a0f7ecfe0f709159bf24a746076017e571788bfd Matthias Bloch <matthias.bloch@puffin.ch> 1422106894 +0100	pull: Fast-forward
./.git/logs/refs/heads/master:a0f7ecfe0f709159bf24a746076017e571788bfd c865cba46b44d0f984ca5160227f0b10c41a5843 Matthias Bloch <matthias.bloch@puffin.ch> 1422110413 +0100	pull: Fast-forward
./.git/logs/refs/heads/master:c865cba46b44d0f984ca5160227f0b10c41a5843 f9bb5723e4ba6d2037dbf4f6ee4abcc1b90321f6 Matthias Bloch <matthias.bloch@puffin.ch> 1422119259 +0100	commit: interface change make_pod -> pod_write
./.git/logs/refs/heads/master:3c6049e848b90cdf84be691ea1ac2ec8bd0571a3 05b29dd997d18b5a887edd2457fb0482503ddbac Matthias Bloch <matthias.bloch@puffin.ch> 1422120430 +0100	pull: Fast-forward
./.git/hooks/applypatch-msg.sample:# applypatch from an e-mail message.
./.git/hooks/applypatch-msg.sample:# The hook should exit with non-zero status after issuing an
./.git/hooks/applypatch-msg.sample:# To enable this hook, rename this file to "applypatch-msg".
./.git/hooks/applypatch-msg.sample:. git-sh-setup
./.git/hooks/applypatch-msg.sample:test -x "$GIT_DIR/hooks/commit-msg" &&
./.git/hooks/applypatch-msg.sample:	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
./.git/hooks/update.sample:# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
./.git/hooks/update.sample:# ------
./.git/hooks/update.sample:# --- Command line
./.git/hooks/update.sample:# --- Safety check
./.git/hooks/update.sample:if [ -z "$GIT_DIR" ]; then
./.git/hooks/update.sample:if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
./.git/hooks/update.sample:# --- Config
./.git/hooks/update.sample:allowunannotated=$(git config --bool hooks.allowunannotated)
./.git/hooks/update.sample:allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
./.git/hooks/update.sample:denycreatebranch=$(git config --bool hooks.denycreatebranch)
./.git/hooks/update.sample:allowdeletetag=$(git config --bool hooks.allowdeletetag)
./.git/hooks/update.sample:allowmodifytag=$(git config --bool hooks.allowmodifytag)
./.git/hooks/update.sample:projectdesc=$(sed -e '1q' "$GIT_DIR/description")
./.git/hooks/update.sample:# --- Check types
./.git/hooks/update.sample:	newrev_type=$(git cat-file -t $newrev)
./.git/hooks/update.sample:		# un-annotated tag
./.git/hooks/update.sample:			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
./.git/hooks/update.sample:			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
./.git/hooks/update.sample:		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
./.git/hooks/update.sample:		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
./.git/hooks/update.sample:# --- Finished
./.git/hooks/commit-msg.sample:# that has the commit message.  The hook should exit with non-zero
./.git/hooks/commit-msg.sample:# To enable this hook, rename this file to "commit-msg".
./.git/hooks/commit-msg.sample:# Uncomment the below to add a Signed-off-by line to the message.
./.git/hooks/commit-msg.sample:# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
./.git/hooks/commit-msg.sample:# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
./.git/hooks/commit-msg.sample:# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
./.git/hooks/commit-msg.sample:# This example catches duplicate Signed-off-by lines.
./.git/hooks/commit-msg.sample:test "" = "$(grep '^Signed-off-by: ' "$1" |
./.git/hooks/commit-msg.sample:	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
./.git/hooks/commit-msg.sample:	echo >&2 Duplicate Signed-off-by lines.
./.git/hooks/pre-push.sample:# pushed.  If this script exits with a non-zero status nothing will be pushed.
./.git/hooks/pre-push.sample:# $1 -- Name of the remote to which the push is being done
./.git/hooks/pre-push.sample:# $2 -- URL to which the push is being done
./.git/hooks/pre-push.sample:		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
./.git/hooks/pre-push.sample:		if [ -n "$commit" ]
./.git/hooks/prepare-commit-msg.sample:# message file.  If the hook fails with a non-zero status,
./.git/hooks/prepare-commit-msg.sample:# To enable this hook, rename this file to "prepare-commit-msg".
./.git/hooks/prepare-commit-msg.sample:# The second includes the output of "git diff --name-status -r"
./.git/hooks/prepare-commit-msg.sample:# commented because it doesn't cope with --amend or with squashed
./.git/hooks/prepare-commit-msg.sample:# The third example adds a Signed-off-by line to the message, that can
./.git/hooks/prepare-commit-msg.sample:    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
./.git/hooks/prepare-commit-msg.sample:#   /usr/bin/perl -i.bak -pe '
./.git/hooks/prepare-commit-msg.sample:#      print "\n" . `git diff --cached --name-status -r`
./.git/hooks/prepare-commit-msg.sample:# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
./.git/hooks/prepare-commit-msg.sample:# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
./.git/hooks/pre-commit.sample:# exit with non-zero status after issuing an appropriate message if
./.git/hooks/pre-commit.sample:# To enable this hook, rename this file to "pre-commit".
./.git/hooks/pre-commit.sample:if git rev-parse --verify HEAD >/dev/null 2>&1
./.git/hooks/pre-commit.sample:# If you want to allow non-ASCII filenames set this variable to true.
./.git/hooks/pre-commit.sample:allownonascii=$(git config --bool hooks.allownonascii)
./.git/hooks/pre-commit.sample:# Cross platform projects tend to avoid non-ASCII filenames; prevent
./.git/hooks/pre-commit.sample:	test $(git diff --cached --name-only --diff-filter=A -z $against |
./.git/hooks/pre-commit.sample:	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
./.git/hooks/pre-commit.sample:Error: Attempt to add a non-ASCII file name.
./.git/hooks/pre-commit.sample:exec git diff-index --check --cached $against --
./.git/hooks/pre-applypatch.sample:# by applypatch from an e-mail message.
./.git/hooks/pre-applypatch.sample:# The hook should exit with non-zero status after issuing an
./.git/hooks/pre-applypatch.sample:# To enable this hook, rename this file to "pre-applypatch".
./.git/hooks/pre-applypatch.sample:. git-sh-setup
./.git/hooks/pre-applypatch.sample:test -x "$GIT_DIR/hooks/pre-commit" &&
./.git/hooks/pre-applypatch.sample:	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
./.git/hooks/pre-rebase.sample:# The "pre-rebase" hook is run just before "git rebase" starts doing
./.git/hooks/pre-rebase.sample:# non-zero status.
./.git/hooks/pre-rebase.sample:# $1 -- the upstream the series was forked from.
./.git/hooks/pre-rebase.sample:# $2 -- the branch being rebased (or empty when rebasing the current branch).
./.git/hooks/pre-rebase.sample:	topic=`git symbolic-ref HEAD` ||
./.git/hooks/pre-rebase.sample:git show-ref -q "$topic" || {
./.git/hooks/pre-rebase.sample:not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
./.git/hooks/pre-rebase.sample:if test -z "$not_in_master"
./.git/hooks/pre-rebase.sample:only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
./.git/hooks/pre-rebase.sample:only_next_2=`git rev-list ^master           ${publish} | sort`
./.git/hooks/pre-rebase.sample:	not_in_topic=`git rev-list "^$topic" master`
./.git/hooks/pre-rebase.sample:	if test -z "$not_in_topic"
./.git/hooks/pre-rebase.sample:		echo >&2 "$topic is already up-to-date with master"
./.git/hooks/pre-rebase.sample:	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
./.git/hooks/pre-rebase.sample:	/usr/bin/perl -e '
./.git/hooks/pre-rebase.sample:			/^([0-9a-f]+) /;
./.git/hooks/pre-rebase.sample:				/^([0-9a-f]+) (.*)$/;
./.git/hooks/pre-rebase.sample:			if (!exists $not_in_next{$elem->[0]}) {
./.git/hooks/pre-rebase.sample:				print STDERR " $elem->[1]\n";
./.git/hooks/pre-rebase.sample:    build on top of it -- other people may already want to
./.git/hooks/pre-rebase.sample:		   o---o---o---o---o---o---o---o---o---o "next"
./.git/hooks/pre-rebase.sample:		 /   a---a---b A     /           /
./.git/hooks/pre-rebase.sample:	       /   /   c---c---c---c B         /
./.git/hooks/pre-rebase.sample:	     /   /   /   b---b C     \       /
./.git/hooks/pre-rebase.sample:    ---o---o---o---o---o---o---o---o---o---o---o "master"
./.git/hooks/pre-rebase.sample:	git rev-list ^master ^topic next
./.git/hooks/pre-rebase.sample:	git rev-list ^master        next
./.git/hooks/pre-rebase.sample:	git rev-list master..topic
./.git/hooks/post-update.sample:# To enable this hook, rename this file to "post-update".
./.git/hooks/post-update.sample:exec git update-server-info
Übereinstimmungen in Binärdatei ./.git/index.
./.git/FETCH_HEAD:05b29dd997d18b5a887edd2457fb0482503ddbac		branch 'master' of github.com:maettu/Data-Processor
./.git/info/exclude:# git ls-files --others --exclude-from=.git/info/exclude
./.git/config:	url = git@github.com:maettu/Data-Processor.git
Übereinstimmungen in Binärdatei ./.git/objects/e0/c134e1c125d344b84cc74914035604cac8ccd8.
Übereinstimmungen in Binärdatei ./.git/objects/e0/8ec9bbf80a3207f33097a852e272ff06af8c49.
Übereinstimmungen in Binärdatei ./.git/objects/e0/3e0227ea660833265945716dd880b26293a5a4.
Übereinstimmungen in Binärdatei ./.git/objects/c1/33de624bd2b0d2060c37e5f8f8522b806f107a.
./.git/objects/c1/4f02d5ec78dad98311b8d45ead1fe984697e52:xAO0=)z0H $z0pnf@-i4mڴM7WEThGU}h0tR'2ZkH9V:ClB܂o;לOabTCiѩ9e	3f,N27͙ڶcqP+Y.=BI:lYG~ޫ7(	`hh@Ro|9CY1>R90t/QԆTϣOc{l
Übereinstimmungen in Binärdatei ./.git/objects/c1/a2de2824185aaf34aef8b17a395836eecd59cf.
Übereinstimmungen in Binärdatei ./.git/objects/6c/8cc8ff5e4a55e3f51829a5dcd4e1a3f629a256.
Übereinstimmungen in Binärdatei ./.git/objects/61/2f1cec9750c7f8c8c6ec2a4993b44424a56e88.
Übereinstimmungen in Binärdatei ./.git/objects/61/d7e16c5e19226dcb28509ec54017f11a555ab1.
Übereinstimmungen in Binärdatei ./.git/objects/dc/b39a4bf1ae1529817e4880883800552cbc6e2b.
Übereinstimmungen in Binärdatei ./.git/objects/dc/69d136508cf2b712f6c55ad05e2b91a0e4c922.
Übereinstimmungen in Binärdatei ./.git/objects/33/113f5e838260ba428091911e485d8ff8a0a4e8.
Übereinstimmungen in Binärdatei ./.git/objects/b2/f2e6cb1728b7fe5d3d5955c8e5a3c31edfa963.
Übereinstimmungen in Binärdatei ./.git/objects/b2/455f5d16a05a5e5884a7af60592213df909675.
Übereinstimmungen in Binärdatei ./.git/objects/81/44307c25ad59cdfe50aef1d0debd49e23057f8.
Übereinstimmungen in Binärdatei ./.git/objects/23/09eb7ae720a0b568b153c4cfefe864f75e7a77.
Übereinstimmungen in Binärdatei ./.git/objects/23/c7fa2e13f758cf2aadf0d72bb02f4e32a0c54a.
Übereinstimmungen in Binärdatei ./.git/objects/2e/57a5ba4b1b57b9249b59909ff2b85f270c3ac6.
Übereinstimmungen in Binärdatei ./.git/objects/49/797e3312b173ce9f1df4929fd249ea294442ce.
Übereinstimmungen in Binärdatei ./.git/objects/49/0f1ccfb113eba45675bf038468bf6b5f6edfbe.
Übereinstimmungen in Binärdatei ./.git/objects/bc/81a52236fdeee4c230482cb7891986d0d0ab99.
Übereinstimmungen in Binärdatei ./.git/objects/bc/70db5630d4ab28b41e22d0704baab87576ab2c.
Übereinstimmungen in Binärdatei ./.git/objects/bc/8b0fd249ca365c6d78c5b9ad4beafc02584bca.
Übereinstimmungen in Binärdatei ./.git/objects/57/c69a3a17773fa6ad41e97f4f0f88e0408fe8e8.
Übereinstimmungen in Binärdatei ./.git/objects/57/8f2c293929957304ea12b793381c4dc2f4bb23.
Übereinstimmungen in Binärdatei ./.git/objects/57/a6e60ae04a69a766b324e005716ffaf99bc40a.
./.git/objects/57/8206af1c5688f5edeede2dfc7823b69e3e7a70:xVn63;X^H1"M1-QY(QwHʲ2yI{ι\fjI_
./.git/objects/57/8206af1c5688f5edeede2dfc7823b69e3e7a70:=n`0*eT-#3t^C*M'pr7K:u{i` Z`LDFq׷c+Cs2QzM33BTZm3sa_q8Q*ּM#z:j74tj-r-*lCn~FdR[=21"KAop|?ȌR42۴ejWeq<k9ASsAqQ\"ۣ/vnd9\<!N@>H3BXUgTp]X<AdVZ.yN<+-BD2@AadCE!pV]hCOA̍r*kUfzK*xY"2	<^V_-Rd	Z;퓢<U^6LX!k?X&v`.ţظ<Jӿg2CSզ$@䦆1V4Ԟ-	g]y&4TM`^N1(\LlηP)̠W2aNՖ=+vF[H-,\Y/\zHvT+2ڎhٱPa6tZr]d_aĦ۵Qtl]w
./.git/objects/57/8206af1c5688f5edeede2dfc7823b69e3e7a70::J8YD)7-1xqntmd`+7;&AkY|5^B^;N1i1$G_^XGwդ>*G
./.git/objects/57/8206af1c5688f5edeede2dfc7823b69e3e7a70:4Gw}T-+<^$,y|U0`/<lJ`a{4.0CxW'^fE0Y,|9f
Übereinstimmungen in Binärdatei ./.git/objects/ef/425302b494648759986ec27bb311a43e82f2f5.
Übereinstimmungen in Binärdatei ./.git/objects/a5/d03ae8fa93d0d55fb1e5908fe14eec2085c520.
Übereinstimmungen in Binärdatei ./.git/objects/a5/8f884910c79e0e23e3c33338c8c8e3a48938e1.
Übereinstimmungen in Binärdatei ./.git/objects/a5/dbfd1d6202063c03c4a72ca77fdc5aa8f591c7.
Übereinstimmungen in Binärdatei ./.git/objects/b3/cc22969f8dd0588944a7efd8768741febf9877.
Übereinstimmungen in Binärdatei ./.git/objects/c3/e1e42dfc731dc3a5e3622991c8d0a01c50dec6.
Übereinstimmungen in Binärdatei ./.git/objects/c3/6e5bfedb5ad14bd2c64415228525bc9011a38b.
Übereinstimmungen in Binärdatei ./.git/objects/21/61d77b7c018613b07a735db7587067aaf44eaa.
Übereinstimmungen in Binärdatei ./.git/objects/21/ce1dc9c58e409ab17fef9ec068dd8e61450a6f.
Übereinstimmungen in Binärdatei ./.git/objects/21/9f98e239254d9d8a457d726d8948d8ed9221b6.
Übereinstimmungen in Binärdatei ./.git/objects/21/06af1fa46f6925c471890ebbbf2f09c71fbeb1.
Übereinstimmungen in Binärdatei ./.git/objects/9d/b98406eb7981f0730b2e613f5548e70366c674.
Übereinstimmungen in Binärdatei ./.git/objects/9d/151fe549f153b5461bd19c42661605077dba3e.
Übereinstimmungen in Binärdatei ./.git/objects/99/b8996ebd1edf347edc3b0b8d82718dc4e99257.
Übereinstimmungen in Binärdatei ./.git/objects/99/0c332186df454e93590d3cb508b6aef1e8a76b.
./.git/objects/99/8a45a3cdfd70b1a38000e08dc133467458dffa:0P9EBdi"CL)X[jzxeـthk)AҘ!Qe|P-Ip`Zݐ5(W)i쀕
Übereinstimmungen in Binärdatei ./.git/objects/b4/a3b1b2115d573becddfdeb19d66869cf605063.
Übereinstimmungen in Binärdatei ./.git/objects/b4/a10f2ce6bc1ba27e94dabc828a182061642675.
./.git/objects/d5/98e0a7807bdc2d423b7e04494e9f06e4ea976c:xmPM ݳbd%-,$ׅ=]JSԴ^M<->g8X`پM!DotY[3@j?b}TT]Ic{w}ĳi.o&刿jQ^(SJq.EnL&Y,E?F8ի1%{@KM֢\o.H1L:$R>pE?P@.>2NP/F<^1soKuG#Ue#91q={Ny
./.git/objects/d5/b35f7f8476b421d1f0a1b49e3410ec7e95e134:xeAo0{W=$RݬIJiUC֭m(=6N	a{3<`bth8J5>	/;kjt$yzZ|??'IlPJs%񪄛>zR[	uh/ \HvP0r7rlūWU$t"Y3Hg'4B>HUTAXFR;Ѷȧv7Nz 钛I,\}N\¢!&dޤ(xG&Z1XiYs><	tXwyYQf2j"|×%g;(仹QX-=&HlqVbEV*nIyRFj[Pa/r̫<wy5~뱁֚jhfPxqb](I,)&cs
Übereinstimmungen in Binärdatei ./.git/objects/d5/48a06ed272da50f2988712c57dcbab0db7c09f.
Übereinstimmungen in Binärdatei ./.git/objects/6d/e9d545af2485a40d458512ab85c5846f5efb2c.
Übereinstimmungen in Binärdatei ./.git/objects/6d/08ac57dbdc964b3aab840dfbb0e4951a0e5862.
Übereinstimmungen in Binärdatei ./.git/objects/6d/55686cacb153e230879001bbb9c33588cfa11a.
Übereinstimmungen in Binärdatei ./.git/objects/6d/3c899f9145c7cf30e537f59944e142704db759.
./.git/objects/64/21037eea5e81a430024afde4432a08cb206271:0E]+f/d "<&`97-460֝&\\7 N+3e/G}bˆKZ&s33c=2	;RB(YeGh*\ۺ2:+""/BMڪ7H
Übereinstimmungen in Binärdatei ./.git/objects/64/d6c844aaa1a7238743070752966de3010154a1.
Übereinstimmungen in Binärdatei ./.git/objects/64/36765966e3478d242f28ec499d9f589f1793c5.
./.git/objects/26/cb30ee58489643736af90166b903544ea82725:WjHlk7(R3d'9K$ȁdÍTǉp<i_gkx-_3/7dM
./.git/objects/26/fca7cdcf705690b74c72f2f87277583e529347:xmQJ1CaZXo7Iv5IZ7.n޼73h4\]\=l Ez[|$1VUޱoިSx\0QeMD1VYU7;δT-|j
./.git/objects/26/fca7cdcf705690b74c72f2f87277583e529347:O/٩Jũp?;_z;/dq6ZN0Tcq-iK.䙯59KtL5Ğd#:!Zkf?Α'
Übereinstimmungen in Binärdatei ./.git/objects/97/280c767ce5ea06a2932bd4e449771e4dc26436.
Übereinstimmungen in Binärdatei ./.git/objects/97/4eed72bcbeadd7b0ca99d8b68842d5101c9ae4.
Übereinstimmungen in Binärdatei ./.git/objects/97/6269dba38b8dbc8f5720e36eef72e3c6517a49.
Übereinstimmungen in Binärdatei ./.git/objects/27/7b5bc3b72880516a7d8bda9a19140d7e6ddf46.
Übereinstimmungen in Binärdatei ./.git/objects/27/ebca306dadc1a8e93a87478a203d455a9c741b.
Übereinstimmungen in Binärdatei ./.git/objects/27/1319612b36bf8d63e9166165934594239c09f9.
Übereinstimmungen in Binärdatei ./.git/objects/27/b41cc2e1e23e5c68537165f112718f076b1253.
Übereinstimmungen in Binärdatei ./.git/objects/27/2201a8465b0d40bcc29f135ae3fb562364416f.
Übereinstimmungen in Binärdatei ./.git/objects/27/7c6fc7878fd8b641886499ff2b3876f1e67dd9.
Übereinstimmungen in Binärdatei ./.git/objects/27/74893cf18ee665e609a7232c8db867d093408d.
Übereinstimmungen in Binärdatei ./.git/objects/7f/0fd230af4cee39d6b97b27796a7296fd0eaeae.
Übereinstimmungen in Binärdatei ./.git/objects/7f/c2bf717856fe8093cc5ee122dd8a56e7567726.
Übereinstimmungen in Binärdatei ./.git/objects/7f/0ddd265c64dc020dc733fc5b9e719a14688aaa.
Übereinstimmungen in Binärdatei ./.git/objects/a3/87ee42e0540be04f2144768b8b5e426c156dcf.
Übereinstimmungen in Binärdatei ./.git/objects/60/650af3fb0098aaea8238d750f89e17b19cb4ee.
Übereinstimmungen in Binärdatei ./.git/objects/e9/c7b5e4c5b6efffaf4d07e75fc02aaac71535d4.
./.git/objects/73/4e485d7df21b66613865828f03c498a0ed862f:x+)JMU07c040031Q(ON-./+ev}%Gݫx>c 10gsk{20"8
Übereinstimmungen in Binärdatei ./.git/objects/73/32f865b938ad1432a9e39c83bad350e871caf3.
Übereinstimmungen in Binärdatei ./.git/objects/65/f4693c5fca61342876c4a7ddf05e1235965a69.
Übereinstimmungen in Binärdatei ./.git/objects/af/d983f39eedda1a48123ea2519617fdee29cd6e.
Übereinstimmungen in Binärdatei ./.git/objects/af/a21d7c316f6343519a8732032f1f630d30cf3b.
Übereinstimmungen in Binärdatei ./.git/objects/af/f502c97128f25e7ac42eaa34c061f76e385457.
Übereinstimmungen in Binärdatei ./.git/objects/a2/e1a197a63e348ff74f2af3525a630eb41c7989.
Übereinstimmungen in Binärdatei ./.git/objects/a2/3f22b2288ebd482a7f4901fd12eb48d702f1e0.
Übereinstimmungen in Binärdatei ./.git/objects/a2/95b7d7f3c114392448427d40fc9800d05bf4bf.
Übereinstimmungen in Binärdatei ./.git/objects/b7/0a1b5be599e62c7171861b5e09c772ad4e0340.
Übereinstimmungen in Binärdatei ./.git/objects/b7/8f6fc104ab42af153e0e4f333738dcff3c38a3.
Übereinstimmungen in Binärdatei ./.git/objects/b7/7d184fe13f7432085ce46bcbb6768d9e513330.
Übereinstimmungen in Binärdatei ./.git/objects/b7/28a688eea7188cb822f244fae2e74194af9ecb.
Übereinstimmungen in Binärdatei ./.git/objects/b7/c3673fdef7cd59dfdf391302a42a051df49f90.
Übereinstimmungen in Binärdatei ./.git/objects/19/cd6165640ffc34f40188aa967d7d0c61346e14.
./.git/objects/19/1de6a6f8de3ab831999bf32059697f86eefd5b:0E])tЅh.0IItϟRj}vتF_~g?i<Q%oZX̊z?8gY;.#ӏ%%K-
Übereinstimmungen in Binärdatei ./.git/objects/19/5ecd994efdf03dbdb9b5065fbf72080b51384b.
Übereinstimmungen in Binärdatei ./.git/objects/5e/e6d4c13db7c3f378722ce6020cf12e94aa7f9a.
./.git/objects/5e/8889f64ecf3c66cb0ec2abd6f012d5190ef488:xKj0@ю7}-B(gTvpAvZry[O0d.CpHhJu,:dw];pqGAO9zv1H$gEl"h۶{o3~q#u^w%)Y8XgծmZpnn~7kU
./.git/objects/e2/f2606fb1008c1633bb0a808daddf48a76866b0:xmKo@{_1JWr$k)dH9e*>Z3`io٩Z]Ow'ʾZ:zs̈́Dx+:xuD79>I\Af}Yr'zkN.7h+HO1!oVjA.L;Aga,К:PFtt=;+434ˋ `z3/pb2*- &_Ҟib'y9S^b/.\Ht`&~;>dBs5߶j}>y]ķ;|}8ӧq!\wӹ1iwlp5`(cFD0h`W	U	Pf=uxr =i'	ӡ=+gE+q"Cy
Übereinstimmungen in Binärdatei ./.git/objects/1a/7b23d0c2e11cc788a9c323e011bb3dceb503d3.
./.git/objects/86/a6588520fa1a2349fbdc4c3bfb942119950e9d:@uS-P)]vB
./.git/objects/86/a6588520fa1a2349fbdc4c3bfb942119950e9d:ik̔I׷HާbW&,r]	VK=ۊ?B:-a$~S'x!#)}2qaܺ5
Übereinstimmungen in Binärdatei ./.git/objects/86/deaa3441a4341fd80846263f128a5eda3b39e5.
Übereinstimmungen in Binärdatei ./.git/objects/1e/8dfe4e25198d24a7c6e08f522b7af661ad3aed.
Übereinstimmungen in Binärdatei ./.git/objects/eb/69a54e566d0754a751589a350368da04d1142f.
./.git/objects/eb/05b93e47cbf536d44249708a3b1de54e8bbb99:xSMO0s~*V*9qEIE)RwƎVfޛqQ	-uFUnN #?.MpN鋡
./.git/objects/eb/05b93e47cbf536d44249708a3b1de54e8bbb99:%H~[K#>bIts- ˣ6Mwm=%{٭|l[n#3]ts6BE"x))ipd+*\Z4x沁}ANgzǺ«4LTE;"x!ꕵU8qaVۉ[?[yq;tYEE]S9m0W,
Übereinstimmungen in Binärdatei ./.git/objects/fd/c6f0da181694be9046243b5f57e115e767da72.
Übereinstimmungen in Binärdatei ./.git/objects/fd/c69052072304d500741be48a0b961830d78fc3.
Übereinstimmungen in Binärdatei ./.git/objects/22/b799b63d62c59eefb6354b8c00f2e4ff5d33b4.
Übereinstimmungen in Binärdatei ./.git/objects/22/ec3dda195c2b58988c7f663c873e456d72b895.
Übereinstimmungen in Binärdatei ./.git/objects/22/7187e3d131f889f84183951db7d65c409e21a4.
Übereinstimmungen in Binärdatei ./.git/objects/22/b252cf32670e321836a35e46da838aa1f16f3e.
Übereinstimmungen in Binärdatei ./.git/objects/2f/82a9d9fcf86d7abc875f170a0aa0bdd6b6fb14.
Übereinstimmungen in Binärdatei ./.git/objects/07/faa2d647f2d10527fadfb23d9aebb503ac9c50.
Übereinstimmungen in Binärdatei ./.git/objects/07/d594468feb70d9ee89e554728696ef4b4e52f8.
Übereinstimmungen in Binärdatei ./.git/objects/f8/0a754dd01d5a714db9d6d77a3f046738b5583f.
./.git/objects/f8/47b3f59df4be1a31cd4e916c35b834d4bb444d:xeQ=k0_q\!5u-tc+ѓbB{%jއ޵#twq]){[K1.s㚢xeh-q)4Cb*\υZ?S3`=!T
./.git/objects/02/52ca4c2a2fbcfca60d5bd8826faecfa2d25942:-ہRB9"˙rҐdmOe*pQN%`HZX*sLs%kDY+ơR>56n(Ԛg)Ӧmͦ{deC̵z{'Uӏ"1.Mᦫm?cR
Übereinstimmungen in Binärdatei ./.git/objects/02/83da7b0201d1d201f49d43c39f97555dc3e5b2.
Übereinstimmungen in Binärdatei ./.git/objects/fa/172a2ef6c844ababf50a83fbfdfcde19060f19.
Übereinstimmungen in Binärdatei ./.git/objects/fa/80263d113d2ec7353f9a8f9213fb2c2410332a.
Übereinstimmungen in Binärdatei ./.git/objects/fa/393f15f35505517efeaa9a638fed051386ef6a.
Übereinstimmungen in Binärdatei ./.git/objects/6e/5055831d3173f72a4444c7771f6ac6c8ef3581.
Übereinstimmungen in Binärdatei ./.git/objects/6e/b5f951e676724c9f1742ecd2b6310d749a158a.
Übereinstimmungen in Binärdatei ./.git/objects/6e/5841ab5a58cf021beb29af5bc5060bd30f3b3d.
Übereinstimmungen in Binärdatei ./.git/objects/bd/9a78fe1e408171132702b8326789d00489d707.
./.git/objects/90/2024d2cc226c713e817897baee048e126c6971:@W-]A-=4bٕM߷22v-]T"w%,X-l+P
./.git/objects/90/2024d2cc226c713e817897baee048e126c6971:C资7zȢMJ8q!Uuw	jXJJnq&B3-(K'h:Ib
Übereinstimmungen in Binärdatei ./.git/objects/90/85086ab92179de4073aba6ab80cd8b6ad62707.
Übereinstimmungen in Binärdatei ./.git/objects/90/392bb1e26d9b9d31dc55936c9b962d5043a4c7.
Übereinstimmungen in Binärdatei ./.git/objects/90/1460f9f34b38b9c17e540746e9e91903b6383d.
Übereinstimmungen in Binärdatei ./.git/objects/12/b2c4d4362db31a6069fbcb8828ff6db5d3ab6f.
Übereinstimmungen in Binärdatei ./.git/objects/12/3beb608c35b229a9c3f82bad536da48f9aabff.
Übereinstimmungen in Binärdatei ./.git/objects/2a/9fa0c7df825db2d62a831bb242271c267e8223.
Übereinstimmungen in Binärdatei ./.git/objects/2a/2c0d5ccd5b6c5fc7bd64e39a007b4963981737.
Übereinstimmungen in Binärdatei ./.git/objects/36/fde5c01b3a93b0afaa89671ff9b836329d267a.
Übereinstimmungen in Binärdatei ./.git/objects/36/59aa91c0b79ab1b352d9bd2c1beac6a8e95830.
Übereinstimmungen in Binärdatei ./.git/objects/36/e692d7224d3aa5e66819566d00c063aaa537fb.
./.git/objects/36/4321fee76b5dd656d7c726ceba06e4f585e820:xeQj0_!J$ЎCB|un!d#l'ۡ{S;ROw'`ڕ"c߂\7(^qɟ+FkK!85PV/	R S#3Ds3@72+y$5#jד#WkiRIx28#dR@C-O4]r˜=K,3WJs9(p&r8\`A%XL0,&51-c@阦 dbOkeKsݚ]
Übereinstimmungen in Binärdatei ./.git/objects/7d/a7b458d00f14822ff53b329ac5a386177d496f.
Übereinstimmungen in Binärdatei ./.git/objects/18/c25360be40d71b9a73c88369f0efcdd7c2508c.
Übereinstimmungen in Binärdatei ./.git/objects/18/d85330e6e0ff91ebbbc11145b29129f1b446ba.
Übereinstimmungen in Binärdatei ./.git/objects/18/8e716db1ecc3b99977876e5b7df28df727c5f4.
Übereinstimmungen in Binärdatei ./.git/objects/18/786f9ef6625c501d26d53d3e129dc6678838b3.
Übereinstimmungen in Binärdatei ./.git/objects/6f/034c50466f8280c0e0aa65d6824c7f9e2fa94c.
Übereinstimmungen in Binärdatei ./.git/objects/6f/89a8059779f89331b1bd909ccbd425bcde7c21.
Übereinstimmungen in Binärdatei ./.git/objects/6f/712ddf823ae1d294498e86809735074704a8a9.
Übereinstimmungen in Binärdatei ./.git/objects/a4/120d7bfb834891749c9dd57a1aa819fd804e7d.
Übereinstimmungen in Binärdatei ./.git/objects/5b/34f4a00fe864acc1f4989bb338454a6c0c0f23.
Übereinstimmungen in Binärdatei ./.git/objects/94/3cc67bdca35bdbcf5d11fa28e26848309bce45.
Übereinstimmungen in Binärdatei ./.git/objects/94/4df554dbc56a760b654da49f5f8efbf54ede15.
Übereinstimmungen in Binärdatei ./.git/objects/f0/0c4b87349fe63dad9c16508daac7ac9a0243f4.
Übereinstimmungen in Binärdatei ./.git/objects/f0/5d1b47cd7f37a8c5465a2d09a1585284e4f88d.
Übereinstimmungen in Binärdatei ./.git/objects/06/a234381bdec06cf2fe799116f5fe525c3f0425.
Übereinstimmungen in Binärdatei ./.git/objects/06/4b05ac2649ed1c2d7f75a231f79fa36f35be5e.
./.git/objects/e1/e45acf0ed130fb261cca2cab4fb3d0597b8415:xS]k0s~ťs9H{m/HmlIRE}iTg[ܯ&J`>{{8{g1#X-R{ٖ#,QU(L¢{=jVrC2fꄜwdNuQBdN#8$>`R,Oǎ3ꑄ
./.git/objects/e1/e45acf0ed130fb261cca2cab4fb3d0597b8415:8Jr,DGdL_>۸mFak4^C.+Čץ/kVT[mvtﵨ*Amv^%,[۞T{zQq=!ڡ7r}xz.lP-qąZ5Z~1kJ
Übereinstimmungen in Binärdatei ./.git/objects/e1/0a5d6e17ad065a8cfb7a101a44018f37d754b7.
./.git/objects/a0/f7ecfe0f709159bf24a746076017e571788bfd:xKN0Y-D[!. &Qqp3b1`RZAkKJ0RFY1tlY3eŖ]:X&-*(Ѻ4(9Gw_s"71jE1xFvc^{oF&ڰE:TDp.iNiXk^y(%хQK7j۱렽ãn@>/Ԟ;zmB_vmj&
Übereinstimmungen in Binärdatei ./.git/objects/2c/5e66a45e45242718722da4f79b7cb71d585d5f.
Übereinstimmungen in Binärdatei ./.git/objects/15/94201646aca65c8abb413a166317b310cf8d33.
Übereinstimmungen in Binärdatei ./.git/objects/52/29a377e21eafc6dd6e8754d249a7ae33775e6a.
Übereinstimmungen in Binärdatei ./.git/objects/55/9f56cc2e29ece9d31788a188ee85a718586e7b.
Übereinstimmungen in Binärdatei ./.git/objects/55/34e97b664c0e1cb170153c5f79cb14a846e21c.
Übereinstimmungen in Binärdatei ./.git/objects/55/a48e4f8eb50ff1aebfc8afcdb45db87dbca8f7.
Übereinstimmungen in Binärdatei ./.git/objects/55/49f218b5d2048d51b70998cc3dc56a0da00446.
Übereinstimmungen in Binärdatei ./.git/objects/59/6091520399378fe343128a141fabe71a30acf1.
Übereinstimmungen in Binärdatei ./.git/objects/0b/c66734c1429afbff7b2662454432e061722bf1.
Übereinstimmungen in Binärdatei ./.git/objects/0b/4b23101c5c54e32907419fe5e5cc6ea26f9302.
Übereinstimmungen in Binärdatei ./.git/objects/0b/09209bfcf46673196e613514bb5b4087d876e9.
Übereinstimmungen in Binärdatei ./.git/objects/d0/933a6bec0572f32b50ca57ecec729ef64c0a36.
Übereinstimmungen in Binärdatei ./.git/objects/d0/6d214ddbcfa106b81ff3910973a45e1057e4d7.
./.git/objects/d0/b160a295dc12d1fcb4fad1742c8dd6127e5e2d: 숢,v"%9r,Eg2JP{mUq6Is>{m-yjDѾh]ߪ3[_uC96<@wL
./.git/objects/00/fba760b3d2b4ba17a5ec52aa6f84eff0c1407d:x+)JMU07c040031Q(ON-./+ev}%Gݫx>c 1~ɴ?hQvdqBӢ2:n!
Übereinstimmungen in Binärdatei ./.git/objects/00/b0d13bf8159436a325b55694b5b6ae92cff31a.
./.git/objects/00/92b3463ae3d1544cc8c1fd1e383be080183cd5:@sPV]\$ؽ-El\s<A?)Q%hQ*wTП/ȁSr|n%
Übereinstimmungen in Binärdatei ./.git/objects/00/6ad061bff1db51fb25051bd8c52dd0ede7f105.
Übereinstimmungen in Binärdatei ./.git/objects/25/017b5c608a4dfd50d9e4a63589a7f314272c04.
Übereinstimmungen in Binärdatei ./.git/objects/67/c9631ab29e344f3d73a7de0dfbf89e67b2e4bb.
Übereinstimmungen in Binärdatei ./.git/objects/67/aa06d8a0b915b60c984d95d008f3bdb2a4c0c8.
Übereinstimmungen in Binärdatei ./.git/objects/da/f711f502f125fe41efb9bf06c5e4062d183570.
./.git/objects/a7/13613cd71355a971ec27dfb32298b947469098:xJ0E]+fI% "tLH*p7gs-Ma;̐s 7sH]ɒ099Q]%˾9i.1G"[-][7R]7
Übereinstimmungen in Binärdatei ./.git/objects/d4/76085e02af6b5230dab5f36150df60929f3fbf.
Übereinstimmungen in Binärdatei ./.git/objects/d4/fe9f9b6008f177f39f139e264c54ef7ee963ac.
Übereinstimmungen in Binärdatei ./.git/objects/d4/49d7a4787e9e1a072146f37cc785d288726865.
Übereinstimmungen in Binärdatei ./.git/objects/d3/46135db336105721af0fa0e77528f5e24be436.
Übereinstimmungen in Binärdatei ./.git/objects/3c/6ab700006829117ea055e6c53a0023df1e71c7.
Übereinstimmungen in Binärdatei ./.git/objects/3c/6049e848b90cdf84be691ea1ac2ec8bd0571a3.
Übereinstimmungen in Binärdatei ./.git/objects/3c/fe071bf49c23f5cb48e3024fd4ceae66842e72.
Übereinstimmungen in Binärdatei ./.git/objects/0f/609f8246165522ef68672f1fce9a153e095be9.
Übereinstimmungen in Binärdatei ./.git/objects/0f/7055a0dcaaf230f72eab175db4af8301871399.
Übereinstimmungen in Binärdatei ./.git/objects/c7/f78134fc41d7a167840d4fdb95b26afbc2d6a5.
Übereinstimmungen in Binärdatei ./.git/objects/c7/c4b1da37f1bfd78b2c259da9abcf235a09c963.
Übereinstimmungen in Binärdatei ./.git/objects/01/f397f941f1081e50df35cd97a432a1b1d7a3a2.
Übereinstimmungen in Binärdatei ./.git/objects/72/37a7c1d4b1447d03a767495b3fbb4ec10a8e02.
Übereinstimmungen in Binärdatei ./.git/objects/bf/c44654a1531538ecff9f9814390a3e42106b4e.
Übereinstimmungen in Binärdatei ./.git/objects/bf/99bc5ae46b30e4ea67a376f479f64c6568fb27.
Übereinstimmungen in Binärdatei ./.git/objects/f9/baefba79c48c115db2b4ffa3d0c3a66a044d3b.
Übereinstimmungen in Binärdatei ./.git/objects/f9/f267c26680552ca6739f26c68cd32287a7f432.
Übereinstimmungen in Binärdatei ./.git/objects/fb/89d1aacef8009ab174611c9e126bfb9091d2ff.
./.git/objects/53/72537e6a571d94179e3666754950c6e56f73b3:4ed3Ădۇޠoxe_צڙ-zF&c@@7eR
Übereinstimmungen in Binärdatei ./.git/objects/fc/5969e66c4e6a62a6f465c86b5d2a2a90bf550b.
Übereinstimmungen in Binärdatei ./.git/objects/5a/d0976a9030ef242b2669c646ffb78d2748fece.
Übereinstimmungen in Binärdatei ./.git/objects/5c/83a145cbe69676a2776548ff1184c456d9924a.
Übereinstimmungen in Binärdatei ./.git/objects/5c/5393ad2fc59ec77ddc5dfa4402b1611e1500c1.
Übereinstimmungen in Binärdatei ./.git/objects/9a/4244c121629988f18298653ffcae4d9db219f0.
Übereinstimmungen in Binärdatei ./.git/objects/9a/2e77d3cacb205604624579b298795933d3dd9d.
./.git/objects/9a/836e57db17b2122660d827d43501c97f42da81:KMl8*[y6!!␘E}\EJI-'{8nEG8?w:=;/}@bbNpj+Eܾ7S`J
Übereinstimmungen in Binärdatei ./.git/objects/9a/6e286c0688afafb8a36e4a6b37c008fd45a503.
./.git/objects/9a/88f4df05cdb0f6dd2dd0ea5465688e79fefc3e:0@a9EB&i"CL	)jzQoxyk":SCDe{d!IɖJj]1Rx!2KrP+gv.%9*j$Go{57}6v:-&FKȃ>]WDA3J
Übereinstimmungen in Binärdatei ./.git/objects/2d/ee6d6dabe8668639ffbf2c07b67d624e6ee8a0.
Übereinstimmungen in Binärdatei ./.git/objects/2d/1f01aad4bcd3944a84af0a22404342035c148f.
Übereinstimmungen in Binärdatei ./.git/objects/f7/74d7e1265ddbf6b209638612e29e2f65864cdf.
Übereinstimmungen in Binärdatei ./.git/objects/f2/6ac08ef33c04115ec26f7e6da3a9da846915a2.
Übereinstimmungen in Binärdatei ./.git/objects/b8/210d0affd67fc4a20ac2a7b171378afc1a39a9.
Übereinstimmungen in Binärdatei ./.git/objects/b8/d4fe821990491c4bb89c27ec3701c156443a0b.
Übereinstimmungen in Binärdatei ./.git/objects/b0/b3bc339803309be23bf8329716f376c9fff510.
Übereinstimmungen in Binärdatei ./.git/objects/b0/b46c0fbd139034e8ecffd5df5570e36bb0fb52.
Übereinstimmungen in Binärdatei ./.git/objects/b0/e2661753f5bf59e35c18a03623c86ae37afe10.
Übereinstimmungen in Binärdatei ./.git/objects/78/efbd497eb356dade3c3ce313848dab615a20e8.
Übereinstimmungen in Binärdatei ./.git/objects/78/01b66b1cf3db815d537cb5faad7a0ef23ec392.
Übereinstimmungen in Binärdatei ./.git/objects/78/e9e2cd523caff9afe969d90429b46ecc1b5b37.
./.git/objects/d8/0f8995a34e499cf9467c8da84fef73ffd1b44a:x-±
./.git/objects/d8/0f8995a34e499cf9467c8da84fef73ffd1b44a:0`{pMS2HTN<=H ﮃߔ}pm|jΩp-Z-u%;v,1Ñ8#/`Y(5U/w H
Übereinstimmungen in Binärdatei ./.git/objects/d8/30f3f55b27231654afe1c52405f2e9bdadffc8.
Übereinstimmungen in Binärdatei ./.git/objects/3b/ad0d6037e4121998995fe123fd1e17db36ff57.
Übereinstimmungen in Binärdatei ./.git/objects/3b/1034d96123a80fe3cf97e487f235077bcc37a6.
Übereinstimmungen in Binärdatei ./.git/objects/a1/ddac2a19d97fe671c420575b1a19d9606f8d95.
Übereinstimmungen in Binärdatei ./.git/objects/ab/a05bbc24ab0730b398ff84913a6636522d1230.
Übereinstimmungen in Binärdatei ./.git/objects/ab/5097b4ef24edbf835434cf79aef08c89369565.
Übereinstimmungen in Binärdatei ./.git/objects/77/c6f28de5e0e582c96f98d3657cec32aa204749.
Übereinstimmungen in Binärdatei ./.git/objects/62/094f367efcae20509972eec7ac4cd0846ec371.
./.git/objects/de/7d9bfdf1a4bb52b15677f454ab92147a4e5f17:xTn@홯YH)V촊T"衽V꡷80;UMwDVB33{of`-ןVz`Q	ި-zo@6+%ZM{j>`Y2x,Wd>QXiq.x`o0,Z#h[ϿaQDcdgVΑc(\ũeWxgd&lIL,Pvaäݖ5ZYjUDkӱSC40)j^TKI4;	2iW#t}E#b?!HJZsźsc(dyyOQRxh6n,Se~b2zhb(_Z6@k$a$.x҃1"H^F.c/83Y8辑iX3JN[J]v]ݑA-vwp$	Cu;+tBB5(_0r5,Tn~;Mi
Übereinstimmungen in Binärdatei ./.git/objects/de/c41711734d4c8b12297e65cab71f1064e6424d.
Übereinstimmungen in Binärdatei ./.git/objects/de/e3335c825a43dce7ec5b46908ac90594b9a4eb.
Übereinstimmungen in Binärdatei ./.git/objects/e8/530c504f4fbe60c167e3c1ec636ba08850ba93.
Übereinstimmungen in Binärdatei ./.git/objects/e8/f6005c950404aa86d0874c62ab1e19f6df9835.
Übereinstimmungen in Binärdatei ./.git/objects/e8/7df33a48a2183780243e1a6d7b9287370facd0.
Übereinstimmungen in Binärdatei ./.git/objects/d9/e88700acbd39993c2b3f580ab355b10508395b.
Übereinstimmungen in Binärdatei ./.git/objects/d9/a1056b84ab5cd4c33faf83632ca7d8483ecf62.
./.git/objects/8f/8d71139c6cd9eba521d87f237255bdfe315fbc:xeS09_͖ eJ-hVm[%d.Ʀ)B(AY5ļ{fXkOOoN^⩞g>8Մ|((J|A?mߜw0\d>Hk>본xpsEbMP Xle@c#2͢$W:m$'x^[iLҟ0kz~Zjf-W$8#E!FGL\3YEM=7_H-Dbx8<,#6J"']dfo*2(*z]BI&$7 y亄pN\ ̆kOBbP/Tж<=V1#whjDWrR*H	2Ny2VHB+#|@|}V\5eLҲ"N3}wlK4Zq*jso%M1
Übereinstimmungen in Binärdatei ./.git/objects/8f/a36caa022d2b606332f697f251c6386eae0faa.
Übereinstimmungen in Binärdatei ./.git/objects/8f/967f370ca272410f59dfd58d4ca9ad96b98135.
Übereinstimmungen in Binärdatei ./.git/objects/8f/a924a5b25fd0f95b30263dc0512c080019339f.
Übereinstimmungen in Binärdatei ./.git/objects/85/283cc5a997ce5d78a7b4119fcba228fde547d7.
Übereinstimmungen in Binärdatei ./.git/objects/03/71722ad905a9f8d213fada74ae0d759141a962.
Übereinstimmungen in Binärdatei ./.git/objects/16/ed9380f48f7492863696d5a0750d4264da46a7.
Übereinstimmungen in Binärdatei ./.git/objects/16/ee53d4d3425049fb7bc0f1e22f448c18ee65ad.
Übereinstimmungen in Binärdatei ./.git/objects/16/a353b506ad51862fc8b1591066c077bec1747e.
Übereinstimmungen in Binärdatei ./.git/objects/16/3d6dd897bd8150099ac2c10a0c55e26d67c98f.
./.git/objects/16/32b0f5b38b2ca5e436c2f7d9f7c409e78c8154:xV[o63!.`;v(1ZKb^bJ,"QTǋeKؓi.*.TLg*<+nxʹJD]+}XS9w`8XsMG'w]?ÞhQ4VE!#U\tH7'-4/L5̈́.8$Ѣg^Ȕ˲6ibͻiLޚTT%Z[TJ|ņY,l>3Fd: x5靈'UYQ FfK[.}Zf7e@'hAiQ-RRUN[-9wN`yF_UYyA|-uzqDdֽ`\Ƽ$^Ԋb\%I .	LaRDjJC*C{|c.J$Kc].VpeR>IcXĖ7ETR:r<LT/Q-S~]#<	5u݁v]B}Iw'2?6حxigwq.GǱV
./.git/objects/16/32b0f5b38b2ca5e436c2f7d9f7c409e78c8154:@Qx2u]:ruʲ$tΞrUoW^>-TqfԙP x86b00d6G\1#A퍶:ёt,\@͞fZՠcCZul	'Q[K{1RItjW!E&rnlbHzĹj*Gp^+VwH]Fmֱ>[Q!MOqR))*"3bUE_cdkrt/zNleUOWh#@QBsM}x	oҭ~-o`w-X7gw]scrZPINews]VMW+3
./.git/objects/16/32b0f5b38b2ca5e436c2f7d9f7c409e78c8154:lHٗOƪhg=z~hxr3G"^Xs!3-Tfъ	%-;Si_30ez0a;1lwģJPa/4ܾp2[.'7W%c5
Übereinstimmungen in Binärdatei ./.git/objects/29/cb6e074f4e8b89a0b0c0ed99d0af532a5152ed.
Übereinstimmungen in Binärdatei ./.git/objects/f4/c8865ece4f6b6cf82e533d8d0d380a09fff360.
Übereinstimmungen in Binärdatei ./.git/objects/df/c769b4a7b641b938ca18a9f76bdf1fd6552115.
Übereinstimmungen in Binärdatei ./.git/objects/df/b6bb97b20944f2981a3a1b2847c93ec10b8796.
Übereinstimmungen in Binärdatei ./.git/objects/df/c0b9b5f856b67d2f7bf910a2c9b2035d1c7d00.
Übereinstimmungen in Binärdatei ./.git/objects/df/13817a5ba3d5cc6e1bafc3bf42a743cc1ca1ec.
Übereinstimmungen in Binärdatei ./.git/objects/cd/193322c3b333026bf3a876a8021021f11adedc.
Übereinstimmungen in Binärdatei ./.git/objects/ff/161b9c87ddc93509f71ac36ccc222d4eb54aec.
Übereinstimmungen in Binärdatei ./.git/objects/92/9829fec5aadc6e6d172a377a668b519cd18847.
Übereinstimmungen in Binärdatei ./.git/objects/92/774653ab163c264590f5fda369c58b52938e99.
Übereinstimmungen in Binärdatei ./.git/objects/88/9ec32a66be56885b595d18002066602172d21c.
Übereinstimmungen in Binärdatei ./.git/objects/88/6a36f2ccfddc1bdd874aa8a3e87cdf9ed78ad5.
Übereinstimmungen in Binärdatei ./.git/objects/4a/b11352e8c89ff3042a7522a70c566cff2753f5.
Übereinstimmungen in Binärdatei ./.git/objects/ad/69f52aeef635dc40f5c0dc0bdc50b0a8e98184.
Übereinstimmungen in Binärdatei ./.git/objects/ad/6131c5bdd1bf55722f5f30bb29ea1da5fb51c1.
Übereinstimmungen in Binärdatei ./.git/objects/c0/29105619e4ace56843077fd4624247a7dde7c1.
Übereinstimmungen in Binärdatei ./.git/objects/8b/3b826d5966308b771401decf3ed45a90dc4014.
Übereinstimmungen in Binärdatei ./.git/objects/8b/a276becd147b33fc7177fc280fb73b1ef43a06.
Übereinstimmungen in Binärdatei ./.git/objects/32/280ecee6cbe894239c2614d8f277b6b3d2d004.
Übereinstimmungen in Binärdatei ./.git/objects/32/9c4094e6bf07a0908073d32256e5cec2d164a1.
Übereinstimmungen in Binärdatei ./.git/objects/32/2d3370d352e1b756efff03489842f002c69767.
Übereinstimmungen in Binärdatei ./.git/objects/32/dffeb42be453eb41ef2b5fc47837b8fa07cefe.
Übereinstimmungen in Binärdatei ./.git/objects/76/228b4774323cc4038db8af085a3ebf3b87d353.
./.git/objects/91/297db8397b57c337673d42b5119c255b0aa2a2:xRMK0_1B*^DҊa/7m0$]-ݤ[q?/63{RQ	WgEHQVlw}Bw4}0$Z2(jhgtJ,D,B!\FvN	fEhZ
Übereinstimmungen in Binärdatei ./.git/objects/91/9e9eb6786a5b69d98f32288a5a11452823e7ed.
Übereinstimmungen in Binärdatei ./.git/objects/50/84af234729791056c871401f9061407029cb05.
Übereinstimmungen in Binärdatei ./.git/objects/50/013f3d168dce7faa97658280bf84182a4a7924.
Übereinstimmungen in Binärdatei ./.git/objects/50/dbdf7e2bacd2b770f430ffe96796da9cdfdbb3.
Übereinstimmungen in Binärdatei ./.git/objects/58/d3eed0df1f1c3b920acdecd38edde45afaad82.
Übereinstimmungen in Binärdatei ./.git/objects/58/dff142cc8e5452970f612b249b4eaa33e61680.
Übereinstimmungen in Binärdatei ./.git/objects/1c/51fdaf101dae5af85d3be10e5512417948f6d5.
Übereinstimmungen in Binärdatei ./.git/objects/1c/890ace8e4905dff4b127f1db3770c2e8e5e794.
Übereinstimmungen in Binärdatei ./.git/objects/13/50f439aa941f23ebdff675ed40744fa6d44633.
Übereinstimmungen in Binärdatei ./.git/objects/13/3dfc310efd89ea881cd3d6aaa9ace6e491ac9f.
Übereinstimmungen in Binärdatei ./.git/objects/0c/a84dc6c2ca2741803db6f8cd390cfe6691cdb3.
Übereinstimmungen in Binärdatei ./.git/objects/0c/61c751cb607e77e1aa20334f7c49a5ad28df09.
Übereinstimmungen in Binärdatei ./.git/objects/1d/cdb4dc63f681a32aaffe9464fc0cb369fcbdfa.
Übereinstimmungen in Binärdatei ./.git/objects/1d/f2e2341d31c88de91f52c577a731a96ac97ff4.
Übereinstimmungen in Binärdatei ./.git/objects/3d/7530f20c739725aaead20b1d79a7343dfd152b.
./.git/objects/3d/578ceea449089467e4e615d910467711d75dd6:xSMO0_1Hm%b9HnHp-rIج.ߙd)%|^vϏjB/5yWd>wڙl(Q/:{[u?8!uq䴡ܺ
./.git/objects/3d/578ceea449089467e4e615d910467711d75dd6:]	,KX۬xۂ`W-EY)E
./.git/objects/3d/578ceea449089467e4e615d910467711d75dd6:QVj"+m3 ,s>nڤ;ZfrkgՆ.9*rۡW_e |atTXIzvge[t˫]ehkgMAŤ0fA{'e+_i3>5iz{3Mޗ)̳kNƚ!!(Ɗ\t-~	0&w7waamļ^M+A3NKvt0~0NXcǒ_{"?l(U^7+
Übereinstimmungen in Binärdatei ./.git/objects/3d/052a2dd2b8431814c0dd62c6ceb0762aebf575.
Übereinstimmungen in Binärdatei ./.git/objects/3d/0376d1a52c66f24184a21a9637b99fe54f5bdc.
Übereinstimmungen in Binärdatei ./.git/objects/aa/f976f439b7aedc8a21962cd4112230035e346e.
Übereinstimmungen in Binärdatei ./.git/objects/aa/6e5b3aee201f53b98dde8a28a761974a8c89d7.
Übereinstimmungen in Binärdatei ./.git/objects/3f/ae6b7d932e98742df6d9573774dfef834f7e93.
Übereinstimmungen in Binärdatei ./.git/objects/3f/0e1dbbf36014a3f4e230d518f3626786515fb6.
./.git/objects/3f/efc291c6f19d11bddae7040226b33097dc3ef6:x]Ro09iH$I~(R&T!ސ\Vc)s~ݷ~Z&`B4A	>;)˞_6wy=!\-BcQq2QȢ(s!yj%lv瑭Hnx=*J[4S8I[怽~E&kTh"=ASw?Y8jv]z$ÆȓR[v,)$ jY)9w|	u;ςy59A-	) *3_/CdؖjR˫iCN?El#߃-lGY|p>XD#IK8E7ZKB]`Fפ8)xH<r>xcdEp$,pY}UWc[e-.bgD/_r3%yt5ȵⵊe"i:*0$1
Übereinstimmungen in Binärdatei ./.git/objects/14/1b73cf0ea4ce003e941153116ca2ae7703c8e8.
Übereinstimmungen in Binärdatei ./.git/objects/14/6496e8d6fec63e6813612cd6613b381a2a523a.
./.git/objects/db/40aca8774043888634974499899ee7bba360dc:xUAO0=S=1x-4>vRIyG5YiuАGdvT|}]~_.YF|TW9yĸ|{`)@Ztꝴ[tV-HP%d3\JE~a֫!ҁڨx(|@Bx*ƓeO!p'Lr4@FTkgi˓{;b,dEu#?t;jCHB6Ϋ~r"_)h)0ԙ5Jv)%*3DꠥXÜw
Übereinstimmungen in Binärdatei ./.git/objects/db/aad417415a375b0b54e90bb730739d08f31b37.
Übereinstimmungen in Binärdatei ./.git/objects/46/f9f2259ce565d82140a9fdeceb78960b67f21d.
Übereinstimmungen in Binärdatei ./.git/objects/05/b29dd997d18b5a887edd2457fb0482503ddbac.
Übereinstimmungen in Binärdatei ./.git/objects/35/670df38ef435619e724d79ced249d77d1b1700.
Übereinstimmungen in Binärdatei ./.git/objects/51/89888425f0d8c877c00cfd3046276383373243.
Übereinstimmungen in Binärdatei ./.git/objects/51/c7dd9e9bf08191e98880dc07cb2dd1d9dc87cc.
Übereinstimmungen in Binärdatei ./.git/objects/f3/fef3cb3e5b936f19797b16298ae97890645c07.
Übereinstimmungen in Binärdatei ./.git/objects/bb/7d6ef91dbeffca035aa0d2e3c3cc3b08821ace.
Übereinstimmungen in Binärdatei ./.git/objects/bb/18c96aebe306fc172b61c4b83c9b3b617b902a.
Übereinstimmungen in Binärdatei ./.git/objects/95/8d972132ecc9fddd09eef445c0350c4c7ae706.
Übereinstimmungen in Binärdatei ./.git/objects/95/9116dce4022024998c7070a0402c7a7ebbd22b.
Übereinstimmungen in Binärdatei ./.git/objects/95/50094da3f261f4f0c55fe1ae212657f95e38ab.
Übereinstimmungen in Binärdatei ./.git/objects/95/e221bc3c0f6a474d1ab311c6e1e155f84a7b35.
./.git/objects/95/eb2193e508066684e10581c0acc2c3b7bef56c:xAj0E)/;6tCȶLL'h7-A2ֵ+PO@FJ3<7U/Q<)8s]6.|XHb"SI2t+:Hމ.cwV]:veǗïGk}D֧`3ZDS~SU%1^o2
Übereinstimmungen in Binärdatei ./.git/objects/4b/9ef8bc07b00dcccb17baa2f9707cf4d89345fc.
Übereinstimmungen in Binärdatei ./.git/objects/ce/74346c92e0d2aab8b7f9ce45d1fe555f9e187f.
Übereinstimmungen in Binärdatei ./.git/objects/ce/8366cb4b2e5fe52e59efec73a563153ef1fddd.
Übereinstimmungen in Binärdatei ./.git/objects/5f/122b0f257b2ce6788a114904aa5cb43fdd0851.
Übereinstimmungen in Binärdatei ./.git/objects/5f/c2e2a64e5d11564c12f630628f55366a2ea9a7.
Übereinstimmungen in Binärdatei ./.git/objects/68/6c5e733293cf8f5ab317b116eedd6850bd2404.
Übereinstimmungen in Binärdatei ./.git/objects/7b/d1b425efdc8eb18c3ce429caa88f05f54e1925.
Übereinstimmungen in Binärdatei ./.git/objects/7b/066d42d68dfaf1e11055d640ea2211e5b31d81.
Übereinstimmungen in Binärdatei ./.git/objects/74/de76b2fb4a7018bd2dc8c497c0848c73127aaf.
Übereinstimmungen in Binärdatei ./.git/objects/30/5315019626c50ec3101e720eade24776081e39.
Übereinstimmungen in Binärdatei ./.git/objects/8a/b9bb7ee60f74f4f5a87bac1fcbbdf5b62d539b.
Übereinstimmungen in Binärdatei ./.git/objects/8a/29ea77bdd04c67a13b444350d27210bcce754b.
Übereinstimmungen in Binärdatei ./.git/objects/8a/6306aaa547a0de379150b2f70a11a444f58ba6.
Übereinstimmungen in Binärdatei ./.git/objects/89/a1fd6d6af0e141f50bb6c507ec1236ccb96e87.
Übereinstimmungen in Binärdatei ./.git/objects/ae/414728ce83cb3d9f843d61b17283bc6141f0c6.
Übereinstimmungen in Binärdatei ./.git/objects/ae/70fe045198144afab4dbf84c5c7b3e5aa8419c.
Übereinstimmungen in Binärdatei ./.git/objects/ae/02e0de2bfd5bb4270143b5eaeb83d20f1ad2d4.
Übereinstimmungen in Binärdatei ./.git/objects/1b/91e5307aa43b6a65cef2c8bd7ba5e9523d2a3d.
Übereinstimmungen in Binärdatei ./.git/objects/1b/d18a221aa8f9efaa90a2590802c9f3d9f9b875.
Übereinstimmungen in Binärdatei ./.git/objects/1b/e4dc136ee726eaf1f78de8ccc691e5d0edf96e.
./.git/objects/28/0fe0fac7a1e5efe38aa0c64735c6fe85e762b8: E;F>(tֵ(MK˅\.yWZ#d耬A6!i׸4 pV*9e+`1\*:4[JQ>sD~RF߫-5~JyN
Übereinstimmungen in Binärdatei ./.git/objects/28/a1b4af90afe504ab3df1b05380b93ce4e0a4f2.
Übereinstimmungen in Binärdatei ./.git/objects/28/ec1e11b20a6309cd5d761553876e3585d3cc12.
Übereinstimmungen in Binärdatei ./.git/objects/28/c31292138efb7ba2b4bdcb513d45f48afb3781.
Übereinstimmungen in Binärdatei ./.git/objects/8e/3b6d36f2af55597f5f419ab8bcd92d89bb303f.
Übereinstimmungen in Binärdatei ./.git/objects/79/d6db07a903f108dd8baacc49e0fc352ee03bd9.
Übereinstimmungen in Binärdatei ./.git/objects/45/2b62734545ed5c7699d6adf0267c8c2f97c8d4.
Übereinstimmungen in Binärdatei ./.git/objects/45/63c33655756f8d1a831ec69383f7eba98ff0e2.
Übereinstimmungen in Binärdatei ./.git/objects/e5/8c9c7976bca0f79d7fb250fa540a2174bfc4f4.
Übereinstimmungen in Binärdatei ./.git/objects/e5/8cbe5a3577585e332ced66098481e3a7d13db2.
Übereinstimmungen in Binärdatei ./.git/objects/f6/3ec1d59a690de6d45921f06c48d63da7060478.
./.git/objects/b5/e826e0946761fe49a503f9189406ec9ebfbd6a:AM/7pm~X{ʞ96:9WMHMt!'+5ǐhXG-bgP-)VtD/?2<ǷuZܮΠuYgZ]WDz5J
Übereinstimmungen in Binärdatei ./.git/objects/b5/959e0b47e4a9d4c1c07f67b8dda0b7ee46f17f.
Übereinstimmungen in Binärdatei ./.git/objects/c5/e13b3c25c6a3e2d2eb61754c790c01a25ecae8.
Übereinstimmungen in Binärdatei ./.git/objects/c5/1ac62fec41cef0fbcbc2a4d4f4fa2e81de2fe4.
Übereinstimmungen in Binärdatei ./.git/objects/b1/bf46b64d384d962bea6920aeb2d6e2ec780fb6.
Übereinstimmungen in Binärdatei ./.git/objects/b1/e0b094e55aa2d4bda028608048c478bad571f6.
Übereinstimmungen in Binärdatei ./.git/objects/c8/4f46ca027373b53c22bfd71dfb56e8fefa1a30.
Übereinstimmungen in Binärdatei ./.git/objects/c8/513d05676e2ebfde3feddcfd341303a15b9b5a.
Übereinstimmungen in Binärdatei ./.git/objects/d1/ab9c1609b8642376306b36659e7f79215dc1a1.
./.git/objects/d1/52d00e9288368727c8fde66ba125fe269f84a4:ҨJmXeL:9}6 keT$WC|{P0|i%ֹ^?夌_;gL>R!T_ҕ?ov閎TڕdBB5lCWX ɺg8_dj-W$I}ﯽ&jS|PfI)yef<fl^	8_oxa'Y&Cvnb^p̈́g?Ȟ[QM%NEr_-V!ᖻZ)tJT+,%?-Z˚EZR)ƨe,έ!?)yݸJ%)u#,)1dv[4fGYqv_Gnz"&׫rf{%'[X߽=,i
Übereinstimmungen in Binärdatei ./.git/objects/34/b9bca9141b7bc5e959f3b57a61809d49a2516f.
Übereinstimmungen in Binärdatei ./.git/objects/34/6bd808af8615ec20c527856b72ae93ee817dec.
Übereinstimmungen in Binärdatei ./.git/objects/5d/734d6149401a2555000200afccd46579c56a36.
Übereinstimmungen in Binärdatei ./.git/objects/5d/043a8216884435c4faec4c46e17bf17069e9d2.
Übereinstimmungen in Binärdatei ./.git/objects/5d/fe45e78d1c0856bbe15f76cf53c3717dd837fb.
Übereinstimmungen in Binärdatei ./.git/objects/5d/4639d5d11be87a9826722ae2f7419e48cc23d3.
Übereinstimmungen in Binärdatei ./.git/objects/56/e4bdab2e0ccf3127d12c849102f0393f8e3726.
Übereinstimmungen in Binärdatei ./.git/objects/56/74ab375eec9d23c20d05686dc430740ae46c3d.
Übereinstimmungen in Binärdatei ./.git/objects/56/56e20f7e5ab4f05da1b04c7319cf7855300c5e.
Übereinstimmungen in Binärdatei ./.git/objects/56/faff1d55ad5217177bb5cb1c9a8712ab991428.
./.git/objects/38/50e95bfa1e342e26b76714b48cc506bf66cd08:[f$Qnl,'4}Zcl-LZiLk+]Z蒜%V7m0#Kq+:qYKIQ!V֤9תzfC}oTTJUS&HmyYEd.cJh	c_c:3a@www'8Xo(|Vf*	z7e~hoyeر8+]ӳ\"#R*$\E`@AVeK3)<.S{G!/i5L1u%Lइt}yM4^2(څu&rpbAu-=9޶
./.git/objects/38/50e95bfa1e342e26b76714b48cc506bf66cd08:T*-DΛg-{[L$ޕib˵}r,g{5DXt#\qnR;T5cr֑;8fuR/60uđDd-bPK-xv t{ʍ%z5r_J|xzbe?zGW`ۆ陓hN]`&V륿1lccӡLS3G8M	Fc,<djZL;<!:"0O>mCWO5Wz=A>y7x<etE|	xY|&smh8f7X1c+nm!! ٞ;79vSc806W?g8y0qߞXʭ@͵|>r-.]ILbmנ>b6Eء,lX7\XQRa!n#JkD{ӬL
./.git/objects/38/9fdbd6a271648fee3821de9af0d25a836f5152:xeMo0wίk?ӴTؤqJ$ U6gZ-8~:|0ppǗ&^[M1:$4k1|Q~⪶(X1P8THk$0 a4v|T?AQߛi]Sէ1|+{/WnAT5
./.git/objects/38/9fdbd6a271648fee3821de9af0d25a836f5152:W=}3Lс=wP$}/u^KuYIͦyyQ|<۔1O[Nǧt]aBI.Ufi p+hu9P!(ZJ-f4JZH#+WMEv@Tb){aK"H
Übereinstimmungen in Binärdatei ./.git/objects/11/55e6e8936944243d33f8afef0f94f423daf16c.
Übereinstimmungen in Binärdatei ./.git/objects/11/9abfc12a6ba23635440ccb3f03829a7a433478.
Übereinstimmungen in Binärdatei ./.git/objects/8c/02f7d4a89fea41d2c232db1e29ca35f5d1c25d.
Übereinstimmungen in Binärdatei ./.git/objects/d2/63bef3b1c7a302f500a9358140f726b20ec3d9.
Übereinstimmungen in Binärdatei ./.git/objects/d2/f10f27c614067ff3ffbe81229c225b29465794.
Übereinstimmungen in Binärdatei ./.git/objects/d2/47a394ac62acc62aa3b1a351193c656c222c67.
./.git/objects/9f/149189c835a65d71279763c9abd650ae549173:x1j0ESS,fmIK!]b4;%'i>>e|Ocl3fFL"ڔcֈ>7+NΚ6idbQ-j=3UX$G|>.|?;{.:5:_pv<_iIkQ{;vۗRZa
Übereinstimmungen in Binärdatei ./.git/objects/c9/11c8da2b742c1c2a3dfe5d527bf9d047dd0b38.
Übereinstimmungen in Binärdatei ./.git/objects/f1/6936b3a6059dfe7121853744bf900ba8002ff3.
Übereinstimmungen in Binärdatei ./.git/objects/f1/78a4903fd03a4ea66d2de40687bac425142ce8.
Übereinstimmungen in Binärdatei ./.git/objects/f1/a8fe7d3012a5bf8a27dc42c537c37e199b71c4.
Übereinstimmungen in Binärdatei ./.git/objects/2b/089e4cdcd0914eec46056fd2f35c010c2da9af.
Übereinstimmungen in Binärdatei ./.git/objects/2b/1e0d173441bf75701c67482d7c1439bb2f3737.
Übereinstimmungen in Binärdatei ./.git/objects/2b/7ba84f19d7068005619ed73846ebc4d22d31fe.
Übereinstimmungen in Binärdatei ./.git/objects/04/1f17c3eb12c79b1a48cab5632caa416937e8aa.
Übereinstimmungen in Binärdatei ./.git/objects/04/3cd16bd4333a3839d8ef590d2e29a8d164652e.
Übereinstimmungen in Binärdatei ./.git/objects/04/1b8bb4f699d6d9f4de6760f53d737d69031262.
Übereinstimmungen in Binärdatei ./.git/objects/9b/01d352316860b9c395d3df0f382cdedf0e8316.
Übereinstimmungen in Binärdatei ./.git/objects/9b/2816c4504cc8f59022d10d68236c3d410bd225.
Übereinstimmungen in Binärdatei ./.git/objects/9b/be1eee78b242e63ad08592dd659f0e9f7e85a3.
Übereinstimmungen in Binärdatei ./.git/objects/c6/6ec93c4027677b97c441fc3fa1efc5b2210947.
Übereinstimmungen in Binärdatei ./.git/objects/c6/6ee237af1a7db6f89f75a8b0bce149d8033012.
Übereinstimmungen in Binärdatei ./.git/objects/75/8e648fa408cb3cc2a76c7fa5d31ab31ac19990.
Übereinstimmungen in Binärdatei ./.git/objects/7a/588e257e1089d214b53d3c5dc6b8a9c616f56c.
Übereinstimmungen in Binärdatei ./.git/objects/10/7b28a40bc6eab8514976a124e445c3e372e9f8.
Übereinstimmungen in Binärdatei ./.git/objects/10/a3bb5b3763e8d445a8861556fa6ef56495a17b.
Übereinstimmungen in Binärdatei ./.git/objects/10/683f362a2cabfdc70e3e49192c787cacda6363.
Übereinstimmungen in Binärdatei ./.git/objects/10/99fb6fd156577482714e19d946e51152339b7e.
./.git/objects/d6/8e61472e845ab46624152123428dfa43b66052:"p0=޽FK#>9 荎˵5#iC/{U{xR #ăW6ʋ3=ʗvU-l)vS
Übereinstimmungen in Binärdatei ./.git/objects/d6/2fa73794a073bef329fd27abf058b2ae91a16e.
Übereinstimmungen in Binärdatei ./.git/objects/63/f11af6b49f5e6fd2d2ef67d962da5ae7e1c6fe.
Übereinstimmungen in Binärdatei ./.git/objects/71/13d25795c05c05aee842dd3ca6f5752ba36240.
./.git/objects/71/92508f80616a49c2e703a6ffd238eed6a14d1f:xmA 쯘C ]h`鶰$.LR5-俯&z3{>w_oc@;P^ض轊m=i|U'(dnIxTERʗTpC
Übereinstimmungen in Binärdatei ./.git/objects/71/04f36f5a2e7c5dda288630c8bd5df67b458880.
Übereinstimmungen in Binärdatei ./.git/objects/41/0556c41d77a0581aec7d0619c6590b68996372.
Übereinstimmungen in Binärdatei ./.git/objects/41/1d85c24d7d8e6510eec2377a48eae59e4f63b0.
./.git/objects/37/ce1438a253cf7cc2e6189d38cdf77e7114c18c:Q,#Iq;$-')w.D,{Ô9f&
Übereinstimmungen in Binärdatei ./.git/objects/37/fa6e628d66b37fae2e366761732fab19ac52df.
./.git/objects/82/d720913d8a58923a1f4303fdafb17e5b90d150:ܐ	A70AHNQ[-iɛ<MQn<\I 8?R	QP(X0"0SmELWX*'8|~bj5B~vڮuY{n'Xep8-I{݀&G
Übereinstimmungen in Binärdatei ./.git/objects/82/68598d7e9ae7cb0c825975b29b371e22d736a9.
Übereinstimmungen in Binärdatei ./.git/objects/dd/de03e8f30cd42413f6ef7392cc8749cb18fc6e.
Übereinstimmungen in Binärdatei ./.git/objects/a9/563ddc073566d43b32f949e01e14d7fb35a4b2.
Übereinstimmungen in Binärdatei ./.git/objects/3a/d3aed2a9a5cf42def56c9f1f547b4ebf618ea4.
Übereinstimmungen in Binärdatei ./.git/objects/0a/d79cceea7b606de43747a001a7d0bdb3fe73b3.
Übereinstimmungen in Binärdatei ./.git/objects/ca/99ea494be74e0a79ac9dc67f86eedd8028002a.
./.git/objects/ea/25d153ec307e9aba0aef6fb1e9daa91213b54b:xKN0DY-Do	!.!vDSUIr[YZ}'wc5:&_XNcٖa!Dک&hf59hYCs2̠<R5!)ƑcVt:"<$2tu?jK^@wNx@%wXqM^Cm2_??('?ԭoSi'
Übereinstimmungen in Binärdatei ./.git/objects/ea/d7366d969a75e807b6b58ffbab6a0a44d4a8e9.
Übereinstimmungen in Binärdatei ./.git/objects/4f/2f0209a38c72a32333ad0746daaecb4c54aab0.
Übereinstimmungen in Binärdatei ./.git/objects/4f/65901c5e82e3e9441d8e780388c43424fd318b.
Übereinstimmungen in Binärdatei ./.git/objects/8d/934af191551ec12b6642f3d1da4938169b5db0.
Übereinstimmungen in Binärdatei ./.git/objects/84/a03651b056b17db8c63180c3ae1120bb7bcb73.
Übereinstimmungen in Binärdatei ./.git/objects/cb/191e7899e581142ec4d0b52c385a214c0c71a8.
Übereinstimmungen in Binärdatei ./.git/objects/cb/cfb44260ff326897079531adb8844793f873b8.
Übereinstimmungen in Binärdatei ./.git/objects/cb/7d05d2368d15300a0e81dfd182c65315b990f4.
Übereinstimmungen in Binärdatei ./.git/objects/c2/584f609927e4bbf10e8c0cb4bfca7733bddd9a.
Übereinstimmungen in Binärdatei ./.git/objects/c2/ce275511104eb54ae4378a661a188bed724df2.
Übereinstimmungen in Binärdatei ./.git/objects/be/c0b887c425c1fdf7b610ff975581be89628cf8.
Übereinstimmungen in Binärdatei ./.git/objects/e6/73fd6751450b13e5ff7879749e078d4779e1b2.
Übereinstimmungen in Binärdatei ./.git/objects/e6/2003d2ee0e05a4ed770d3bd7c81000a708f8e3.
Übereinstimmungen in Binärdatei ./.git/objects/a6/b4ac27158ac1e9dedeae071cf09789ba357547.
Übereinstimmungen in Binärdatei ./.git/objects/a6/3c1634b50baa7956a0880ed478db92e22b8480.
./.git/objects/08/c37d0c8f08b0ed926aa472f942f956497209fc:xJ1E]Wnʣ3DDJe:Џ!{D\^8eJC"ڠBv8q̽s0Jw7273ZuJQTR]N}g`S)pr(IIcvyڎ6,.Phq^}vr.W@5b£B:Nk"*+ͻ0Ѻ`p-mq'ֶjYu]jwOq$V+}x
Übereinstimmungen in Binärdatei ./.git/objects/08/d2e71c3e72d19494e975e1c69586acf34ac71a.
./.git/objects/08/3ee67aa0564acef8fba657c5465bf9f056dbe5:xe10`75ViAڈWT(H 7-Րf[e} 7ua'4m/彚gD"	br E%
Übereinstimmungen in Binärdatei ./.git/objects/09/bcba47a782754dd0f3d000c49f6e1a0e327c21.
Übereinstimmungen in Binärdatei ./.git/objects/47/7471f495242d572f567e0a78b64cc3ee37d15f.
Übereinstimmungen in Binärdatei ./.git/objects/47/37037541fa55b9a8d9e6f10ab4523287d8c34a.
Übereinstimmungen in Binärdatei ./.git/objects/cc/525fd8d73debd5eb1607bfe3f01df7466a0165.
Übereinstimmungen in Binärdatei ./.git/objects/cc/2ad9cefdbe69b93095a1bfd3f804f803b7846c.
./.git/objects/80/e522afa6c55c511789dff521a2fd4a8d662f05: E/}bI$5-A7-@ڞH5Q6H%1b왵\v	JT\B$u@T8i9ڌl;<|ke/?7.pY~<\Z!iӽp(Ֆ7hIl
Übereinstimmungen in Binärdatei ./.git/objects/69/a257bf7053c4ee3f19811a2536079a7233bcd9.
Übereinstimmungen in Binärdatei ./.git/objects/69/42699bd1ad82cb78bd8bcc9dc40cfeb51107a1.
Übereinstimmungen in Binärdatei ./.git/objects/48/c0bddfef3c9e09407f84e7768d7b5e00b08b99.
Übereinstimmungen in Binärdatei ./.git/objects/48/f586ecf5c12622ca30f4a7abc428a7a43c76be.
Übereinstimmungen in Binärdatei ./.git/objects/48/07aca75ce5ea5e9edb7c4f41066b3d3105cdd5.
Übereinstimmungen in Binärdatei ./.git/objects/66/bf0972e4dce7f2c6cca236fed9e40f32eaf2dd.
Übereinstimmungen in Binärdatei ./.git/objects/66/2532aa8ca5c83bc6283075d9cbcc52e22bd0a7.
./.git/objects/66/35bc7aacd88e133d773fe70555faa9c8c58b68:X/dǛ/o_aQa'ri8	GP;匡][1:҂P\OM_UӼk<BkjQ=zk 1-vϢ;*|,;O||q&]L_WJ3rhhgoq*@Hөu@)";.g3\>{JglMuBY\̳{
Übereinstimmungen in Binärdatei ./.git/objects/24/93d89eba9c625cc1586b7dc8de6859e6a984a3.
Übereinstimmungen in Binärdatei ./.git/objects/24/78d66db6d748748f23322ee477a6ab911463f2.
Übereinstimmungen in Binärdatei ./.git/objects/c4/37aa5afbfc8882700bfdb3639524484356095a.
Übereinstimmungen in Binärdatei ./.git/objects/0e/2871d5c2653b0cf3846d7005d1936c68b82b97.
Übereinstimmungen in Binärdatei ./.git/objects/0e/a8e429ac03072db97065f6344f6bc99dc04cba.
Übereinstimmungen in Binärdatei ./.git/objects/17/847d5bfa7d5ea3da677277e41a0455db3ff7a4.
Übereinstimmungen in Binärdatei ./.git/objects/17/e3fdc2461326da08f63d232525b1d3c833ae9c.
Übereinstimmungen in Binärdatei ./.git/objects/17/446ec9f26fde53d8dcb74ee2bf7cc929757833.
Übereinstimmungen in Binärdatei ./.git/objects/17/8381dee7fa5fbf63913f981b93c44aa092ff68.
Übereinstimmungen in Binärdatei ./Data-Processor-0.1.6.tar.gz.
./Data-Processor-0.1.6/META.json:   "meta-spec" : {
./Data-Processor-0.1.6/META.json:   "name" : "Data-Processor",
./Data-Processor-0.1.6/META.json:         "web" : "https://github.com/maettu/Data-Processor/issues"
./Data-Processor-0.1.6/META.json:      "homepage" : "https://github.com/maettu/Data-Processor",
./Data-Processor-0.1.6/META.json:         "url" : "https://github.com/maettu/Data-Processor.git",
./Data-Processor-0.1.6/META.json:         "web" : "https://github.com/maettu/Data-Processor"
./Data-Processor-0.1.6/Changes:Revision history for Data-Processor
./Data-Processor-0.1.6/Changes:0.1.6  2015-01-23 16:50:55 CET
./Data-Processor-0.1.6/Changes:    - no more "require"
./Data-Processor-0.1.6/Changes:    - code cleanup
./Data-Processor-0.1.6/Changes:0.1.5  2015-01-22 16:50:24 CET
./Data-Processor-0.1.6/Changes:    - Interface change: use positional parameters for $schema, $data
./Data-Processor-0.1.6/Changes:0.1.4  2015-01-22 16:22:30 CET
./Data-Processor-0.1.6/Changes:    - array support as of t/013_array.t 
./Data-Processor-0.1.6/Changes:    - Transformer object
./Data-Processor-0.1.6/Changes:    - Error::Instance handles more
./Data-Processor-0.1.6/Changes:0.1.3  2015-01-20 09:43:14 CET
./Data-Processor-0.1.6/Changes:    - not-ready and interface change warning added
./Data-Processor-0.1.6/Changes:0.1.2  2015-01-19 11:15:29 CET
./Data-Processor-0.1.6/Changes:    - Makefile.PL instead of Build.PL
./Data-Processor-0.1.6/Changes:0.1.1  2015-01-18 21:48:47 CET
./Data-Processor-0.1.6/Changes:    - more test (mostly ported from old module)
./Data-Processor-0.1.6/Changes:    - ValidatorFactory
./Data-Processor-0.1.6/Changes:0.1.0  2015-01-18 16:50:50 CET
./Data-Processor-0.1.6/Changes:    - Error Collector added
./Data-Processor-0.1.6/Changes:    - Basic functionality: validation without frills
./Data-Processor-0.1.6/Changes:0.0.3  2015-01-15 21:37:19 CET
./Data-Processor-0.1.6/Changes:0.0.2  2015-01-15 21:31:16 CET
./Data-Processor-0.1.6/Changes:    - Code Layout
./Data-Processor-0.1.6/Changes:0.0.1  2015-01-15 19:09:03 CET
./Data-Processor-0.1.6/Changes:        - Initial release
./Data-Processor-0.1.6/META.yml:---
./Data-Processor-0.1.6/META.yml:  - 'Matthias Bloch <matthias.bloch@puffin.ch>'
./Data-Processor-0.1.6/META.yml:meta-spec:
./Data-Processor-0.1.6/META.yml:  url: http://module-build.sourceforge.net/META-spec-v1.4.html
./Data-Processor-0.1.6/META.yml:name: Data-Processor
./Data-Processor-0.1.6/META.yml:    - t
./Data-Processor-0.1.6/META.yml:    - xt
./Data-Processor-0.1.6/META.yml:    - inc
./Data-Processor-0.1.6/META.yml:    - share
./Data-Processor-0.1.6/META.yml:    - eg
./Data-Processor-0.1.6/META.yml:    - examples
./Data-Processor-0.1.6/META.yml:  bugtracker: https://github.com/maettu/Data-Processor/issues
./Data-Processor-0.1.6/META.yml:  homepage: https://github.com/maettu/Data-Processor
./Data-Processor-0.1.6/META.yml:  repository: https://github.com/maettu/Data-Processor.git
./Data-Processor-0.1.6/META.yml:  - 'Dominik Hassler <hadfl@cpan.org>'
./Data-Processor-0.1.6/META.yml:  - 'Tobias Oetiker <tobi@oetiker.ch>'
./Data-Processor-0.1.6/META.yml:  - 'maettu <matthias.bloch@puffin.ch>'
./Data-Processor-0.1.6/MANIFEST:t/release-pod-syntax.t
./Data-Processor-0.1.6/Build.PL:# This Build.PL for Data-Processor was generated by Dist::Zilla::Plugin::ModuleBuildTiny 0.008.
./Data-Processor-0.1.6/Makefile.PL:      license     => 'http://www.opensource.org/licenses/artistic-license-2.0',
./Data-Processor-0.1.6/Makefile.PL:      repository  => 'https://github.com/maettu/Data-Structure-Validation',
./Data-Processor-0.1.6/Makefile.PL:      bugtracker  => 'https://github.com/maettu/Data-Structure-Validation/issues'
./Data-Processor-0.1.6/LICENSE:This software is copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.1.6/LICENSE:--- The GNU General Public License, Version 1, February 1989 ---
./Data-Processor-0.1.6/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.1.6/LICENSE: 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
./Data-Processor-0.1.6/LICENSE:software--to make sure the software is free for all its users.  The
./Data-Processor-0.1.6/LICENSE:    a) accompany it with the complete corresponding machine-readable
./Data-Processor-0.1.6/LICENSE:    for the cost of distribution) a complete machine-readable copy of the
./Data-Processor-0.1.6/LICENSE:    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA  02110-1301 USA
./Data-Processor-0.1.6/LICENSE:c'; they could even be mouse-clicks or menu items--whatever suits your
./Data-Processor-0.1.6/LICENSE:--- The Artistic License 1.0 ---
./Data-Processor-0.1.6/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.1.6/LICENSE:the package the right to use and distribute the Package in a more-or-less
./Data-Processor-0.1.6/LICENSE:  - "Package" refers to the collection of files distributed by the Copyright
./Data-Processor-0.1.6/LICENSE:  - "Standard Version" refers to such a Package if it has not been modified,
./Data-Processor-0.1.6/LICENSE:  - "Copyright Holder" is whoever is named in the copyright or copyrights for
./Data-Processor-0.1.6/LICENSE:  - "You" is you, if you're thinking about copying or distributing this Package.
./Data-Processor-0.1.6/LICENSE:  - "Reasonable copying fee" is whatever you can justify on the basis of media
./Data-Processor-0.1.6/LICENSE:  - "Freely Available" means that no fee is charged for the item itself, though
./Data-Processor-0.1.6/LICENSE:  c) rename any non-standard executables so the names do not conflict with
./Data-Processor-0.1.6/LICENSE:     manual page for each non-standard executable that clearly documents how it
./Data-Processor-0.1.6/LICENSE:  b) accompany the distribution with the machine-readable source of the Package
./Data-Processor-0.1.6/LICENSE:  c) accompany any non-standard executables with their corresponding Standard
./Data-Processor-0.1.6/LICENSE:     Version executables, giving the non-standard executables non-standard
./Data-Processor-0.1.6/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(verbose => 1);
./Data-Processor-0.1.6/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}, 'section "GENERAL" exists');
./Data-Processor-0.1.6/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}->{logfile}, '"logfile" exists');
./Data-Processor-0.1.6/t/100_make_config_template.t:#~ ok ($config_template->{GENERAL}->{logfile} = 'absolute path to logfile (?-xism:/.*)', 'logifle has correct content');
./Data-Processor-0.1.6/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(entry_point => $schema->{GENERAL}->{members}->{silos});
./Data-Processor-0.1.6/t/100_make_config_template.t:#~ ok (exists $config_template->{'silo-.+'}, 'entry point "silos" found');
./Data-Processor-0.1.6/t/100_make_config_template.t:#~ ok ($config_template->{'silo-.+'}->{url} eq 'url of the silo server. Only https:// allowed(?^:https.*)',
./Data-Processor-0.1.6/t/007_no_value_check.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.6/t/007_no_value_check.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.6/t/007_no_value_check.t:ok ($error_collection->count==0, 'no errors');
./Data-Processor-0.1.6/t/007_no_value_check.t:$error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.6/t/007_no_value_check.t:ok ($error_collection->count==0, 'still no errors');
./Data-Processor-0.1.6/t/010_transformer.t:                return ($1 * $timespecfactor->{($2 || 's')});
./Data-Processor-0.1.6/t/010_transformer.t:        transformer => $transformer->{timespec}(
./Data-Processor-0.1.6/t/010_transformer.t:my $validator = Data::Processor->new($schema);
./Data-Processor-0.1.6/t/010_transformer.t:my $error_collection = $validator->validate($data, verbose=>0);
./Data-Processor-0.1.6/t/010_transformer.t:ok ($data->{history} == 3600, 'transformed "1h" into "3600"');
./Data-Processor-0.1.6/t/010_transformer.t:    history => 'regards, your error :-)',
./Data-Processor-0.1.6/t/010_transformer.t:$error_collection = $validator->validate($data);
./Data-Processor-0.1.6/t/010_transformer.t:ok ($data->{history} eq 'regards, your error :-)',
./Data-Processor-0.1.6/t/010_transformer.t:    'Could not transform "regards, your error :-)"');
./Data-Processor-0.1.6/t/010_transformer.t:ok ($error_collection->{errors}[0]->{message}
./Data-Processor-0.1.6/t/011_default_values.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.6/t/011_default_values.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.6/t/011_default_values.t:ok ($data->{key_with_default_value}==42,
./Data-Processor-0.1.6/t/005_synopsis.t:                    # undef is "no-error" -> success.
./Data-Processor-0.1.6/t/005_synopsis.t:                        if $self->{value} == 42;
./Data-Processor-0.1.6/t/005_synopsis.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.6/t/005_synopsis.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.6/t/005_synopsis.t:# no errors :-)
./Data-Processor-0.1.6/t/005_synopsis.t:ok ($error_collection->count==0, 'no errors');
./Data-Processor-0.1.6/t/013_array.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.6/t/013_array.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.6/t/013_array.t:ok ($error_collection->count == 8, '8 errors detected');
./Data-Processor-0.1.6/t/013_array.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.6/t/008_error_stringify.t:my $validator = Data::Processor->new($schema);
./Data-Processor-0.1.6/t/008_error_stringify.t:my $error_collection = $validator->validate($data, verbose=>0);
./Data-Processor-0.1.6/t/008_error_stringify.t:ok ($error_collection->count==1, '1 error');
./Data-Processor-0.1.6/t/008_error_stringify.t:my $msg = $error_collection->{errors}[0]->stringify();
./Data-Processor-0.1.6/t/012_factory.t:my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.1.6/t/012_factory.t:like ($vf->file('<','oops')->('/tmp/xkddf'),qr/oops/, 'error message generated');
./Data-Processor-0.1.6/t/012_factory.t:is ($vf->rx(qr{XX},'oops')->('xxXXx'),undef,'regular expression check');
./Data-Processor-0.1.6/t/012_factory.t:is ($vf->any(qw(OFF ON))->('OFF'),undef, 'is it one of the list');
./Data-Processor-0.1.6/t/012_factory.t:is ($vf->dir()->('/'),undef, 'directory exists');
./Data-Processor-0.1.6/t/002_validate.t:my $processor = Data::Processor->new($schema);
./Data-Processor-0.1.6/t/002_validate.t:eval{$processor->validate()};
./Data-Processor-0.1.6/t/002_validate.t:my $error_collection = $processor->validate($data);
./Data-Processor-0.1.6/t/002_validate.t:my @errors = $error_collection->as_array();
./Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->count()==2, 'error count =2');
./Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.6/t/002_validate.t:        string => "silo-a",
./Data-Processor-0.1.6/t/002_validate.t:    "missing value from 'silo-a'"
./Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.6/t/002_validate.t:        logfile => '/tmp/n3k-poller.log',
./Data-Processor-0.1.6/t/002_validate.t:        cachedb => '/tmp/n3k-cache.db',
./Data-Processor-0.1.6/t/002_validate.t:            'silo-a' => {
./Data-Processor-0.1.6/t/002_validate.t:                url => 'https://silo-a/api',
./Data-Processor-0.1.6/t/002_validate.t:                key => 'my-secret-shared-key',
./Data-Processor-0.1.6/t/002_validate.t:$error_collection = $processor->validate($data);
./Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->count==0, 'no more errors with corrected config');
./Data-Processor-0.1.6/t/002_validate.t:use Data::Dumper; print Dumper $error_collection->as_array;
./Data-Processor-0.1.6/t/002_validate.t:$error_collection = $processor->validate($data);
./Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->count==2, '2 errors');
./Data-Processor-0.1.6/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.6/t/002_validate.t:            logfile => '/tmp/n3k-poller.log',
./Data-Processor-0.1.6/t/002_validate.t:            cachedb => '/tmp/n3k-cache.db',
./Data-Processor-0.1.6/t/002_validate.t:                'silo-a' => {
./Data-Processor-0.1.6/t/002_validate.t:                    url => 'https://silo-a/api',
./Data-Processor-0.1.6/t/002_validate.t:                    key => 'my-secret-shared-key',
./Data-Processor-0.1.6/t/002_validate.t:                    # "members" stands for all "non-internal" fields
./Data-Processor-0.1.6/t/002_validate.t:                        'silo-.+' => {
./Data-Processor-0.1.6/t/002_validate.t:                                    example     => 'https://silo-a/api',
./Data-Processor-0.1.6/t/001_basic.t:my $processor = Data::Processor->new();
./Data-Processor-0.1.6/t/006_regex_keys.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.6/t/006_regex_keys.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.6/t/006_regex_keys.t:ok ($error_collection->count==3, '3 errors detected');
./Data-Processor-0.1.6/t/006_regex_keys.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:# Data::Processor::Validator - Validate Data Against a Schema
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        errors => $p{errors}  // Data::Processor::Error::Collection->new(),
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        transformer => Data::Processor::Transformer->new(),
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    $self->{errors} = Data::Processor::Error::Collection->new();
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    $self->_add_defaults();
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{data}}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain (">>'$key'");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        my $schema_key = $self->_schema_twin_key($key) or next;
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->__value_is_valid( $key );
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->__validator_returns_undef($key, $schema_key);
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        my $e = $self->{transformer}->transform($key, $self);
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->error($e) if $e;
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        if ($self->{schema}->{$schema_key}->{no_descend_into}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        if (! %{$self->{schema}->{$schema_key}}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain ("skipping '$key' because schema key is empty'");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        if (! $self->{schema}->{$schema_key}->{members}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain (">>descending into '$key'\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        if (ref $self->{data}->{$key} eq ref {} ){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            my $e = Data::Processor::Validator->new(
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                schema      => $self->{schema}->{$schema_key}->{members},
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                data        => $self->{data}->{$key},
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                parent_keys => [@{$self->{parent_keys}}, $key],
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                depth       => $self->{depth}+1,
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                verbose     => $self->{verbose},
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            ) ->validate();
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->{errors}->add_collection($e);
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        elsif ((ref $self->{data}->{$key} eq ref [])
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            && $self->{schema}->{$schema_key}->{array}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain(
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            push @{$self->{parent_keys}}, $key;
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->{depth}++;
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            for my $member (@{$self->{data}->{$key}}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                my $e = Data::Processor::Validator->new(
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    schema      => $self->{schema}->{$schema_key}->{members},
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    parent_keys => [@{$self->{parent_keys}}, $key],
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    depth       => $self->{depth}+1,
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    verbose     => $self->{verbose},
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                ) ->validate();
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->{errors}->add_collection($e);
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            pop @{$self->{parent_keys}};
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->{depth}--;
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        # We cannot descend into a non-existing branch in data
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain(">>checking data key '$key' which is a leaf..");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$schema_key}->{members}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("but schema requires members.\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->error("'$key' should have members");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("schema key is also a leaf. ok.\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    # look for missing non-optional keys in schema
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    $self->_check_mandatory_keys();
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    return $self->{errors};
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    $self->{errors}->add(
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        path => $self->{parent_keys},
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    my $indent = ' ' x ($self->{depth}*$self->{indent});
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    print $string if $self->{verbose};
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        next unless $self->{schema}->{$key}->{default};
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->{data}->{$key} = $self->{schema}->{$key}->{default}
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            unless $self->{data}->{$key};
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain(">>Checking if '$key' is mandatory: ");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        unless ($self->{schema}->{$key}->{optional}
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                   and $self->{schema}->{$key}->{optional}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain("true\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            next if $self->{data}->{$key};
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            # regex-keys never directly occur.
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$key}->{regex}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain(">>regex enabled key found. ");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("Checking data keys.. ");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                for my $c_key (keys %{$self->{data}}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("$c matching occurencies found\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            next if $self->{schema}->{$key}->{array};
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $error_msg = $self->{schema}->{$key}->{error_msg}
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                if $self->{schema}->{$key}->{error_msg};
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->error("mandatory key '$key' missing. Error msg: '$error_msg'");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain("false\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    if ($self->{schema}->{$key}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain(" ok\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        for my $match_key (keys %{$self->{schema}}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            next unless exists $self->{schema}->{$match_key}
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                           and $self->{schema}->{$match_key}->{regex};
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("'$key' matches $match_key\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain(">>$key not in schema, keys available: ");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain(join (", ", (keys %{$self->{schema}})));
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain("\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->error("key '$key' not found in schema\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:# 'validator' specified gets this called to call the callback :-)
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    return unless $self->{schema}->{$schema_key}->{validator};
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    $self->explain("running validator for '$key': $self->{data}->{$key}\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    if (ref $self->{data}->{$key} eq ref []
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        && $self->{schema}->{$key}->{array}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        for my $elem (@{$self->{data}->{$key}}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            my $return_value = $self->{schema}->{$key}->{validator}->($elem, $self->{data});
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("validator error: $return_value (element $counter)\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->error("Execution of validator for '$key' element $counter returns with error: $return_value");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                $self->explain("successful validation for key '$key' element $counter\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        my $return_value = $self->{schema}->{$key}->{validator}->($self->{data}->{$key}, $self->{data});
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain("validator error: $return_value\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->error("Execution of validator for '$key' returns with error: $return_value");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain("successful validation for key '$key'\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:    if (exists  $self->{schema}->{$key}
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            and $self->{schema}->{$key}->{value}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        $self->explain('>>'.ref($self->{schema}->{$key}->{value})."\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        if (ref($self->{schema}->{$key}->{value}) eq 'CODE'){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:        elsif (ref($self->{schema}->{$key}->{value}) eq 'Regexp'){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            if (ref $self->{data}->{$key} eq ref []
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                && $self->{schema}->{$key}->{array}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                for my $elem (@{$self->{data}->{$key}}){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    $self->explain(">>match '$elem' against '$self->{schema}->{$key}->{value}'");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    if ($elem =~ m/^$self->{schema}->{$key}->{value}$/){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                        $self->explain(" ok.\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                        $self->explain(" no.\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                        $self->error("$elem does not match ^$self->{schema}->{$key}->{value}\$");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:               $self->explain(">>match '$self->{data}->{$key}' against '$self->{schema}->{$key}->{value}'");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                if ($self->{data}->{$key} =~ m/^$self->{schema}->{$key}->{value}$/){
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    $self->explain(" ok.\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    $self->explain(" no.\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:                    $self->error("$self->{data}->{$key} does not match ^$self->{schema}->{$key}->{value}\$");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->explain("neither CODE nor Regexp\n");
./Data-Processor-0.1.6/lib/Data/Processor/Validator.pm:            $self->error("'$key' not CODE nor Regexp");
./Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm:Data::Processor::ValidatorFactory - create validators for use in schemas
./Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm: my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->file('>','writing'),
./Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->rx(qr{[A-Z]+},'expected name made up from capital letters')
./Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->any(qw(UP DOWN))
./Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm: $vf->file('<','reading');
./Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm: $vf->file('>>','appending to');
./Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm: $vf->dir();
./Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm:        return undef if -d $value;
./Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm: $vf->rx(qr{[A-Z]+},'use uppercase letters')
./Data-Processor-0.1.6/lib/Data/Processor/ValidatorFactory.pm: $vf->any(qw(ON OFF))
./Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:    if (exists $section->{schema}->{$key}
./Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:        and exists $section->{schema}->{$key}->{transformer}){
./Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:                $section->{schema}->{$key}->{transformer}
./Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:                ->($section->{data}->{$key},$section->{data});
./Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:            if (ref $err eq 'HASH' and $err->{msg}){
./Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:                $err = $err->{msg};
./Data-Processor-0.1.6/lib/Data/Processor/Transformer.pm:            $section->{data}->{$key} = $return_value;
./Data-Processor-0.1.6/lib/Data/Processor/Error/Instance.pm:        $self->{$_} // die "$_ missing";
./Data-Processor-0.1.6/lib/Data/Processor/Error/Instance.pm:    $self->{path_array} = $self->{path};
./Data-Processor-0.1.6/lib/Data/Processor/Error/Instance.pm:    $self->{path} = join '->', @{$self->{path}};
./Data-Processor-0.1.6/lib/Data/Processor/Error/Instance.pm:    $self->{caller} = "$sub line $line";
./Data-Processor-0.1.6/lib/Data/Processor/Error/Instance.pm:    return $self->{path}. ": " . $self->{message};
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:Data::Processor::Error::Collection - Collect errors for Data::Processor
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    my $errors = Data::Processor::Error::Collection->new();
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:- message
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:- path
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    my $error = Data::Processor::Error::Instance->new(%p);
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $error;
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $e;
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    my @e = $other->as_array();
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:        $self->add_error($_);
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:  $error->collection->any_error_contains(
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    for my $error (@{$self->{errors}}){
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:        return 1 if $error->{$p{field}} =~ /$p{string}/;
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    return @{$self->{errors}};
./Data-Processor-0.1.6/lib/Data/Processor/Error/Collection.pm:    return scalar @{$self->{errors}};
./Data-Processor-0.1.6/lib/Data/Processor.pm:Data::Processor - Transform Perl Data Structures, Validate Data against a Schema, Produce Data from a Schema, or produce documentation directly from information in the Data
./Data-Processor-0.1.6/lib/Data/Processor.pm: my $processor = Data::Processor->new($schema);
./Data-Processor-0.1.6/lib/Data/Processor.pm:- indent: count of spaces to insert when printing in verbose mode. Default 4
./Data-Processor-0.1.6/lib/Data/Processor.pm:- depth: level at which to start. Default is 0.
./Data-Processor-0.1.6/lib/Data/Processor.pm:- verbose: Set to a true value to print messages during processing.
./Data-Processor-0.1.6/lib/Data/Processor.pm:        errors      => Data::Processor::Error::Collection->new(),
./Data-Processor-0.1.6/lib/Data/Processor.pm: my @errors = $processor->validate($data, verbose=>0);
./Data-Processor-0.1.6/lib/Data/Processor.pm:    $self->{validator}=Data::Processor::Validator->new(
./Data-Processor-0.1.6/lib/Data/Processor.pm:        schema      => $self->{schema} // $p{schema},
./Data-Processor-0.1.6/lib/Data/Processor.pm:        verbose     => $p{verbose} // $self->{verbose} // undef,
./Data-Processor-0.1.6/lib/Data/Processor.pm:        errors      => $self->{errors},
./Data-Processor-0.1.6/lib/Data/Processor.pm:        depth       => $self->{depth},
./Data-Processor-0.1.6/lib/Data/Processor.pm:        indent      => $self->{indent},
./Data-Processor-0.1.6/lib/Data/Processor.pm:        parent_keys => $self->{parent_keys},
./Data-Processor-0.1.6/lib/Data/Processor.pm:    return $self->{validator}->validate();
./Data-Processor-0.1.6/lib/Data/Processor.pm: my ($data_transformed, @errors) = $processor->transform_data(data=>$data);
./Data-Processor-0.1.6/lib/Data/Processor.pm: my ($schema_transformed, @errors) = $processor->transform_schema(schema=>$schema);
./Data-Processor-0.1.6/lib/Data/Processor.pm: my ($data, @errors) = $processor->make_data(data=>$data);
./Data-Processor-0.1.6/lib/Data/Processor.pm: my ($pod, @errors) = $processor->make_pod(data=>$data);
./Data-Processor-0.1.6/lib/Data/Processor.pm:Copyright 2015- Matthias Bloch
Übereinstimmungen in Binärdatei ./Data-Processor-0.1.4.tar.gz.
./t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(verbose => 1);
./t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}, 'section "GENERAL" exists');
./t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}->{logfile}, '"logfile" exists');
./t/100_make_config_template.t:#~ ok ($config_template->{GENERAL}->{logfile} = 'absolute path to logfile (?-xism:/.*)', 'logifle has correct content');
./t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(entry_point => $schema->{GENERAL}->{members}->{silos});
./t/100_make_config_template.t:#~ ok (exists $config_template->{'silo-.+'}, 'entry point "silos" found');
./t/100_make_config_template.t:#~ ok ($config_template->{'silo-.+'}->{url} eq 'url of the silo server. Only https:// allowed(?^:https.*)',
./t/007_no_value_check.t:my $p = Data::Processor->new($schema);
./t/007_no_value_check.t:my $error_collection = $p->validate($data, verbose=>0);
./t/007_no_value_check.t:ok ($error_collection->count==0, 'no errors');
./t/007_no_value_check.t:$error_collection = $p->validate($data, verbose=>0);
./t/007_no_value_check.t:ok ($error_collection->count==0, 'still no errors');
./t/010_transformer.t:                return ($1 * $timespecfactor->{($2 || 's')});
./t/010_transformer.t:        transformer => $transformer->{timespec}(
./t/010_transformer.t:my $validator = Data::Processor->new($schema);
./t/010_transformer.t:my $error_collection = $validator->validate($data, verbose=>0);
./t/010_transformer.t:ok ($data->{history} == 3600, 'transformed "1h" into "3600"');
./t/010_transformer.t:    history => 'regards, your error :-)',
./t/010_transformer.t:$error_collection = $validator->validate($data);
./t/010_transformer.t:ok ($data->{history} eq 'regards, your error :-)',
./t/010_transformer.t:    'Could not transform "regards, your error :-)"');
./t/010_transformer.t:ok ($error_collection->{errors}[0]->{message}
./t/011_default_values.t:my $p = Data::Processor->new($schema);
./t/011_default_values.t:my $error_collection = $p->validate($data, verbose=>0);
./t/011_default_values.t:ok ($data->{key_with_default_value}==42,
./t/016_schemaschema.t:eval { Data::Processor->new($schema);};
./t/005_synopsis.t:                    # undef is "no-error" -> success.
./t/005_synopsis.t:                        if $self->{value} == 42;
./t/005_synopsis.t:my $p = Data::Processor->new($schema);
./t/005_synopsis.t:my $error_collection = $p->validate($data, verbose=>0);
./t/005_synopsis.t:# no errors :-)
./t/005_synopsis.t:ok ($error_collection->count==0, 'no errors');
./t/013_array.t:my $p = Data::Processor->new($schema);
./t/013_array.t:my $error_collection = $p->validate($data, verbose=>0);
./t/013_array.t:ok ($error_collection->count == 9, '9 errors detected');
./t/013_array.t:ok ($error_collection->any_error_contains(
./t/013_array.t:ok ($error_collection->any_error_contains(
./t/015_rx_validator.t:my $p = Data::Processor->new($schema);
./t/015_rx_validator.t:like ( [$p->validate($data)->as_array]->[0]->{message}, qr'BAD', 'got an error as expected');
./t/015_rx_validator.t:like ( [$p->validate($data)->as_array]->[1]->{message}, qr'BAD', 'got an error as expected');
Übereinstimmungen in Binärdatei ./t/.001_basic.t.swp.
./t/200_pod_writer.t:my $p = Data::Processor->new($schema);
./t/200_pod_writer.t:my $pod = $p->pod_write();
./t/008_error_stringify.t:my $validator = Data::Processor->new($schema);
./t/008_error_stringify.t:my $error_collection = $validator->validate($data, verbose=>0);
./t/008_error_stringify.t:ok ($error_collection->count==1, '1 error');
./t/008_error_stringify.t:my $msg = $error_collection->{errors}[0]->stringify();
./t/300_make_config_template.t:                # "members" stands for all "non-internal" fields
./t/300_make_config_template.t:                    'silo-.+' => {
./t/300_make_config_template.t:                                example     => 'https://silo-a/api',
./t/300_make_config_template.t:my $p = Data::Processor->new($schema);
./t/300_make_config_template.t:my $data_template = $p->make_data();
./t/300_make_config_template.t:ok (exists $data_template->{GENERAL}, 'section "GENERAL" exists');
./t/300_make_config_template.t:ok (exists $data_template->{GENERAL}->{logfile}, '"logfile" exists');
./t/300_make_config_template.t:ok ($data_template->{GENERAL}->{logfile} = 'absolute path to logfile (?-xism:/.*)', 'logifle has correct content');
./t/300_make_config_template.t:my $data_template = $p->make_data($schema->{GENERAL}->{members}->{silos});
./t/300_make_config_template.t:ok (exists $data_template->{'silo-.+'}, 'entry point "silos" found');
./t/300_make_config_template.t:ok ($data_template->{'silo-.+'}->{url} eq 'url of the silo server. Only https:// allowed(?^:https.*)',
Übereinstimmungen in Binärdatei ./t/.005_synopsis.t.swp.
Übereinstimmungen in Binärdatei ./t/.200_pod_writer.t.swp.
Übereinstimmungen in Binärdatei ./t/.300_make_config_template.t.swp.
./t/012_factory.t:my $vf = Data::Processor::ValidatorFactory->new;
./t/012_factory.t:like ($vf->file('<','oops')->('/tmp/xkddf'),qr/oops/, 'error message generated');
./t/012_factory.t:is ($vf->rx(qr{XX},'oops')->('xxXXx'),undef,'regular expression check');
./t/012_factory.t:is ($vf->any(qw(OFF ON))->('OFF'),undef, 'is it one of the list');
./t/012_factory.t:is ($vf->dir()->('/'),undef, 'directory exists');
./t/002_validate.t:my $processor = Data::Processor->new($schema);
./t/002_validate.t:eval{$processor->validate()};
./t/002_validate.t:my $error_collection = $processor->validate($data);
./t/002_validate.t:my @errors = $error_collection->as_array();
./t/002_validate.t:ok ($error_collection->count()==2, 'error count =2');
./t/002_validate.t:ok ($error_collection->any_error_contains(
./t/002_validate.t:ok ($error_collection->any_error_contains(
./t/002_validate.t:ok ($error_collection->any_error_contains(
./t/002_validate.t:        string => "silo-a",
./t/002_validate.t:    "missing value from 'silo-a'"
./t/002_validate.t:ok ($error_collection->any_error_contains(
./t/002_validate.t:        logfile => '/tmp/n3k-poller.log',
./t/002_validate.t:        cachedb => '/tmp/n3k-cache.db',
./t/002_validate.t:            'silo-a' => {
./t/002_validate.t:                url => 'https://silo-a/api',
./t/002_validate.t:                key => 'my-secret-shared-key',
./t/002_validate.t:$error_collection = $processor->validate($data);
./t/002_validate.t:ok ($error_collection->count==0, 'no more errors with corrected config');
./t/002_validate.t:$error_collection = $processor->validate($data);
./t/002_validate.t:ok ($error_collection->count==2, '2 errors');
./t/002_validate.t:ok ($error_collection->any_error_contains(
./t/002_validate.t:            logfile => '/tmp/n3k-poller.log',
./t/002_validate.t:            cachedb => '/tmp/n3k-cache.db',
./t/002_validate.t:                'silo-a' => {
./t/002_validate.t:                    url => 'https://silo-a/api',
./t/002_validate.t:                    key => 'my-secret-shared-key',
./t/002_validate.t:                    # "members" stands for all "non-internal" fields
./t/002_validate.t:                        'silo-.+' => {
./t/002_validate.t:                                    example     => 'https://silo-a/api',
./t/001_basic.t:my $processor = Data::Processor->new();
./t/006_regex_keys.t:my $p = Data::Processor->new($schema);
./t/006_regex_keys.t:my $error_collection = $p->validate($data, verbose=>0);
./t/006_regex_keys.t:ok ($error_collection->count==3, '3 errors detected');
./t/006_regex_keys.t:ok ($error_collection->any_error_contains(
./t/014_transformer_direct.t:my $v = Data::Processor::Validator->new($schema, data=>$data);
./t/014_transformer_direct.t:my $p = Data::Processor->new($schema);
./t/014_transformer_direct.t:my $error_collection = $p->transform_data('transform_here', $v);
./t/014_transformer_direct.t:ok ($data->{transform_here}==42, 'transformed into 42');
Übereinstimmungen in Binärdatei ./t/.002_validate.t.swp.
./Data-Processor-0.2.0/META.json:   "meta-spec" : {
./Data-Processor-0.2.0/META.json:   "name" : "Data-Processor",
./Data-Processor-0.2.0/META.json:         "web" : "https://github.com/maettu/Data-Processor/issues"
./Data-Processor-0.2.0/META.json:      "homepage" : "https://github.com/maettu/Data-Processor",
./Data-Processor-0.2.0/META.json:         "url" : "https://github.com/maettu/Data-Processor.git",
./Data-Processor-0.2.0/META.json:         "web" : "https://github.com/maettu/Data-Processor"
./Data-Processor-0.2.0/Changes:Revision history for Data-Processor
./Data-Processor-0.2.0/Changes:0.2.0  2015-01-24 22:12:26 CET
./Data-Processor-0.2.0/Changes:    - Pod writer
./Data-Processor-0.2.0/Changes:    - schema validator
./Data-Processor-0.2.0/Changes:0.1.7  2015-01-23 20:31:53 CET
./Data-Processor-0.2.0/Changes:    - Transformer, basic (not very useful yet)
./Data-Processor-0.2.0/Changes:0.1.6  2015-01-23 16:50:55 CET
./Data-Processor-0.2.0/Changes:    - no more "require"
./Data-Processor-0.2.0/Changes:    - code cleanup
./Data-Processor-0.2.0/Changes:0.1.5  2015-01-22 16:50:24 CET
./Data-Processor-0.2.0/Changes:    - Interface change: use positional parameters for $schema, $data
./Data-Processor-0.2.0/Changes:0.1.4  2015-01-22 16:22:30 CET
./Data-Processor-0.2.0/Changes:    - array support as of t/013_array.t 
./Data-Processor-0.2.0/Changes:    - Transformer object
./Data-Processor-0.2.0/Changes:    - Error::Instance handles more
./Data-Processor-0.2.0/Changes:0.1.3  2015-01-20 09:43:14 CET
./Data-Processor-0.2.0/Changes:    - not-ready and interface change warning added
./Data-Processor-0.2.0/Changes:0.1.2  2015-01-19 11:15:29 CET
./Data-Processor-0.2.0/Changes:    - Makefile.PL instead of Build.PL
./Data-Processor-0.2.0/Changes:0.1.1  2015-01-18 21:48:47 CET
./Data-Processor-0.2.0/Changes:    - more test (mostly ported from old module)
./Data-Processor-0.2.0/Changes:    - ValidatorFactory
./Data-Processor-0.2.0/Changes:0.1.0  2015-01-18 16:50:50 CET
./Data-Processor-0.2.0/Changes:    - Error Collector added
./Data-Processor-0.2.0/Changes:    - Basic functionality: validation without frills
./Data-Processor-0.2.0/Changes:0.0.3  2015-01-15 21:37:19 CET
./Data-Processor-0.2.0/Changes:0.0.2  2015-01-15 21:31:16 CET
./Data-Processor-0.2.0/Changes:    - Code Layout
./Data-Processor-0.2.0/Changes:0.0.1  2015-01-15 19:09:03 CET
./Data-Processor-0.2.0/Changes:        - Initial release
./Data-Processor-0.2.0/META.yml:---
./Data-Processor-0.2.0/META.yml:  - 'Matthias Bloch <matthias.bloch@puffin.ch>'
./Data-Processor-0.2.0/META.yml:meta-spec:
./Data-Processor-0.2.0/META.yml:  url: http://module-build.sourceforge.net/META-spec-v1.4.html
./Data-Processor-0.2.0/META.yml:name: Data-Processor
./Data-Processor-0.2.0/META.yml:    - t
./Data-Processor-0.2.0/META.yml:    - xt
./Data-Processor-0.2.0/META.yml:    - inc
./Data-Processor-0.2.0/META.yml:    - share
./Data-Processor-0.2.0/META.yml:    - eg
./Data-Processor-0.2.0/META.yml:    - examples
./Data-Processor-0.2.0/META.yml:  bugtracker: https://github.com/maettu/Data-Processor/issues
./Data-Processor-0.2.0/META.yml:  homepage: https://github.com/maettu/Data-Processor
./Data-Processor-0.2.0/META.yml:  repository: https://github.com/maettu/Data-Processor.git
./Data-Processor-0.2.0/META.yml:  - 'Dominik Hassler <hadfl@cpan.org>'
./Data-Processor-0.2.0/META.yml:  - 'Tobias Oetiker <tobi@oetiker.ch>'
./Data-Processor-0.2.0/META.yml:  - 'maettu <matthias.bloch@puffin.ch>'
./Data-Processor-0.2.0/MANIFEST:t/release-pod-syntax.t
./Data-Processor-0.2.0/Build.PL:# This Build.PL for Data-Processor was generated by Dist::Zilla::Plugin::ModuleBuildTiny 0.008.
./Data-Processor-0.2.0/Makefile.PL:      license     => 'http://www.opensource.org/licenses/artistic-license-2.0',
./Data-Processor-0.2.0/Makefile.PL:      repository  => 'https://github.com/maettu/Data-Structure-Validation',
./Data-Processor-0.2.0/Makefile.PL:      bugtracker  => 'https://github.com/maettu/Data-Structure-Validation/issues'
./Data-Processor-0.2.0/LICENSE:This software is copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.2.0/LICENSE:--- The GNU General Public License, Version 1, February 1989 ---
./Data-Processor-0.2.0/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.2.0/LICENSE: 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
./Data-Processor-0.2.0/LICENSE:software--to make sure the software is free for all its users.  The
./Data-Processor-0.2.0/LICENSE:    a) accompany it with the complete corresponding machine-readable
./Data-Processor-0.2.0/LICENSE:    for the cost of distribution) a complete machine-readable copy of the
./Data-Processor-0.2.0/LICENSE:    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA  02110-1301 USA
./Data-Processor-0.2.0/LICENSE:c'; they could even be mouse-clicks or menu items--whatever suits your
./Data-Processor-0.2.0/LICENSE:--- The Artistic License 1.0 ---
./Data-Processor-0.2.0/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.2.0/LICENSE:the package the right to use and distribute the Package in a more-or-less
./Data-Processor-0.2.0/LICENSE:  - "Package" refers to the collection of files distributed by the Copyright
./Data-Processor-0.2.0/LICENSE:  - "Standard Version" refers to such a Package if it has not been modified,
./Data-Processor-0.2.0/LICENSE:  - "Copyright Holder" is whoever is named in the copyright or copyrights for
./Data-Processor-0.2.0/LICENSE:  - "You" is you, if you're thinking about copying or distributing this Package.
./Data-Processor-0.2.0/LICENSE:  - "Reasonable copying fee" is whatever you can justify on the basis of media
./Data-Processor-0.2.0/LICENSE:  - "Freely Available" means that no fee is charged for the item itself, though
./Data-Processor-0.2.0/LICENSE:  c) rename any non-standard executables so the names do not conflict with
./Data-Processor-0.2.0/LICENSE:     manual page for each non-standard executable that clearly documents how it
./Data-Processor-0.2.0/LICENSE:  b) accompany the distribution with the machine-readable source of the Package
./Data-Processor-0.2.0/LICENSE:  c) accompany any non-standard executables with their corresponding Standard
./Data-Processor-0.2.0/LICENSE:     Version executables, giving the non-standard executables non-standard
./Data-Processor-0.2.0/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(verbose => 1);
./Data-Processor-0.2.0/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}, 'section "GENERAL" exists');
./Data-Processor-0.2.0/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}->{logfile}, '"logfile" exists');
./Data-Processor-0.2.0/t/100_make_config_template.t:#~ ok ($config_template->{GENERAL}->{logfile} = 'absolute path to logfile (?-xism:/.*)', 'logifle has correct content');
./Data-Processor-0.2.0/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(entry_point => $schema->{GENERAL}->{members}->{silos});
./Data-Processor-0.2.0/t/100_make_config_template.t:#~ ok (exists $config_template->{'silo-.+'}, 'entry point "silos" found');
./Data-Processor-0.2.0/t/100_make_config_template.t:#~ ok ($config_template->{'silo-.+'}->{url} eq 'url of the silo server. Only https:// allowed(?^:https.*)',
./Data-Processor-0.2.0/t/007_no_value_check.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.2.0/t/007_no_value_check.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.2.0/t/007_no_value_check.t:ok ($error_collection->count==0, 'no errors');
./Data-Processor-0.2.0/t/007_no_value_check.t:$error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.2.0/t/007_no_value_check.t:ok ($error_collection->count==0, 'still no errors');
./Data-Processor-0.2.0/t/010_transformer.t:                return ($1 * $timespecfactor->{($2 || 's')});
./Data-Processor-0.2.0/t/010_transformer.t:        transformer => $transformer->{timespec}(
./Data-Processor-0.2.0/t/010_transformer.t:my $validator = Data::Processor->new($schema);
./Data-Processor-0.2.0/t/010_transformer.t:my $error_collection = $validator->validate($data, verbose=>0);
./Data-Processor-0.2.0/t/010_transformer.t:ok ($data->{history} == 3600, 'transformed "1h" into "3600"');
./Data-Processor-0.2.0/t/010_transformer.t:    history => 'regards, your error :-)',
./Data-Processor-0.2.0/t/010_transformer.t:$error_collection = $validator->validate($data);
./Data-Processor-0.2.0/t/010_transformer.t:ok ($data->{history} eq 'regards, your error :-)',
./Data-Processor-0.2.0/t/010_transformer.t:    'Could not transform "regards, your error :-)"');
./Data-Processor-0.2.0/t/010_transformer.t:ok ($error_collection->{errors}[0]->{message}
./Data-Processor-0.2.0/t/011_default_values.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.2.0/t/011_default_values.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.2.0/t/011_default_values.t:ok ($data->{key_with_default_value}==42,
./Data-Processor-0.2.0/t/016_schemaschema.t:eval { Data::Processor->new($schema);};
./Data-Processor-0.2.0/t/005_synopsis.t:                    # undef is "no-error" -> success.
./Data-Processor-0.2.0/t/005_synopsis.t:                        if $self->{value} == 42;
./Data-Processor-0.2.0/t/005_synopsis.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.2.0/t/005_synopsis.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.2.0/t/005_synopsis.t:# no errors :-)
./Data-Processor-0.2.0/t/005_synopsis.t:ok ($error_collection->count==0, 'no errors');
./Data-Processor-0.2.0/t/013_array.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.2.0/t/013_array.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.2.0/t/013_array.t:ok ($error_collection->count == 9, '9 errors detected');
./Data-Processor-0.2.0/t/013_array.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.2.0/t/013_array.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.2.0/t/015_rx_validator.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.2.0/t/015_rx_validator.t:like ( [$p->validate($data)->as_array]->[0]->{message}, qr'BAD', 'got an error as expected');
./Data-Processor-0.2.0/t/015_rx_validator.t:like ( [$p->validate($data)->as_array]->[1]->{message}, qr'BAD', 'got an error as expected');
./Data-Processor-0.2.0/t/200_pod_writer.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.2.0/t/200_pod_writer.t:my $pod = $p->pod_write();
./Data-Processor-0.2.0/t/008_error_stringify.t:my $validator = Data::Processor->new($schema);
./Data-Processor-0.2.0/t/008_error_stringify.t:my $error_collection = $validator->validate($data, verbose=>0);
./Data-Processor-0.2.0/t/008_error_stringify.t:ok ($error_collection->count==1, '1 error');
./Data-Processor-0.2.0/t/008_error_stringify.t:my $msg = $error_collection->{errors}[0]->stringify();
./Data-Processor-0.2.0/t/012_factory.t:my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.2.0/t/012_factory.t:like ($vf->file('<','oops')->('/tmp/xkddf'),qr/oops/, 'error message generated');
./Data-Processor-0.2.0/t/012_factory.t:is ($vf->rx(qr{XX},'oops')->('xxXXx'),undef,'regular expression check');
./Data-Processor-0.2.0/t/012_factory.t:is ($vf->any(qw(OFF ON))->('OFF'),undef, 'is it one of the list');
./Data-Processor-0.2.0/t/012_factory.t:is ($vf->dir()->('/'),undef, 'directory exists');
./Data-Processor-0.2.0/t/002_validate.t:my $processor = Data::Processor->new($schema);
./Data-Processor-0.2.0/t/002_validate.t:eval{$processor->validate()};
./Data-Processor-0.2.0/t/002_validate.t:my $error_collection = $processor->validate($data);
./Data-Processor-0.2.0/t/002_validate.t:my @errors = $error_collection->as_array();
./Data-Processor-0.2.0/t/002_validate.t:ok ($error_collection->count()==2, 'error count =2');
./Data-Processor-0.2.0/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.2.0/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.2.0/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.2.0/t/002_validate.t:        string => "silo-a",
./Data-Processor-0.2.0/t/002_validate.t:    "missing value from 'silo-a'"
./Data-Processor-0.2.0/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.2.0/t/002_validate.t:        logfile => '/tmp/n3k-poller.log',
./Data-Processor-0.2.0/t/002_validate.t:        cachedb => '/tmp/n3k-cache.db',
./Data-Processor-0.2.0/t/002_validate.t:            'silo-a' => {
./Data-Processor-0.2.0/t/002_validate.t:                url => 'https://silo-a/api',
./Data-Processor-0.2.0/t/002_validate.t:                key => 'my-secret-shared-key',
./Data-Processor-0.2.0/t/002_validate.t:$error_collection = $processor->validate($data);
./Data-Processor-0.2.0/t/002_validate.t:ok ($error_collection->count==0, 'no more errors with corrected config');
./Data-Processor-0.2.0/t/002_validate.t:$error_collection = $processor->validate($data);
./Data-Processor-0.2.0/t/002_validate.t:ok ($error_collection->count==2, '2 errors');
./Data-Processor-0.2.0/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.2.0/t/002_validate.t:            logfile => '/tmp/n3k-poller.log',
./Data-Processor-0.2.0/t/002_validate.t:            cachedb => '/tmp/n3k-cache.db',
./Data-Processor-0.2.0/t/002_validate.t:                'silo-a' => {
./Data-Processor-0.2.0/t/002_validate.t:                    url => 'https://silo-a/api',
./Data-Processor-0.2.0/t/002_validate.t:                    key => 'my-secret-shared-key',
./Data-Processor-0.2.0/t/002_validate.t:                    # "members" stands for all "non-internal" fields
./Data-Processor-0.2.0/t/002_validate.t:                        'silo-.+' => {
./Data-Processor-0.2.0/t/002_validate.t:                                    example     => 'https://silo-a/api',
./Data-Processor-0.2.0/t/001_basic.t:my $processor = Data::Processor->new();
./Data-Processor-0.2.0/t/006_regex_keys.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.2.0/t/006_regex_keys.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.2.0/t/006_regex_keys.t:ok ($error_collection->count==3, '3 errors detected');
./Data-Processor-0.2.0/t/006_regex_keys.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.2.0/t/014_transformer_direct.t:my $v = Data::Processor::Validator->new($schema, data=>$data);
./Data-Processor-0.2.0/t/014_transformer_direct.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.2.0/t/014_transformer_direct.t:my $error_collection = $p->transform_data('transform_here', $v);
./Data-Processor-0.2.0/t/014_transformer_direct.t:ok ($data->{transform_here}==42, 'transformed into 42');
./Data-Processor-0.2.0/lib/Data/Processor/PodWriter.pm:            if $schema->{$key}->{optional};
./Data-Processor-0.2.0/lib/Data/Processor/PodWriter.pm:        $pod_string .= ": $schema->{$key}->{description}"
./Data-Processor-0.2.0/lib/Data/Processor/PodWriter.pm:            if $schema->{$key}->{description};
./Data-Processor-0.2.0/lib/Data/Processor/PodWriter.pm:        $pod_string .= "\n\nDefault value: $schema->{$key}->{default}"
./Data-Processor-0.2.0/lib/Data/Processor/PodWriter.pm:            if $schema->{$key}->{default};
./Data-Processor-0.2.0/lib/Data/Processor/PodWriter.pm:        if ($schema->{$key}->{members}){
./Data-Processor-0.2.0/lib/Data/Processor/PodWriter.pm:            $pod_string .= pod_write($schema->{$key}->{members}, '');
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:# Data::Processor::Validator - Validate Data Against a Schema
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        errors => $p{errors}  // Data::Processor::Error::Collection->new(),
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        transformer => Data::Processor::Transformer->new(),
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    $self->{data} = shift;
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    croak ('cannot validate without "data"') unless $self->{data};
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    $self->{errors} = Data::Processor::Error::Collection->new();
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    $self->_add_defaults();
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{data}}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->explain (">>'$key'");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        my $schema_key = $self->_schema_twin_key($key) or next;
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->__value_is_valid( $key );
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->__validator_returns_undef($key, $schema_key);
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        my $e = $self->{transformer}->transform($key, $self);
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->error($e) if $e;
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        if ($self->{schema}->{$schema_key}->{no_descend_into}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        if (! %{$self->{schema}->{$schema_key}}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->explain (">>skipping '$key' because schema key is empty\n'");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        if (! $self->{schema}->{$schema_key}->{members}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->explain (">>descending into '$key'\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        if (ref $self->{data}->{$key} eq ref {} ){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->explain
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            my $e = Data::Processor::Validator->new(
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                $self->{schema}->{$schema_key}->{members},
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                parent_keys => [@{$self->{parent_keys}}, $key],
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                depth       => $self->{depth}+1,
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                verbose     => $self->{verbose},
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            ) ->validate($self->{data}->{$key});
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->{errors}->add_collection($e);
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        elsif ((ref $self->{data}->{$key} eq ref [])
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            && $self->{schema}->{$schema_key}->{array}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->explain(
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            push @{$self->{parent_keys}}, $key;
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->{depth}++;
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            for my $member (@{$self->{data}->{$key}}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                my $e = Data::Processor::Validator->new(
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                    $self->{schema}->{$schema_key}->{members},
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                    parent_keys => [@{$self->{parent_keys}}, $key],
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                    depth       => $self->{depth}+1,
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                    verbose     => $self->{verbose},
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                ) ->validate($member);
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                $self->{errors}->add_collection($e);
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            pop @{$self->{parent_keys}};
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->{depth}--;
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        # We cannot descend into a non-existing branch in data
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->explain(">>checking data key '$key' which is a leaf..");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$schema_key}->{members}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                $self->explain("but schema requires members.\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                $self->error("'$key' should have members");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                $self->explain("schema key is also a leaf. ok.\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    # look for missing non-optional keys in schema
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    $self->_check_mandatory_keys();
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    return $self->{errors};
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    $self->{errors}->add(
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        path => $self->{parent_keys},
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    my $indent = ' ' x ($self->{depth}*$self->{indent});
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    print $string if $self->{verbose};
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        next unless $self->{schema}->{$key}->{default};
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->{data}->{$key} = $self->{schema}->{$key}->{default}
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            unless $self->{data}->{$key};
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->explain(">>Checking if '$key' is mandatory: ");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        unless ($self->{schema}->{$key}->{optional}
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                   and $self->{schema}->{$key}->{optional}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->explain("true\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            next if $self->{data}->{$key};
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            # regex-keys never directly occur.
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$key}->{regex}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                $self->explain(">>regex enabled key found. ");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                $self->explain("Checking data keys.. ");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                for my $c_key (keys %{$self->{data}}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                $self->explain("$c matching occurencies found\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $error_msg = $self->{schema}->{$key}->{error_msg}
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                if $self->{schema}->{$key}->{error_msg};
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->error("mandatory key '$key' missing. Error msg: '$error_msg'");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->explain("false\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    if ($self->{schema}->{$key}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->explain(" ok\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        for my $match_key (keys %{$self->{schema}}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            next unless exists $self->{schema}->{$match_key}
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                           and $self->{schema}->{$match_key}->{regex};
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                $self->explain("'$key' matches $match_key\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->explain(">>$key not in schema, keys available: ");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->explain(join (", ", (keys %{$self->{schema}})));
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->explain("\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->error("key '$key' not found in schema\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:# 'validator' specified gets this called to call the callback :-)
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    return unless $self->{schema}->{$schema_key}->{validator};
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    $self->explain("running validator for '$key': $self->{data}->{$key}\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    if (ref $self->{data}->{$key} eq ref []
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        && $self->{schema}->{$schema_key}->{array}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        for my $elem (@{$self->{data}->{$key}}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            my $return_value = $self->{schema}->{$schema_key}->{validator}->($elem, $self->{data});
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                $self->explain("validator error: $return_value (element $counter)\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                $self->error("Execution of validator for '$key' element $counter returns with error: $return_value");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                $self->explain("successful validation for key '$key' element $counter\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        my $return_value = $self->{schema}->{$schema_key}->{validator}->($self->{data}->{$key}, $self->{data});
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->explain("validator error: $return_value\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->error("Execution of validator for '$key' returns with error: $return_value");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->explain("successful validation for key '$key'\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:    if (exists  $self->{schema}->{$key}
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            and $self->{schema}->{$key}->{value}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        $self->explain('>>'.ref($self->{schema}->{$key}->{value})."\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        if (ref($self->{schema}->{$key}->{value}) eq 'CODE'){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:        elsif (ref($self->{schema}->{$key}->{value}) eq 'Regexp'){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            if (ref $self->{data}->{$key} eq ref []
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                && $self->{schema}->{$key}->{array}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                for my $elem (@{$self->{data}->{$key}}){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                    $self->explain(">>match '$elem' against '$self->{schema}->{$key}->{value}'");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                    if ($elem =~ m/^$self->{schema}->{$key}->{value}$/){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                        $self->explain(" ok.\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                        $self->explain(" no.\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                        $self->error("$elem does not match ^$self->{schema}->{$key}->{value}\$");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:               $self->explain(">>match '$self->{data}->{$key}' against '$self->{schema}->{$key}->{value}'");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                if ($self->{data}->{$key} =~ m/^$self->{schema}->{$key}->{value}$/){
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                    $self->explain(" ok.\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                    $self->explain(" no.\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:                    $self->error("$self->{data}->{$key} does not match ^$self->{schema}->{$key}->{value}\$");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->explain("neither CODE nor Regexp\n");
./Data-Processor-0.2.0/lib/Data/Processor/Validator.pm:            $self->error("'$key' not CODE nor Regexp");
./Data-Processor-0.2.0/lib/Data/Processor/ValidatorFactory.pm:Data::Processor::ValidatorFactory - create validators for use in schemas
./Data-Processor-0.2.0/lib/Data/Processor/ValidatorFactory.pm: my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.2.0/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->file('>','writing'),
./Data-Processor-0.2.0/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->rx(qr{[A-Z]+},'expected name made up from capital letters')
./Data-Processor-0.2.0/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->any(qw(UP DOWN))
./Data-Processor-0.2.0/lib/Data/Processor/ValidatorFactory.pm: $vf->file('<','reading');
./Data-Processor-0.2.0/lib/Data/Processor/ValidatorFactory.pm: $vf->file('>>','appending to');
./Data-Processor-0.2.0/lib/Data/Processor/ValidatorFactory.pm: $vf->dir();
./Data-Processor-0.2.0/lib/Data/Processor/ValidatorFactory.pm:        return undef if -d $value;
./Data-Processor-0.2.0/lib/Data/Processor/ValidatorFactory.pm: $vf->rx(qr{[A-Z]+},'use uppercase letters')
./Data-Processor-0.2.0/lib/Data/Processor/ValidatorFactory.pm: $vf->any(qw(ON OFF))
./Data-Processor-0.2.0/lib/Data/Processor/Transformer.pm:    if (exists $section->{schema}->{$key}
./Data-Processor-0.2.0/lib/Data/Processor/Transformer.pm:        and exists $section->{schema}->{$key}->{transformer}){
./Data-Processor-0.2.0/lib/Data/Processor/Transformer.pm:                $section->{schema}->{$key}->{transformer}
./Data-Processor-0.2.0/lib/Data/Processor/Transformer.pm:                ->($section->{data}->{$key},$section->{data});
./Data-Processor-0.2.0/lib/Data/Processor/Transformer.pm:            if (ref $err eq 'HASH' and $err->{msg}){
./Data-Processor-0.2.0/lib/Data/Processor/Transformer.pm:                $err = $err->{msg};
./Data-Processor-0.2.0/lib/Data/Processor/Transformer.pm:            $section->{data}->{$key} = $return_value;
./Data-Processor-0.2.0/lib/Data/Processor/Error/Instance.pm:        $self->{$_} // die "$_ missing";
./Data-Processor-0.2.0/lib/Data/Processor/Error/Instance.pm:    $self->{path_array} = $self->{path};
./Data-Processor-0.2.0/lib/Data/Processor/Error/Instance.pm:    $self->{path} = join '->', @{$self->{path}};
./Data-Processor-0.2.0/lib/Data/Processor/Error/Instance.pm:    $self->{caller} = "$sub line $line";
./Data-Processor-0.2.0/lib/Data/Processor/Error/Instance.pm:    return $self->{path}. ": " . $self->{message};
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:Data::Processor::Error::Collection - Collect errors for Data::Processor
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:    my $errors = Data::Processor::Error::Collection->new();
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:- message
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:- path
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:    my $error = Data::Processor::Error::Instance->new(%p);
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $error;
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $e;
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:    my @e = $other->as_array();
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:        $self->add_error($_);
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:  $error->collection->any_error_contains(
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:    for my $error (@{$self->{errors}}){
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:        return 1 if $error->{$p{field}} =~ /$p{string}/;
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:    return @{$self->{errors}};
./Data-Processor-0.2.0/lib/Data/Processor/Error/Collection.pm:    return scalar @{$self->{errors}};
./Data-Processor-0.2.0/lib/Data/Processor.pm:Data::Processor - Transform Perl Data Structures, Validate Data against a Schema, Produce Data from a Schema, or produce documentation directly from information in the Data
./Data-Processor-0.2.0/lib/Data/Processor.pm: my $processor = Data::Processor->new($schema);
./Data-Processor-0.2.0/lib/Data/Processor.pm:- indent: count of spaces to insert when printing in verbose mode. Default 4
./Data-Processor-0.2.0/lib/Data/Processor.pm:- depth: level at which to start. Default is 0.
./Data-Processor-0.2.0/lib/Data/Processor.pm:- verbose: Set to a true value to print messages during processing.
./Data-Processor-0.2.0/lib/Data/Processor.pm:        errors      => Data::Processor::Error::Collection->new(),
./Data-Processor-0.2.0/lib/Data/Processor.pm:    my $e = $self->validate_schema;
./Data-Processor-0.2.0/lib/Data/Processor.pm:    if ($e->count > 0){
./Data-Processor-0.2.0/lib/Data/Processor.pm:        croak "There is a problem with your schema:".join "\n", $e->as_array;
./Data-Processor-0.2.0/lib/Data/Processor.pm: my @errors = $processor->validate($data, verbose=>0);
./Data-Processor-0.2.0/lib/Data/Processor.pm:    $self->{validator}=Data::Processor::Validator->new(
./Data-Processor-0.2.0/lib/Data/Processor.pm:        $self->{schema} // $p{schema},
./Data-Processor-0.2.0/lib/Data/Processor.pm:        verbose     => $p{verbose} // $self->{verbose} // undef,
./Data-Processor-0.2.0/lib/Data/Processor.pm:        errors      => $self->{errors},
./Data-Processor-0.2.0/lib/Data/Processor.pm:        depth       => $self->{depth},
./Data-Processor-0.2.0/lib/Data/Processor.pm:        indent      => $self->{indent},
./Data-Processor-0.2.0/lib/Data/Processor.pm:        parent_keys => $self->{parent_keys},
./Data-Processor-0.2.0/lib/Data/Processor.pm:    return $self->{validator}->validate($data);
./Data-Processor-0.2.0/lib/Data/Processor.pm:    my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.2.0/lib/Data/Processor.pm:    my $bool = $vf->rx(qr(^[01]$),'Expected 0 or 1');
./Data-Processor-0.2.0/lib/Data/Processor.pm:                    validator => $vf->rx(qr(.+),'expected a description string'),
./Data-Processor-0.2.0/lib/Data/Processor.pm:                    validator => $vf->rx(qr(.+),'expected an example string'),
./Data-Processor-0.2.0/lib/Data/Processor.pm:                    validator => $vf->rx(qr(.+),'expected an error message string'),
./Data-Processor-0.2.0/lib/Data/Processor.pm:                        my $subVal=Data::Processor::Validator->new($schemaSchema,%$self);
./Data-Processor-0.2.0/lib/Data/Processor.pm:                        my $e = $subVal->validate($value);
./Data-Processor-0.2.0/lib/Data/Processor.pm:                        return ( $e->count > 0 ? join("\n", $e->as_array) : undef);
./Data-Processor-0.2.0/lib/Data/Processor.pm:    return Data::Processor::Validator->new($schemaSchema,%$self)->validate($self->{schema});
./Data-Processor-0.2.0/lib/Data/Processor.pm:Transforms the data in-place.
./Data-Processor-0.2.0/lib/Data/Processor.pm: my $validator = Data::Processor::Validator->new($schema, data => $data)
./Data-Processor-0.2.0/lib/Data/Processor.pm: my $error_string = $processor->transform($key, $validator);
./Data-Processor-0.2.0/lib/Data/Processor.pm:    return Data::Processor::Transformer->new()->transform($key, $val);
./Data-Processor-0.2.0/lib/Data/Processor.pm: my ($data, @errors) = $processor->make_data(data=>$data);
./Data-Processor-0.2.0/lib/Data/Processor.pm: my $pod_string = $processor->make_pod();
./Data-Processor-0.2.0/lib/Data/Processor.pm:        $self->{schema},
./Data-Processor-0.2.0/lib/Data/Processor.pm:Copyright 2015- Matthias Bloch
./lib/Data/Processor/PodWriter.pm:            if $schema->{$key}->{optional};
./lib/Data/Processor/PodWriter.pm:        $pod_string .= ": $schema->{$key}->{description}"
./lib/Data/Processor/PodWriter.pm:            if $schema->{$key}->{description};
./lib/Data/Processor/PodWriter.pm:        $pod_string .= "\n\nDefault value: $schema->{$key}->{default}"
./lib/Data/Processor/PodWriter.pm:            if $schema->{$key}->{default};
./lib/Data/Processor/PodWriter.pm:        if ($schema->{$key}->{members}){
./lib/Data/Processor/PodWriter.pm:            $pod_string .= pod_write($schema->{$key}->{members}, '');
./lib/Data/Processor/Validator.pm:# Data::Processor::Validator - Validate Data Against a Schema
./lib/Data/Processor/Validator.pm:        errors => $p{errors}  // Data::Processor::Error::Collection->new(),
./lib/Data/Processor/Validator.pm:        transformer => Data::Processor::Transformer->new(),
./lib/Data/Processor/Validator.pm:    $self->{data} = shift;
./lib/Data/Processor/Validator.pm:    croak ('cannot validate without "data"') unless $self->{data};
./lib/Data/Processor/Validator.pm:    $self->{errors} = Data::Processor::Error::Collection->new();
./lib/Data/Processor/Validator.pm:    $self->_add_defaults();
./lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{data}}){
./lib/Data/Processor/Validator.pm:        $self->explain (">>'$key'");
./lib/Data/Processor/Validator.pm:        my $schema_key = $self->_schema_twin_key($key) or next;
./lib/Data/Processor/Validator.pm:        $self->__value_is_valid( $key );
./lib/Data/Processor/Validator.pm:        $self->__validator_returns_undef($key, $schema_key);
./lib/Data/Processor/Validator.pm:        my $e = $self->{transformer}->transform($key, $self);
./lib/Data/Processor/Validator.pm:        $self->error($e) if $e;
./lib/Data/Processor/Validator.pm:        if ($self->{schema}->{$schema_key}->{no_descend_into}){
./lib/Data/Processor/Validator.pm:            $self->explain (
./lib/Data/Processor/Validator.pm:        if (! %{$self->{schema}->{$schema_key}}){
./lib/Data/Processor/Validator.pm:            $self->explain (">>skipping '$key' because schema key is empty\n'");
./lib/Data/Processor/Validator.pm:        if (! $self->{schema}->{$schema_key}->{members}){
./lib/Data/Processor/Validator.pm:            $self->explain (
./lib/Data/Processor/Validator.pm:        $self->explain (">>descending into '$key'\n");
./lib/Data/Processor/Validator.pm:        if (ref $self->{data}->{$key} eq ref {} ){
./lib/Data/Processor/Validator.pm:            $self->explain
./lib/Data/Processor/Validator.pm:            my $e = Data::Processor::Validator->new(
./lib/Data/Processor/Validator.pm:                $self->{schema}->{$schema_key}->{members},
./lib/Data/Processor/Validator.pm:                parent_keys => [@{$self->{parent_keys}}, $key],
./lib/Data/Processor/Validator.pm:                depth       => $self->{depth}+1,
./lib/Data/Processor/Validator.pm:                verbose     => $self->{verbose},
./lib/Data/Processor/Validator.pm:            ) ->validate($self->{data}->{$key});
./lib/Data/Processor/Validator.pm:            $self->{errors}->add_collection($e);
./lib/Data/Processor/Validator.pm:        elsif ((ref $self->{data}->{$key} eq ref [])
./lib/Data/Processor/Validator.pm:            && $self->{schema}->{$schema_key}->{array}){
./lib/Data/Processor/Validator.pm:            $self->explain(
./lib/Data/Processor/Validator.pm:            push @{$self->{parent_keys}}, $key;
./lib/Data/Processor/Validator.pm:            $self->{depth}++;
./lib/Data/Processor/Validator.pm:            for my $member (@{$self->{data}->{$key}}){
./lib/Data/Processor/Validator.pm:                my $e = Data::Processor::Validator->new(
./lib/Data/Processor/Validator.pm:                    $self->{schema}->{$schema_key}->{members},
./lib/Data/Processor/Validator.pm:                    parent_keys => [@{$self->{parent_keys}}, $key],
./lib/Data/Processor/Validator.pm:                    depth       => $self->{depth}+1,
./lib/Data/Processor/Validator.pm:                    verbose     => $self->{verbose},
./lib/Data/Processor/Validator.pm:                ) ->validate($member);
./lib/Data/Processor/Validator.pm:                $self->{errors}->add_collection($e);
./lib/Data/Processor/Validator.pm:            pop @{$self->{parent_keys}};
./lib/Data/Processor/Validator.pm:            $self->{depth}--;
./lib/Data/Processor/Validator.pm:        # We cannot descend into a non-existing branch in data
./lib/Data/Processor/Validator.pm:            $self->explain(">>checking data key '$key' which is a leaf..");
./lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$schema_key}->{members}){
./lib/Data/Processor/Validator.pm:                $self->explain("but schema requires members.\n");
./lib/Data/Processor/Validator.pm:                $self->error("'$key' should have members");
./lib/Data/Processor/Validator.pm:                $self->explain("schema key is also a leaf. ok.\n");
./lib/Data/Processor/Validator.pm:    # look for missing non-optional keys in schema
./lib/Data/Processor/Validator.pm:    $self->_check_mandatory_keys();
./lib/Data/Processor/Validator.pm:    return $self->{errors};
./lib/Data/Processor/Validator.pm:    $self->{errors}->add(
./lib/Data/Processor/Validator.pm:        path => $self->{parent_keys},
./lib/Data/Processor/Validator.pm:    my $indent = ' ' x ($self->{depth}*$self->{indent});
./lib/Data/Processor/Validator.pm:    print $string if $self->{verbose};
./lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./lib/Data/Processor/Validator.pm:        next unless $self->{schema}->{$key}->{default};
./lib/Data/Processor/Validator.pm:        $self->{data}->{$key} = $self->{schema}->{$key}->{default}
./lib/Data/Processor/Validator.pm:            unless $self->{data}->{$key};
./lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./lib/Data/Processor/Validator.pm:        $self->explain(">>Checking if '$key' is mandatory: ");
./lib/Data/Processor/Validator.pm:        unless ($self->{schema}->{$key}->{optional}
./lib/Data/Processor/Validator.pm:                   and $self->{schema}->{$key}->{optional}){
./lib/Data/Processor/Validator.pm:            $self->explain("true\n");
./lib/Data/Processor/Validator.pm:            next if $self->{data}->{$key};
./lib/Data/Processor/Validator.pm:            # regex-keys never directly occur.
./lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$key}->{regex}){
./lib/Data/Processor/Validator.pm:                $self->explain(">>regex enabled key found. ");
./lib/Data/Processor/Validator.pm:                $self->explain("Checking data keys.. ");
./lib/Data/Processor/Validator.pm:                for my $c_key (keys %{$self->{data}}){
./lib/Data/Processor/Validator.pm:                $self->explain("$c matching occurencies found\n");
./lib/Data/Processor/Validator.pm:            $error_msg = $self->{schema}->{$key}->{error_msg}
./lib/Data/Processor/Validator.pm:                if $self->{schema}->{$key}->{error_msg};
./lib/Data/Processor/Validator.pm:            $self->error("mandatory key '$key' missing. Error msg: '$error_msg'");
./lib/Data/Processor/Validator.pm:            $self->explain("false\n");
./lib/Data/Processor/Validator.pm:    if ($self->{schema}->{$key}){
./lib/Data/Processor/Validator.pm:        $self->explain(" ok\n");
./lib/Data/Processor/Validator.pm:        for my $match_key (keys %{$self->{schema}}){
./lib/Data/Processor/Validator.pm:            next unless exists $self->{schema}->{$match_key}
./lib/Data/Processor/Validator.pm:                           and $self->{schema}->{$match_key}->{regex};
./lib/Data/Processor/Validator.pm:                $self->explain("'$key' matches $match_key\n");
./lib/Data/Processor/Validator.pm:        $self->explain(">>$key not in schema, keys available: ");
./lib/Data/Processor/Validator.pm:        $self->explain(join (", ", (keys %{$self->{schema}})));
./lib/Data/Processor/Validator.pm:        $self->explain("\n");
./lib/Data/Processor/Validator.pm:        $self->error("key '$key' not found in schema\n");
./lib/Data/Processor/Validator.pm:# 'validator' specified gets this called to call the callback :-)
./lib/Data/Processor/Validator.pm:    return unless $self->{schema}->{$schema_key}->{validator};
./lib/Data/Processor/Validator.pm:    $self->explain("running validator for '$key': $self->{data}->{$key}\n");
./lib/Data/Processor/Validator.pm:    if (ref $self->{data}->{$key} eq ref []
./lib/Data/Processor/Validator.pm:        && $self->{schema}->{$schema_key}->{array}){
./lib/Data/Processor/Validator.pm:        for my $elem (@{$self->{data}->{$key}}){
./lib/Data/Processor/Validator.pm:            my $return_value = $self->{schema}->{$schema_key}->{validator}->($elem, $self->{data});
./lib/Data/Processor/Validator.pm:                $self->explain("validator error: $return_value (element $counter)\n");
./lib/Data/Processor/Validator.pm:                $self->error("Execution of validator for '$key' element $counter returns with error: $return_value");
./lib/Data/Processor/Validator.pm:                $self->explain("successful validation for key '$key' element $counter\n");
./lib/Data/Processor/Validator.pm:        my $return_value = $self->{schema}->{$schema_key}->{validator}->($self->{data}->{$key}, $self->{data});
./lib/Data/Processor/Validator.pm:            $self->explain("validator error: $return_value\n");
./lib/Data/Processor/Validator.pm:            $self->error("Execution of validator for '$key' returns with error: $return_value");
./lib/Data/Processor/Validator.pm:            $self->explain("successful validation for key '$key'\n");
./lib/Data/Processor/Validator.pm:    if (exists  $self->{schema}->{$key}
./lib/Data/Processor/Validator.pm:            and $self->{schema}->{$key}->{value}){
./lib/Data/Processor/Validator.pm:        $self->explain('>>'.ref($self->{schema}->{$key}->{value})."\n");
./lib/Data/Processor/Validator.pm:        if (ref($self->{schema}->{$key}->{value}) eq 'CODE'){
./lib/Data/Processor/Validator.pm:        elsif (ref($self->{schema}->{$key}->{value}) eq 'Regexp'){
./lib/Data/Processor/Validator.pm:            if (ref $self->{data}->{$key} eq ref []
./lib/Data/Processor/Validator.pm:                && $self->{schema}->{$key}->{array}){
./lib/Data/Processor/Validator.pm:                for my $elem (@{$self->{data}->{$key}}){
./lib/Data/Processor/Validator.pm:                    $self->explain(">>match '$elem' against '$self->{schema}->{$key}->{value}'");
./lib/Data/Processor/Validator.pm:                    if ($elem =~ m/^$self->{schema}->{$key}->{value}$/){
./lib/Data/Processor/Validator.pm:                        $self->explain(" ok.\n");
./lib/Data/Processor/Validator.pm:                        $self->explain(" no.\n");
./lib/Data/Processor/Validator.pm:                        $self->error("$elem does not match ^$self->{schema}->{$key}->{value}\$");
./lib/Data/Processor/Validator.pm:               $self->explain(">>match '$self->{data}->{$key}' against '$self->{schema}->{$key}->{value}'");
./lib/Data/Processor/Validator.pm:                if ($self->{data}->{$key} =~ m/^$self->{schema}->{$key}->{value}$/){
./lib/Data/Processor/Validator.pm:                    $self->explain(" ok.\n");
./lib/Data/Processor/Validator.pm:                    $self->explain(" no.\n");
./lib/Data/Processor/Validator.pm:                    $self->error("$self->{data}->{$key} does not match ^$self->{schema}->{$key}->{value}\$");
./lib/Data/Processor/Validator.pm:            $self->explain("neither CODE nor Regexp\n");
./lib/Data/Processor/Validator.pm:            $self->error("'$key' not CODE nor Regexp");
Übereinstimmungen in Binärdatei ./lib/Data/Processor/.Generator.pm.swp.
./lib/Data/Processor/Generator.pm:        if (ref $schema_section->{$key} eq ref {} ){
./lib/Data/Processor/Generator.pm:                    $schema_section->{$key},
./lib/Data/Processor/Generator.pm:                if (exists $schema_section->{$key}->{description}){
./lib/Data/Processor/Generator.pm:                    $data->{$key} = $schema_section->{$key}->{description}
./lib/Data/Processor/Generator.pm:                if (exists $schema_section->{$key}->{value}){
./lib/Data/Processor/Generator.pm:                    $data->{$key} .= $schema_section->{$key}->{value};
./lib/Data/Processor/Generator.pm:                # Inversely, if there is a value, it is an end-point.
./lib/Data/Processor/Generator.pm:                if (! exists  $schema_section->{$key}->{value}){
./lib/Data/Processor/Generator.pm:                    $data->{$key} = make_data_template(
./lib/Data/Processor/Generator.pm:                        $schema_section->{$key},
Übereinstimmungen in Binärdatei ./lib/Data/Processor/.PodWriter.pm.swp.
./lib/Data/Processor/ValidatorFactory.pm:Data::Processor::ValidatorFactory - create validators for use in schemas
./lib/Data/Processor/ValidatorFactory.pm: my $vf = Data::Processor::ValidatorFactory->new;
./lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->file('>','writing'),
./lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->rx(qr{[A-Z]+},'expected name made up from capital letters')
./lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->any(qw(UP DOWN))
./lib/Data/Processor/ValidatorFactory.pm: $vf->file('<','reading');
./lib/Data/Processor/ValidatorFactory.pm: $vf->file('>>','appending to');
./lib/Data/Processor/ValidatorFactory.pm: $vf->dir();
./lib/Data/Processor/ValidatorFactory.pm:        return undef if -d $value;
./lib/Data/Processor/ValidatorFactory.pm: $vf->rx(qr{[A-Z]+},'use uppercase letters')
./lib/Data/Processor/ValidatorFactory.pm: $vf->any(qw(ON OFF))
./lib/Data/Processor/Transformer.pm:    if (exists $section->{schema}->{$key}
./lib/Data/Processor/Transformer.pm:        and exists $section->{schema}->{$key}->{transformer}){
./lib/Data/Processor/Transformer.pm:                $section->{schema}->{$key}->{transformer}
./lib/Data/Processor/Transformer.pm:                ->($section->{data}->{$key},$section->{data});
./lib/Data/Processor/Transformer.pm:            if (ref $err eq 'HASH' and $err->{msg}){
./lib/Data/Processor/Transformer.pm:                $err = $err->{msg};
./lib/Data/Processor/Transformer.pm:            $section->{data}->{$key} = $return_value;
./lib/Data/Processor/Error/Instance.pm:        $self->{$_} // die "$_ missing";
./lib/Data/Processor/Error/Instance.pm:    $self->{path_array} = $self->{path};
./lib/Data/Processor/Error/Instance.pm:    $self->{path} = join '->', @{$self->{path}};
./lib/Data/Processor/Error/Instance.pm:    $self->{caller} = "$sub line $line";
./lib/Data/Processor/Error/Instance.pm:    return $self->{path}. ": " . $self->{message};
./lib/Data/Processor/Error/Collection.pm:Data::Processor::Error::Collection - Collect errors for Data::Processor
./lib/Data/Processor/Error/Collection.pm:    my $errors = Data::Processor::Error::Collection->new();
./lib/Data/Processor/Error/Collection.pm:- message
./lib/Data/Processor/Error/Collection.pm:- path
./lib/Data/Processor/Error/Collection.pm:    my $error = Data::Processor::Error::Instance->new(%p);
./lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $error;
./lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $e;
./lib/Data/Processor/Error/Collection.pm:    my @e = $other->as_array();
./lib/Data/Processor/Error/Collection.pm:        $self->add_error($_);
./lib/Data/Processor/Error/Collection.pm:  $error->collection->any_error_contains(
./lib/Data/Processor/Error/Collection.pm:    for my $error (@{$self->{errors}}){
./lib/Data/Processor/Error/Collection.pm:        return 1 if $error->{$p{field}} =~ /$p{string}/;
./lib/Data/Processor/Error/Collection.pm:    return @{$self->{errors}};
./lib/Data/Processor/Error/Collection.pm:    return scalar @{$self->{errors}};
./lib/Data/Processor.pm:Data::Processor - Transform Perl Data Structures, Validate Data against a Schema, Produce Data from a Schema, or produce documentation directly from information in the Schema.
./lib/Data/Processor.pm:                    # undef is "no-error" -> success.
./lib/Data/Processor.pm:                        if $self->{value} == 42;
./lib/Data/Processor.pm:  my $p = Data::Processor->new($schema);
./lib/Data/Processor.pm:  my $error_collection = $p->validate($data, verbose=>0);
./lib/Data/Processor.pm:  # no errors :-)
./lib/Data/Processor.pm: my $processor = Data::Processor->new($schema);
./lib/Data/Processor.pm:- indent: count of spaces to insert when printing in verbose mode. Default 4
./lib/Data/Processor.pm:- depth: level at which to start. Default is 0.
./lib/Data/Processor.pm:- verbose: Set to a true value to print messages during processing.
./lib/Data/Processor.pm:        errors      => Data::Processor::Error::Collection->new(),
./lib/Data/Processor.pm:    my $e = $self->validate_schema;
./lib/Data/Processor.pm:    if ($e->count > 0){
./lib/Data/Processor.pm:        croak "There is a problem with your schema:".join "\n", $e->as_array;
./lib/Data/Processor.pm: my $error_collection = $processor->validate($data, verbose=>0);
./lib/Data/Processor.pm:    $self->{validator}=Data::Processor::Validator->new(
./lib/Data/Processor.pm:        $self->{schema} // $p{schema},
./lib/Data/Processor.pm:        verbose     => $p{verbose} // $self->{verbose} // undef,
./lib/Data/Processor.pm:        errors      => $self->{errors},
./lib/Data/Processor.pm:        depth       => $self->{depth},
./lib/Data/Processor.pm:        indent      => $self->{indent},
./lib/Data/Processor.pm:        parent_keys => $self->{parent_keys},
./lib/Data/Processor.pm:    return $self->{validator}->validate($data);
./lib/Data/Processor.pm: my $error_collection = $processor->validate_schema();
./lib/Data/Processor.pm:    my $vf = Data::Processor::ValidatorFactory->new;
./lib/Data/Processor.pm:    my $bool = $vf->rx(qr(^[01]$),'Expected 0 or 1');
./lib/Data/Processor.pm:                    validator => $vf->rx(qr(.+),'expected a description string'),
./lib/Data/Processor.pm:                    validator => $vf->rx(qr(.+),'expected an example string'),
./lib/Data/Processor.pm:                    validator => $vf->rx(qr(.+),'expected an error message string'),
./lib/Data/Processor.pm:                        my $subVal=Data::Processor::Validator->new($schemaSchema,%$self);
./lib/Data/Processor.pm:                        my $e = $subVal->validate($value);
./lib/Data/Processor.pm:                        return ( $e->count > 0 ? join("\n", $e->as_array) : undef);
./lib/Data/Processor.pm:    return Data::Processor::Validator->new($schemaSchema,%$self)->validate($self->{schema});
./lib/Data/Processor.pm:Transforms the data in-place.
./lib/Data/Processor.pm: my $validator = Data::Processor::Validator->new($schema, data => $data)
./lib/Data/Processor.pm: my $error_string = $processor->transform($key, $validator);
./lib/Data/Processor.pm:    return Data::Processor::Transformer->new()->transform($key, $val);
./lib/Data/Processor.pm: my $data = $processor->make_data(data=>$data);
./lib/Data/Processor.pm:    my $entry_point = shift // $self->{schema};
./lib/Data/Processor.pm: my $pod_string = $processor->make_pod();
./lib/Data/Processor.pm:        $self->{schema},
./lib/Data/Processor.pm:Copyright 2015- Matthias Bloch
Übereinstimmungen in Binärdatei ./lib/Data/.Processor.pm.swp.
./.travis.yml:  - "5.20"
./.travis.yml:  - "5.16"
./.travis.yml:  - "5.14"
./.travis.yml:  - "5.12"
./.travis.yml:  - "5.10"
./Data-Processor-0.1.7/META.json:   "meta-spec" : {
./Data-Processor-0.1.7/META.json:   "name" : "Data-Processor",
./Data-Processor-0.1.7/META.json:         "web" : "https://github.com/maettu/Data-Processor/issues"
./Data-Processor-0.1.7/META.json:      "homepage" : "https://github.com/maettu/Data-Processor",
./Data-Processor-0.1.7/META.json:         "url" : "https://github.com/maettu/Data-Processor.git",
./Data-Processor-0.1.7/META.json:         "web" : "https://github.com/maettu/Data-Processor"
./Data-Processor-0.1.7/Changes:Revision history for Data-Processor
./Data-Processor-0.1.7/Changes:0.1.7  2015-01-23 20:31:53 CET
./Data-Processor-0.1.7/Changes:    - Transformer, basic (not very useful yet)
./Data-Processor-0.1.7/Changes:0.1.6  2015-01-23 16:50:55 CET
./Data-Processor-0.1.7/Changes:    - no more "require"
./Data-Processor-0.1.7/Changes:    - code cleanup
./Data-Processor-0.1.7/Changes:0.1.5  2015-01-22 16:50:24 CET
./Data-Processor-0.1.7/Changes:    - Interface change: use positional parameters for $schema, $data
./Data-Processor-0.1.7/Changes:0.1.4  2015-01-22 16:22:30 CET
./Data-Processor-0.1.7/Changes:    - array support as of t/013_array.t 
./Data-Processor-0.1.7/Changes:    - Transformer object
./Data-Processor-0.1.7/Changes:    - Error::Instance handles more
./Data-Processor-0.1.7/Changes:0.1.3  2015-01-20 09:43:14 CET
./Data-Processor-0.1.7/Changes:    - not-ready and interface change warning added
./Data-Processor-0.1.7/Changes:0.1.2  2015-01-19 11:15:29 CET
./Data-Processor-0.1.7/Changes:    - Makefile.PL instead of Build.PL
./Data-Processor-0.1.7/Changes:0.1.1  2015-01-18 21:48:47 CET
./Data-Processor-0.1.7/Changes:    - more test (mostly ported from old module)
./Data-Processor-0.1.7/Changes:    - ValidatorFactory
./Data-Processor-0.1.7/Changes:0.1.0  2015-01-18 16:50:50 CET
./Data-Processor-0.1.7/Changes:    - Error Collector added
./Data-Processor-0.1.7/Changes:    - Basic functionality: validation without frills
./Data-Processor-0.1.7/Changes:0.0.3  2015-01-15 21:37:19 CET
./Data-Processor-0.1.7/Changes:0.0.2  2015-01-15 21:31:16 CET
./Data-Processor-0.1.7/Changes:    - Code Layout
./Data-Processor-0.1.7/Changes:0.0.1  2015-01-15 19:09:03 CET
./Data-Processor-0.1.7/Changes:        - Initial release
./Data-Processor-0.1.7/META.yml:---
./Data-Processor-0.1.7/META.yml:  - 'Matthias Bloch <matthias.bloch@puffin.ch>'
./Data-Processor-0.1.7/META.yml:meta-spec:
./Data-Processor-0.1.7/META.yml:  url: http://module-build.sourceforge.net/META-spec-v1.4.html
./Data-Processor-0.1.7/META.yml:name: Data-Processor
./Data-Processor-0.1.7/META.yml:    - t
./Data-Processor-0.1.7/META.yml:    - xt
./Data-Processor-0.1.7/META.yml:    - inc
./Data-Processor-0.1.7/META.yml:    - share
./Data-Processor-0.1.7/META.yml:    - eg
./Data-Processor-0.1.7/META.yml:    - examples
./Data-Processor-0.1.7/META.yml:  bugtracker: https://github.com/maettu/Data-Processor/issues
./Data-Processor-0.1.7/META.yml:  homepage: https://github.com/maettu/Data-Processor
./Data-Processor-0.1.7/META.yml:  repository: https://github.com/maettu/Data-Processor.git
./Data-Processor-0.1.7/META.yml:  - 'Dominik Hassler <hadfl@cpan.org>'
./Data-Processor-0.1.7/META.yml:  - 'Tobias Oetiker <tobi@oetiker.ch>'
./Data-Processor-0.1.7/META.yml:  - 'maettu <matthias.bloch@puffin.ch>'
./Data-Processor-0.1.7/MANIFEST:t/release-pod-syntax.t
./Data-Processor-0.1.7/Build.PL:# This Build.PL for Data-Processor was generated by Dist::Zilla::Plugin::ModuleBuildTiny 0.008.
./Data-Processor-0.1.7/Makefile.PL:      license     => 'http://www.opensource.org/licenses/artistic-license-2.0',
./Data-Processor-0.1.7/Makefile.PL:      repository  => 'https://github.com/maettu/Data-Structure-Validation',
./Data-Processor-0.1.7/Makefile.PL:      bugtracker  => 'https://github.com/maettu/Data-Structure-Validation/issues'
./Data-Processor-0.1.7/LICENSE:This software is copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.1.7/LICENSE:--- The GNU General Public License, Version 1, February 1989 ---
./Data-Processor-0.1.7/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.1.7/LICENSE: 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
./Data-Processor-0.1.7/LICENSE:software--to make sure the software is free for all its users.  The
./Data-Processor-0.1.7/LICENSE:    a) accompany it with the complete corresponding machine-readable
./Data-Processor-0.1.7/LICENSE:    for the cost of distribution) a complete machine-readable copy of the
./Data-Processor-0.1.7/LICENSE:    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA  02110-1301 USA
./Data-Processor-0.1.7/LICENSE:c'; they could even be mouse-clicks or menu items--whatever suits your
./Data-Processor-0.1.7/LICENSE:--- The Artistic License 1.0 ---
./Data-Processor-0.1.7/LICENSE:This software is Copyright (c) 2015- by Matthias Bloch <matthias.bloch@puffin.ch>.
./Data-Processor-0.1.7/LICENSE:the package the right to use and distribute the Package in a more-or-less
./Data-Processor-0.1.7/LICENSE:  - "Package" refers to the collection of files distributed by the Copyright
./Data-Processor-0.1.7/LICENSE:  - "Standard Version" refers to such a Package if it has not been modified,
./Data-Processor-0.1.7/LICENSE:  - "Copyright Holder" is whoever is named in the copyright or copyrights for
./Data-Processor-0.1.7/LICENSE:  - "You" is you, if you're thinking about copying or distributing this Package.
./Data-Processor-0.1.7/LICENSE:  - "Reasonable copying fee" is whatever you can justify on the basis of media
./Data-Processor-0.1.7/LICENSE:  - "Freely Available" means that no fee is charged for the item itself, though
./Data-Processor-0.1.7/LICENSE:  c) rename any non-standard executables so the names do not conflict with
./Data-Processor-0.1.7/LICENSE:     manual page for each non-standard executable that clearly documents how it
./Data-Processor-0.1.7/LICENSE:  b) accompany the distribution with the machine-readable source of the Package
./Data-Processor-0.1.7/LICENSE:  c) accompany any non-standard executables with their corresponding Standard
./Data-Processor-0.1.7/LICENSE:     Version executables, giving the non-standard executables non-standard
./Data-Processor-0.1.7/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(verbose => 1);
./Data-Processor-0.1.7/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}, 'section "GENERAL" exists');
./Data-Processor-0.1.7/t/100_make_config_template.t:#~ ok (exists $config_template->{GENERAL}->{logfile}, '"logfile" exists');
./Data-Processor-0.1.7/t/100_make_config_template.t:#~ ok ($config_template->{GENERAL}->{logfile} = 'absolute path to logfile (?-xism:/.*)', 'logifle has correct content');
./Data-Processor-0.1.7/t/100_make_config_template.t:#~ my $config_template = $validator->make_config_template(entry_point => $schema->{GENERAL}->{members}->{silos});
./Data-Processor-0.1.7/t/100_make_config_template.t:#~ ok (exists $config_template->{'silo-.+'}, 'entry point "silos" found');
./Data-Processor-0.1.7/t/100_make_config_template.t:#~ ok ($config_template->{'silo-.+'}->{url} eq 'url of the silo server. Only https:// allowed(?^:https.*)',
./Data-Processor-0.1.7/t/007_no_value_check.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.7/t/007_no_value_check.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.7/t/007_no_value_check.t:ok ($error_collection->count==0, 'no errors');
./Data-Processor-0.1.7/t/007_no_value_check.t:$error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.7/t/007_no_value_check.t:ok ($error_collection->count==0, 'still no errors');
./Data-Processor-0.1.7/t/010_transformer.t:                return ($1 * $timespecfactor->{($2 || 's')});
./Data-Processor-0.1.7/t/010_transformer.t:        transformer => $transformer->{timespec}(
./Data-Processor-0.1.7/t/010_transformer.t:my $validator = Data::Processor->new($schema);
./Data-Processor-0.1.7/t/010_transformer.t:my $error_collection = $validator->validate($data, verbose=>0);
./Data-Processor-0.1.7/t/010_transformer.t:ok ($data->{history} == 3600, 'transformed "1h" into "3600"');
./Data-Processor-0.1.7/t/010_transformer.t:    history => 'regards, your error :-)',
./Data-Processor-0.1.7/t/010_transformer.t:$error_collection = $validator->validate($data);
./Data-Processor-0.1.7/t/010_transformer.t:ok ($data->{history} eq 'regards, your error :-)',
./Data-Processor-0.1.7/t/010_transformer.t:    'Could not transform "regards, your error :-)"');
./Data-Processor-0.1.7/t/010_transformer.t:ok ($error_collection->{errors}[0]->{message}
./Data-Processor-0.1.7/t/011_default_values.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.7/t/011_default_values.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.7/t/011_default_values.t:ok ($data->{key_with_default_value}==42,
./Data-Processor-0.1.7/t/005_synopsis.t:                    # undef is "no-error" -> success.
./Data-Processor-0.1.7/t/005_synopsis.t:                        if $self->{value} == 42;
./Data-Processor-0.1.7/t/005_synopsis.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.7/t/005_synopsis.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.7/t/005_synopsis.t:# no errors :-)
./Data-Processor-0.1.7/t/005_synopsis.t:ok ($error_collection->count==0, 'no errors');
./Data-Processor-0.1.7/t/013_array.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.7/t/013_array.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.7/t/013_array.t:ok ($error_collection->count == 9, '9 errors detected');
./Data-Processor-0.1.7/t/013_array.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.7/t/013_array.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.7/t/008_error_stringify.t:my $validator = Data::Processor->new($schema);
./Data-Processor-0.1.7/t/008_error_stringify.t:my $error_collection = $validator->validate($data, verbose=>0);
./Data-Processor-0.1.7/t/008_error_stringify.t:ok ($error_collection->count==1, '1 error');
./Data-Processor-0.1.7/t/008_error_stringify.t:my $msg = $error_collection->{errors}[0]->stringify();
./Data-Processor-0.1.7/t/012_factory.t:my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.1.7/t/012_factory.t:like ($vf->file('<','oops')->('/tmp/xkddf'),qr/oops/, 'error message generated');
./Data-Processor-0.1.7/t/012_factory.t:is ($vf->rx(qr{XX},'oops')->('xxXXx'),undef,'regular expression check');
./Data-Processor-0.1.7/t/012_factory.t:is ($vf->any(qw(OFF ON))->('OFF'),undef, 'is it one of the list');
./Data-Processor-0.1.7/t/012_factory.t:is ($vf->dir()->('/'),undef, 'directory exists');
./Data-Processor-0.1.7/t/002_validate.t:my $processor = Data::Processor->new($schema);
./Data-Processor-0.1.7/t/002_validate.t:eval{$processor->validate()};
./Data-Processor-0.1.7/t/002_validate.t:my $error_collection = $processor->validate($data);
./Data-Processor-0.1.7/t/002_validate.t:my @errors = $error_collection->as_array();
./Data-Processor-0.1.7/t/002_validate.t:ok ($error_collection->count()==2, 'error count =2');
./Data-Processor-0.1.7/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.7/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.7/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.7/t/002_validate.t:        string => "silo-a",
./Data-Processor-0.1.7/t/002_validate.t:    "missing value from 'silo-a'"
./Data-Processor-0.1.7/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.7/t/002_validate.t:        logfile => '/tmp/n3k-poller.log',
./Data-Processor-0.1.7/t/002_validate.t:        cachedb => '/tmp/n3k-cache.db',
./Data-Processor-0.1.7/t/002_validate.t:            'silo-a' => {
./Data-Processor-0.1.7/t/002_validate.t:                url => 'https://silo-a/api',
./Data-Processor-0.1.7/t/002_validate.t:                key => 'my-secret-shared-key',
./Data-Processor-0.1.7/t/002_validate.t:$error_collection = $processor->validate($data);
./Data-Processor-0.1.7/t/002_validate.t:ok ($error_collection->count==0, 'no more errors with corrected config');
./Data-Processor-0.1.7/t/002_validate.t:$error_collection = $processor->validate($data);
./Data-Processor-0.1.7/t/002_validate.t:ok ($error_collection->count==2, '2 errors');
./Data-Processor-0.1.7/t/002_validate.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.7/t/002_validate.t:            logfile => '/tmp/n3k-poller.log',
./Data-Processor-0.1.7/t/002_validate.t:            cachedb => '/tmp/n3k-cache.db',
./Data-Processor-0.1.7/t/002_validate.t:                'silo-a' => {
./Data-Processor-0.1.7/t/002_validate.t:                    url => 'https://silo-a/api',
./Data-Processor-0.1.7/t/002_validate.t:                    key => 'my-secret-shared-key',
./Data-Processor-0.1.7/t/002_validate.t:                    # "members" stands for all "non-internal" fields
./Data-Processor-0.1.7/t/002_validate.t:                        'silo-.+' => {
./Data-Processor-0.1.7/t/002_validate.t:                                    example     => 'https://silo-a/api',
./Data-Processor-0.1.7/t/001_basic.t:my $processor = Data::Processor->new();
./Data-Processor-0.1.7/t/006_regex_keys.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.7/t/006_regex_keys.t:my $error_collection = $p->validate($data, verbose=>0);
./Data-Processor-0.1.7/t/006_regex_keys.t:ok ($error_collection->count==3, '3 errors detected');
./Data-Processor-0.1.7/t/006_regex_keys.t:ok ($error_collection->any_error_contains(
./Data-Processor-0.1.7/t/014_transformer_direct.t:my $v = Data::Processor::Validator->new($schema, data=>$data);
./Data-Processor-0.1.7/t/014_transformer_direct.t:my $p = Data::Processor->new($schema);
./Data-Processor-0.1.7/t/014_transformer_direct.t:my $error_collection = $p->transform_data('transform_here', $v);
./Data-Processor-0.1.7/t/014_transformer_direct.t:ok ($data->{transform_here}==42, 'transformed into 42');
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:# Data::Processor::Validator - Validate Data Against a Schema
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        errors => $p{errors}  // Data::Processor::Error::Collection->new(),
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        transformer => Data::Processor::Transformer->new(),
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    $self->{data} = shift;
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    croak ('cannot validate without "data"') unless $self->{data};
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    $self->{errors} = Data::Processor::Error::Collection->new();
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    $self->_add_defaults();
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{data}}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->explain (">>'$key'");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        my $schema_key = $self->_schema_twin_key($key) or next;
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->__value_is_valid( $key );
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->__validator_returns_undef($key, $schema_key);
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        my $e = $self->{transformer}->transform($key, $self);
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->error($e) if $e;
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        if ($self->{schema}->{$schema_key}->{no_descend_into}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        if (! %{$self->{schema}->{$schema_key}}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->explain (">>skipping '$key' because schema key is empty\n'");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        if (! $self->{schema}->{$schema_key}->{members}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->explain (
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->explain (">>descending into '$key'\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        if (ref $self->{data}->{$key} eq ref {} ){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->explain
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            my $e = Data::Processor::Validator->new(
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                $self->{schema}->{$schema_key}->{members},
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                parent_keys => [@{$self->{parent_keys}}, $key],
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                depth       => $self->{depth}+1,
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                verbose     => $self->{verbose},
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            ) ->validate($self->{data}->{$key});
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->{errors}->add_collection($e);
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        elsif ((ref $self->{data}->{$key} eq ref [])
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            && $self->{schema}->{$schema_key}->{array}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->explain(
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            push @{$self->{parent_keys}}, $key;
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->{depth}++;
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            for my $member (@{$self->{data}->{$key}}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                my $e = Data::Processor::Validator->new(
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                    $self->{schema}->{$schema_key}->{members},
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                    parent_keys => [@{$self->{parent_keys}}, $key],
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                    depth       => $self->{depth}+1,
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                    verbose     => $self->{verbose},
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                ) ->validate($member);
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                $self->{errors}->add_collection($e);
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            pop @{$self->{parent_keys}};
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->{depth}--;
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        # We cannot descend into a non-existing branch in data
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->explain(">>checking data key '$key' which is a leaf..");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$schema_key}->{members}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                $self->explain("but schema requires members.\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                $self->error("'$key' should have members");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                $self->explain("schema key is also a leaf. ok.\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    # look for missing non-optional keys in schema
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    $self->_check_mandatory_keys();
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    return $self->{errors};
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    $self->{errors}->add(
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        path => $self->{parent_keys},
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    my $indent = ' ' x ($self->{depth}*$self->{indent});
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    print $string if $self->{verbose};
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        next unless $self->{schema}->{$key}->{default};
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->{data}->{$key} = $self->{schema}->{$key}->{default}
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            unless $self->{data}->{$key};
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    for my $key (keys %{$self->{schema}}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->explain(">>Checking if '$key' is mandatory: ");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        unless ($self->{schema}->{$key}->{optional}
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                   and $self->{schema}->{$key}->{optional}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->explain("true\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            next if $self->{data}->{$key};
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            # regex-keys never directly occur.
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            if ($self->{schema}->{$key}->{regex}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                $self->explain(">>regex enabled key found. ");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                $self->explain("Checking data keys.. ");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                for my $c_key (keys %{$self->{data}}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                $self->explain("$c matching occurencies found\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $error_msg = $self->{schema}->{$key}->{error_msg}
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                if $self->{schema}->{$key}->{error_msg};
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->error("mandatory key '$key' missing. Error msg: '$error_msg'");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->explain("false\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    if ($self->{schema}->{$key}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->explain(" ok\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        for my $match_key (keys %{$self->{schema}}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            next unless exists $self->{schema}->{$match_key}
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                           and $self->{schema}->{$match_key}->{regex};
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                $self->explain("'$key' matches $match_key\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->explain(">>$key not in schema, keys available: ");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->explain(join (", ", (keys %{$self->{schema}})));
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->explain("\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->error("key '$key' not found in schema\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:# 'validator' specified gets this called to call the callback :-)
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    return unless $self->{schema}->{$schema_key}->{validator};
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    $self->explain("running validator for '$key': $self->{data}->{$key}\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    if (ref $self->{data}->{$key} eq ref []
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        && $self->{schema}->{$key}->{array}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        for my $elem (@{$self->{data}->{$key}}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            my $return_value = $self->{schema}->{$key}->{validator}->($elem, $self->{data});
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                $self->explain("validator error: $return_value (element $counter)\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                $self->error("Execution of validator for '$key' element $counter returns with error: $return_value");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                $self->explain("successful validation for key '$key' element $counter\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        my $return_value = $self->{schema}->{$key}->{validator}->($self->{data}->{$key}, $self->{data});
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->explain("validator error: $return_value\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->error("Execution of validator for '$key' returns with error: $return_value");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->explain("successful validation for key '$key'\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:    if (exists  $self->{schema}->{$key}
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            and $self->{schema}->{$key}->{value}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        $self->explain('>>'.ref($self->{schema}->{$key}->{value})."\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        if (ref($self->{schema}->{$key}->{value}) eq 'CODE'){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:        elsif (ref($self->{schema}->{$key}->{value}) eq 'Regexp'){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            if (ref $self->{data}->{$key} eq ref []
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                && $self->{schema}->{$key}->{array}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                for my $elem (@{$self->{data}->{$key}}){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                    $self->explain(">>match '$elem' against '$self->{schema}->{$key}->{value}'");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                    if ($elem =~ m/^$self->{schema}->{$key}->{value}$/){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                        $self->explain(" ok.\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                        $self->explain(" no.\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                        $self->error("$elem does not match ^$self->{schema}->{$key}->{value}\$");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:               $self->explain(">>match '$self->{data}->{$key}' against '$self->{schema}->{$key}->{value}'");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                if ($self->{data}->{$key} =~ m/^$self->{schema}->{$key}->{value}$/){
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                    $self->explain(" ok.\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                    $self->explain(" no.\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:                    $self->error("$self->{data}->{$key} does not match ^$self->{schema}->{$key}->{value}\$");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->explain("neither CODE nor Regexp\n");
./Data-Processor-0.1.7/lib/Data/Processor/Validator.pm:            $self->error("'$key' not CODE nor Regexp");
./Data-Processor-0.1.7/lib/Data/Processor/ValidatorFactory.pm:Data::Processor::ValidatorFactory - create validators for use in schemas
./Data-Processor-0.1.7/lib/Data/Processor/ValidatorFactory.pm: my $vf = Data::Processor::ValidatorFactory->new;
./Data-Processor-0.1.7/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->file('>','writing'),
./Data-Processor-0.1.7/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->rx(qr{[A-Z]+},'expected name made up from capital letters')
./Data-Processor-0.1.7/lib/Data/Processor/ValidatorFactory.pm:        validator => $vf->any(qw(UP DOWN))
./Data-Processor-0.1.7/lib/Data/Processor/ValidatorFactory.pm: $vf->file('<','reading');
./Data-Processor-0.1.7/lib/Data/Processor/ValidatorFactory.pm: $vf->file('>>','appending to');
./Data-Processor-0.1.7/lib/Data/Processor/ValidatorFactory.pm: $vf->dir();
./Data-Processor-0.1.7/lib/Data/Processor/ValidatorFactory.pm:        return undef if -d $value;
./Data-Processor-0.1.7/lib/Data/Processor/ValidatorFactory.pm: $vf->rx(qr{[A-Z]+},'use uppercase letters')
./Data-Processor-0.1.7/lib/Data/Processor/ValidatorFactory.pm: $vf->any(qw(ON OFF))
./Data-Processor-0.1.7/lib/Data/Processor/Transformer.pm:    if (exists $section->{schema}->{$key}
./Data-Processor-0.1.7/lib/Data/Processor/Transformer.pm:        and exists $section->{schema}->{$key}->{transformer}){
./Data-Processor-0.1.7/lib/Data/Processor/Transformer.pm:                $section->{schema}->{$key}->{transformer}
./Data-Processor-0.1.7/lib/Data/Processor/Transformer.pm:                ->($section->{data}->{$key},$section->{data});
./Data-Processor-0.1.7/lib/Data/Processor/Transformer.pm:            if (ref $err eq 'HASH' and $err->{msg}){
./Data-Processor-0.1.7/lib/Data/Processor/Transformer.pm:                $err = $err->{msg};
./Data-Processor-0.1.7/lib/Data/Processor/Transformer.pm:            $section->{data}->{$key} = $return_value;
./Data-Processor-0.1.7/lib/Data/Processor/Error/Instance.pm:        $self->{$_} // die "$_ missing";
./Data-Processor-0.1.7/lib/Data/Processor/Error/Instance.pm:    $self->{path_array} = $self->{path};
./Data-Processor-0.1.7/lib/Data/Processor/Error/Instance.pm:    $self->{path} = join '->', @{$self->{path}};
./Data-Processor-0.1.7/lib/Data/Processor/Error/Instance.pm:    $self->{caller} = "$sub line $line";
./Data-Processor-0.1.7/lib/Data/Processor/Error/Instance.pm:    return $self->{path}. ": " . $self->{message};
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:Data::Processor::Error::Collection - Collect errors for Data::Processor
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:    my $errors = Data::Processor::Error::Collection->new();
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:- message
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:- path
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:    my $error = Data::Processor::Error::Instance->new(%p);
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $error;
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:    push @{$self->{errors}}, $e;
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:    my @e = $other->as_array();
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:        $self->add_error($_);
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:  $error->collection->any_error_contains(
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:    for my $error (@{$self->{errors}}){
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:        return 1 if $error->{$p{field}} =~ /$p{string}/;
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:    return @{$self->{errors}};
./Data-Processor-0.1.7/lib/Data/Processor/Error/Collection.pm:    return scalar @{$self->{errors}};
./Data-Processor-0.1.7/lib/Data/Processor.pm:Data::Processor - Transform Perl Data Structures, Validate Data against a Schema, Produce Data from a Schema, or produce documentation directly from information in the Data
./Data-Processor-0.1.7/lib/Data/Processor.pm: my $processor = Data::Processor->new($schema);
./Data-Processor-0.1.7/lib/Data/Processor.pm:- indent: count of spaces to insert when printing in verbose mode. Default 4
./Data-Processor-0.1.7/lib/Data/Processor.pm:- depth: level at which to start. Default is 0.
./Data-Processor-0.1.7/lib/Data/Processor.pm:- verbose: Set to a true value to print messages during processing.
./Data-Processor-0.1.7/lib/Data/Processor.pm:        errors      => Data::Processor::Error::Collection->new(),
./Data-Processor-0.1.7/lib/Data/Processor.pm: my @errors = $processor->validate($data, verbose=>0);
./Data-Processor-0.1.7/lib/Data/Processor.pm:    $self->{validator}=Data::Processor::Validator->new(
./Data-Processor-0.1.7/lib/Data/Processor.pm:        $self->{schema} // $p{schema},
./Data-Processor-0.1.7/lib/Data/Processor.pm:        verbose     => $p{verbose} // $self->{verbose} // undef,
./Data-Processor-0.1.7/lib/Data/Processor.pm:        errors      => $self->{errors},
./Data-Processor-0.1.7/lib/Data/Processor.pm:        depth       => $self->{depth},
./Data-Processor-0.1.7/lib/Data/Processor.pm:        indent      => $self->{indent},
./Data-Processor-0.1.7/lib/Data/Processor.pm:        parent_keys => $self->{parent_keys},
./Data-Processor-0.1.7/lib/Data/Processor.pm:    return $self->{validator}->validate($data);
./Data-Processor-0.1.7/lib/Data/Processor.pm:Transforms the data in-place.
./Data-Processor-0.1.7/lib/Data/Processor.pm: my $validator = Data::Processor::Validator->new($schema, data => $data)
./Data-Processor-0.1.7/lib/Data/Processor.pm: my $error_string = $processor->transform($key, $validator);
./Data-Processor-0.1.7/lib/Data/Processor.pm:    return Data::Processor::Transformer->new()->transform($key, $val);
./Data-Processor-0.1.7/lib/Data/Processor.pm: my ($schema_transformed, @errors) = $processor->transform_schema(schema=>$schema);
./Data-Processor-0.1.7/lib/Data/Processor.pm: my ($data, @errors) = $processor->make_data(data=>$data);
./Data-Processor-0.1.7/lib/Data/Processor.pm: my ($pod, @errors) = $processor->make_pod(data=>$data);
./Data-Processor-0.1.7/lib/Data/Processor.pm:Copyright 2015- Matthias Bloch
Übereinstimmungen in Binärdatei ./Data-Processor-0.1.7.tar.gz.
